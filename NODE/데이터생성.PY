import pandas as pd
import numpy as np
from datetime import datetime, timedelta
import random
import json
import os

def generate_semiconductor_mcs_data(num_records=100):
    """
    ë°˜ë„ì²´ FAB MCS(Material Control System) ë¬¼ë¥˜ ë¡œê·¸ ìƒ˜í”Œ ë°ì´í„° ìƒì„±
    """
    
    # ê¸°ì¤€ ì‹œì‘ ì‹œê°„
    base_time = datetime(2025, 7, 1, 0, 0, 0)
    
    # FAB ë¼ì¸ ë° ë² ì´ ì •ë³´
    fab_lines = ['FAB1', 'FAB2', 'FAB3']
    bays = {
        'PHOTO': 'í¬í† ê³µì •',
        'ETCH': 'ì‹ê°ê³µì •',
        'DIFF': 'í™•ì‚°ê³µì •',
        'IMPLANT': 'ì´ì˜¨ì£¼ì…',
        'CVD': 'CVDê³µì •',
        'PVD': 'PVDê³µì •',
        'CMP': 'CMPê³µì •',
        'CLEAN': 'ì„¸ì •ê³µì •',
        'METROLOGY': 'ê³„ì¸¡ê³µì •',
        'TEST': 'í…ŒìŠ¤íŠ¸ê³µì •'
    }
    
    # ì¥ë¹„ íƒ€ì…
    equipment_types = {
        'ASML': ['ASML_NXT_1980', 'ASML_NXT_2050', 'ASML_XT_1460'],
        'AMAT': ['AMAT_ENDURA', 'AMAT_CENTURA', 'AMAT_PRODUCER'],
        'LAM': ['LAM_KIYO', 'LAM_VERSYS', 'LAM_FLEX'],
        'TEL': ['TEL_CLEAN', 'TEL_COAT', 'TEL_ETCH'],
        'KLA': ['KLA_2935', 'KLA_SP5', 'KLA_AIT']
    }
    
    # ìºë¦¬ì–´ íƒ€ì…
    carrier_types = ['FOUP', 'FOSB', 'OPEN_CASSETTE']
    
    # ì›¨ì´í¼ ì‚¬ì´ì¦ˆ
    wafer_sizes = ['200mm', '300mm']
    
    # ì œí’ˆ ì½”ë“œ
    product_codes = ['DRAM_16G', 'DRAM_32G', 'NAND_512G', 'NAND_1T', 
                     'LOGIC_7NM', 'LOGIC_5NM', 'ANALOG_28NM']
    
    # ìš°ì„ ìˆœìœ„
    priorities = ['NORMAL', 'HOT_LOT', 'SUPER_HOT', 'ENGINEERING', 'PILOT']
    
    # MCS ì´ë²¤íŠ¸ íƒ€ì…
    event_types = [
        'LOAD_REQUEST',      # ì ì¬ ìš”ì²­
        'UNLOAD_REQUEST',    # í•˜ì—­ ìš”ì²­
        'TRANSFER_START',    # ì´ì†¡ ì‹œì‘
        'TRANSFER_COMPLETE', # ì´ì†¡ ì™„ë£Œ
        'STOCKER_IN',       # ìŠ¤í† ì»¤ ì…ê³ 
        'STOCKER_OUT',      # ìŠ¤í† ì»¤ ì¶œê³ 
        'LOADPORT_LOAD',    # ë¡œë“œí¬íŠ¸ ì ì¬
        'LOADPORT_UNLOAD',  # ë¡œë“œí¬íŠ¸ í•˜ì—­
        'CARRIER_WAIT',     # ìºë¦¬ì–´ ëŒ€ê¸°
        'ALARM_OCCURRED'    # ì•ŒëŒ ë°œìƒ
    ]
    
    # ìš´ë°˜ ì¥ë¹„
    transport_vehicles = ['OHT', 'OHS', 'AGV', 'RGV', 'MANUAL']
    
    # ì•ŒëŒ ì½”ë“œ (ì‹¤ì œ MCSì—ì„œ ì‚¬ìš©í•˜ëŠ” í˜•ì‹)
    alarm_codes = ['E84_TIMEOUT', 'CARRIER_ID_MISMATCH', 'VEHICLE_COLLISION_RISK', 
                   'LOADPORT_ERROR', 'STOCKER_FULL', 'PATH_BLOCKED']
    
    records = []
    
    # LOT ë‹¨ìœ„ë¡œ ë°ì´í„° ìƒì„±
    lot_count = num_records // 5  # í‰ê·  5ê°œ ì´ë²¤íŠ¸ per LOT
    
    for lot_idx in range(lot_count):
        # LOT ì •ë³´ ìƒì„±
        lot_id = f"LOT{2025070000 + lot_idx:010d}"
        carrier_id = f"CAR{random.randint(10000, 99999)}"
        product = random.choice(product_codes)
        priority = random.choice(priorities)
        wafer_size = random.choice(wafer_sizes)
        wafer_count = 25 if wafer_size == '300mm' else 50
        
        # LOTì˜ ë¼ìš°íŒ… (ê³µì • ìˆœì„œ)
        num_steps = random.randint(3, 7)
        route = random.sample(list(bays.keys()), num_steps)
        
        # ì‹œì‘ ì‹œê°„
        current_time = base_time + timedelta(
            days=random.randint(0, 29),
            hours=random.randint(0, 23),
            minutes=random.randint(0, 59)
        )
        
        # ê° ê³µì • ë‹¨ê³„ë³„ ì´ë²¤íŠ¸ ìƒì„±
        for step_idx, bay in enumerate(route):
            # ì´ì†¡ ìš”ì²­
            records.append({
                'timestamp': current_time.strftime('%Y-%m-%d %H:%M:%S'),
                'event_type': 'TRANSFER_START',
                'lot_id': lot_id,
                'carrier_id': carrier_id,
                'carrier_type': random.choice(carrier_types),
                'product_code': product,
                'wafer_size': wafer_size,
                'wafer_count': wafer_count,
                'priority': priority,
                'from_location': route[step_idx-1] if step_idx > 0 else 'STOCKER_01',
                'to_location': bay,
                'vehicle_id': f"{random.choice(transport_vehicles)}_{random.randint(100, 999)}",
                'fab_line': random.choice(fab_lines),
                'step_number': f"{(step_idx + 1) * 100}",
                'recipe': f"{bay}_RECIPE_{random.randint(1, 5)}",
                'temperature': round(20 + random.random() * 5, 1),
                'humidity': round(45 + random.random() * 10, 1),
                'particle_count': random.randint(0, 50),
                'status': 'IN_TRANSIT',
                'alarm_code': None,
                'transfer_time_sec': None
            })
            
            # ì´ì†¡ ì‹œê°„ (ì´ˆ)
            transfer_time = random.randint(30, 300)
            current_time += timedelta(seconds=transfer_time)
            
            # ì´ì†¡ ì™„ë£Œ
            records.append({
                'timestamp': current_time.strftime('%Y-%m-%d %H:%M:%S'),
                'event_type': 'TRANSFER_COMPLETE',
                'lot_id': lot_id,
                'carrier_id': carrier_id,
                'carrier_type': random.choice(carrier_types),
                'product_code': product,
                'wafer_size': wafer_size,
                'wafer_count': wafer_count,
                'priority': priority,
                'from_location': route[step_idx-1] if step_idx > 0 else 'STOCKER_01',
                'to_location': bay,
                'vehicle_id': f"{random.choice(transport_vehicles)}_{random.randint(100, 999)}",
                'fab_line': random.choice(fab_lines),
                'step_number': f"{(step_idx + 1) * 100}",
                'recipe': f"{bay}_RECIPE_{random.randint(1, 5)}",
                'temperature': round(20 + random.random() * 5, 1),
                'humidity': round(45 + random.random() * 10, 1),
                'particle_count': random.randint(0, 50),
                'status': 'ARRIVED',
                'alarm_code': None,
                'transfer_time_sec': transfer_time
            })
            
            # ì¥ë¹„ì— ë¡œë“œ
            current_time += timedelta(seconds=random.randint(10, 60))
            
            # ê°€ë” ì•ŒëŒ ë°œìƒ
            if random.random() < 0.1:  # 10% í™•ë¥ 
                records.append({
                    'timestamp': current_time.strftime('%Y-%m-%d %H:%M:%S'),
                    'event_type': 'ALARM_OCCURRED',
                    'lot_id': lot_id,
                    'carrier_id': carrier_id,
                    'carrier_type': random.choice(carrier_types),
                    'product_code': product,
                    'wafer_size': wafer_size,
                    'wafer_count': wafer_count,
                    'priority': priority,
                    'from_location': bay,
                    'to_location': bay,
                    'vehicle_id': None,
                    'fab_line': random.choice(fab_lines),
                    'step_number': f"{(step_idx + 1) * 100}",
                    'recipe': f"{bay}_RECIPE_{random.randint(1, 5)}",
                    'temperature': round(20 + random.random() * 5, 1),
                    'humidity': round(45 + random.random() * 10, 1),
                    'particle_count': random.randint(0, 50),
                    'status': 'ALARM',
                    'alarm_code': random.choice(alarm_codes),
                    'transfer_time_sec': None
                })
                current_time += timedelta(minutes=random.randint(5, 30))
            
            # ê³µì • ì‹œê°„
            process_time = random.randint(30, 180)  # 30ë¶„ ~ 3ì‹œê°„
            current_time += timedelta(minutes=process_time)
    
    # DataFrame ìƒì„±
    df = pd.DataFrame(records[:num_records])  # ì •í™•íˆ 100ê°œë§Œ
    
    # ì‹œê°„ìˆœ ì •ë ¬
    df['timestamp'] = pd.to_datetime(df['timestamp'])
    df = df.sort_values('timestamp').reset_index(drop=True)
    
    return df


def generate_vibration_sensor_data(num_records=100):
    """
    ë°˜ë„ì²´ ì¥ë¹„ ì§„ë™ì„¼ì„œ ë°ì´í„° ìƒì„±
    OHT(Overhead Hoist Transport) ë° ì£¼ìš” ì¥ë¹„ì˜ ì§„ë™ ë°ì´í„°
    """
    
    # ê¸°ì¤€ ì‹œì‘ ì‹œê°„
    base_time = datetime(2025, 7, 1, 0, 0, 0)
    
    # ì„¼ì„œ ìœ„ì¹˜ (ì¥ë¹„ íƒ€ì…ë³„)
    sensor_locations = {
        'OHT_RAIL': ['OHT_RAIL_A1', 'OHT_RAIL_A2', 'OHT_RAIL_B1', 'OHT_RAIL_B2'],
        'OHT_VEHICLE': ['OHT_001', 'OHT_002', 'OHT_003', 'OHT_004', 'OHT_005'],
        'STOCKER': ['STK_01_TOP', 'STK_01_MID', 'STK_02_TOP', 'STK_02_MID'],
        'EQUIPMENT': ['ASML_1980_01', 'AMAT_ENDURA_01', 'LAM_KIYO_01', 'TEL_CLEAN_01'],
        'LOADPORT': ['LP_PHOTO_01', 'LP_ETCH_01', 'LP_CVD_01', 'LP_CMP_01']
    }
    
    # ì§„ë™ ìƒíƒœ
    vibration_states = {
        'NORMAL': {'x_range': (0.1, 0.5), 'y_range': (0.1, 0.5), 'z_range': (0.2, 0.8)},
        'WARNING': {'x_range': (0.5, 1.5), 'y_range': (0.5, 1.5), 'z_range': (0.8, 2.0)},
        'CRITICAL': {'x_range': (1.5, 3.0), 'y_range': (1.5, 3.0), 'z_range': (2.0, 4.0)},
        'MAINTENANCE': {'x_range': (0.05, 0.2), 'y_range': (0.05, 0.2), 'z_range': (0.1, 0.3)}
    }
    
    records = []
    
    # ê° ì„¼ì„œë³„ë¡œ ì‹œê³„ì—´ ë°ì´í„° ìƒì„±
    all_sensors = []
    for location_type, sensors in sensor_locations.items():
        all_sensors.extend([(location_type, sensor) for sensor in sensors])
    
    # ë ˆì½”ë“œ ìˆ˜ë¥¼ ì„¼ì„œë³„ë¡œ ë¶„ë°°
    records_per_sensor = num_records // len(all_sensors)
    remaining_records = num_records % len(all_sensors)
    
    for idx, (location_type, sensor_id) in enumerate(all_sensors):
        # ì´ ì„¼ì„œì˜ ë ˆì½”ë“œ ìˆ˜
        sensor_records = records_per_sensor + (1 if idx < remaining_records else 0)
        
        # ì„¼ì„œë³„ ì´ˆê¸° ìƒíƒœ
        current_state = 'NORMAL'
        base_vibration_level = random.uniform(0.2, 0.4)
        
        for i in range(sensor_records):
            # ì‹œê°„ ì¦ê°€ (1ë¶„ ê°„ê²©)
            timestamp = base_time + timedelta(minutes=i + idx * records_per_sensor)
            
            # ê°€ë” ìƒíƒœ ë³€ê²½ (10% í™•ë¥ )
            if random.random() < 0.1:
                current_state = random.choice(list(vibration_states.keys()))
            
            # ì§„ë™ ê°’ ìƒì„±
            state_config = vibration_states[current_state]
            
            # ê¸°ë³¸ ì§„ë™ + ë…¸ì´ì¦ˆ
            vibration_x = random.uniform(*state_config['x_range']) + random.gauss(0, 0.05)
            vibration_y = random.uniform(*state_config['y_range']) + random.gauss(0, 0.05)
            vibration_z = random.uniform(*state_config['z_range']) + random.gauss(0, 0.08)
            
            # OHT ì´ë™ ì¤‘ì¼ ë•Œ ì§„ë™ ì¦ê°€
            if location_type == 'OHT_VEHICLE' and random.random() < 0.3:
                vibration_x *= 1.5
                vibration_y *= 1.5
                vibration_z *= 2.0
            
            # RMS ê°’ ê³„ì‚°
            rms_value = np.sqrt((vibration_x**2 + vibration_y**2 + vibration_z**2) / 3)
            
            # ì£¼íŒŒìˆ˜ ìŠ¤í™íŠ¸ëŸ¼ (ê°„ë‹¨í•œ ì‹œë®¬ë ˆì´ì…˜)
            dominant_frequency = random.uniform(10, 500)
            
            # FFT í”¼í¬ ê°’ë“¤
            fft_peaks = {
                'peak_1_freq': dominant_frequency,
                'peak_1_amp': random.uniform(0.1, 0.5),
                'peak_2_freq': dominant_frequency * 2,  # í•˜ëª¨ë‹‰
                'peak_2_amp': random.uniform(0.05, 0.2),
                'peak_3_freq': dominant_frequency * 3,
                'peak_3_amp': random.uniform(0.02, 0.1)
            }
            
            # ì˜¨ë„ (ì§„ë™ê³¼ ì•½ê°„ì˜ ìƒê´€ê´€ê³„)
            temperature = 25 + base_vibration_level * 10 + random.gauss(0, 2)
            
            record = {
                'timestamp': timestamp.strftime('%Y-%m-%d %H:%M:%S'),
                'sensor_id': sensor_id,
                'location_type': location_type,
                'vibration_x_mm_s': round(vibration_x, 4),
                'vibration_y_mm_s': round(vibration_y, 4),
                'vibration_z_mm_s': round(vibration_z, 4),
                'rms_mm_s': round(rms_value, 4),
                'dominant_frequency_hz': round(dominant_frequency, 2),
                'peak_1_frequency_hz': round(fft_peaks['peak_1_freq'], 2),
                'peak_1_amplitude': round(fft_peaks['peak_1_amp'], 4),
                'peak_2_frequency_hz': round(fft_peaks['peak_2_freq'], 2),
                'peak_2_amplitude': round(fft_peaks['peak_2_amp'], 4),
                'temperature_c': round(temperature, 1),
                'vibration_state': current_state,
                'threshold_exceeded': current_state in ['WARNING', 'CRITICAL'],
                'maintenance_required': current_state == 'CRITICAL',
                'sensor_health': 'GOOD' if random.random() > 0.05 else 'CHECK'
            }
            
            records.append(record)
    
    # DataFrame ìƒì„± ë° ì •ë ¬
    df = pd.DataFrame(records[:num_records])  # ì •í™•íˆ ìš”ì²­ëœ ìˆ˜ë§Œí¼
    df['timestamp'] = pd.to_datetime(df['timestamp'])
    df = df.sort_values(['sensor_id', 'timestamp']).reset_index(drop=True)
    
    return df


def save_data_files(mcs_df, vibration_df):
    """
    ë°ì´í„°ë¥¼ ë‹¤ì–‘í•œ í˜•ì‹ìœ¼ë¡œ ì €ì¥
    """
    # ì¶œë ¥ ë””ë ‰í† ë¦¬ ìƒì„±
    output_dir = "semiconductor_test_data"
    if not os.path.exists(output_dir):
        os.makedirs(output_dir)
    
    # MCS ë°ì´í„° ì €ì¥
    mcs_path = os.path.join(output_dir, "mcs_data")
    if not os.path.exists(mcs_path):
        os.makedirs(mcs_path)
    
    # CSV
    mcs_df.to_csv(os.path.join(mcs_path, 'semiconductor_mcs_data.csv'), 
                  index=False, encoding='utf-8-sig')
    
    # JSON
    mcs_df_json = mcs_df.copy()
    mcs_df_json['timestamp'] = mcs_df_json['timestamp'].astype(str)
    mcs_df_json.to_json(os.path.join(mcs_path, 'semiconductor_mcs_data.json'), 
                        orient='records', force_ascii=False, indent=2)
    
    # Excel
    with pd.ExcelWriter(os.path.join(mcs_path, 'semiconductor_mcs_data.xlsx'), 
                        engine='openpyxl') as writer:
        mcs_df.to_excel(writer, sheet_name='MCS_LOG', index=False)
        
        # ìš”ì•½ í†µê³„
        summary_df = pd.DataFrame({
            'í•­ëª©': ['ì´ ë ˆì½”ë“œ ìˆ˜', 'ê³ ìœ  LOT ìˆ˜', 'ê³ ìœ  ìºë¦¬ì–´ ìˆ˜', 'ì•ŒëŒ ë°œìƒ ìˆ˜', 
                    'í‰ê·  ì´ì†¡ ì‹œê°„(ì´ˆ)', 'ê°€ì¥ ë§ì€ ê³µì •'],
            'ê°’': [
                len(mcs_df),
                mcs_df['lot_id'].nunique(),
                mcs_df['carrier_id'].nunique(),
                len(mcs_df[mcs_df['event_type'] == 'ALARM_OCCURRED']),
                mcs_df[mcs_df['transfer_time_sec'].notna()]['transfer_time_sec'].mean(),
                mcs_df['to_location'].mode()[0] if len(mcs_df) > 0 else 'N/A'
            ]
        })
        summary_df.to_excel(writer, sheet_name='Summary', index=False)
    
    print("âœ… MCS ë°ì´í„° ì €ì¥ ì™„ë£Œ")
    
    # ì§„ë™ì„¼ì„œ ë°ì´í„° ì €ì¥
    vibration_path = os.path.join(output_dir, "vibration_data")
    if not os.path.exists(vibration_path):
        os.makedirs(vibration_path)
    
    # CSV
    vibration_df.to_csv(os.path.join(vibration_path, 'vibration_sensor_data.csv'), 
                        index=False, encoding='utf-8-sig')
    
    # JSON
    vibration_df_json = vibration_df.copy()
    vibration_df_json['timestamp'] = vibration_df_json['timestamp'].astype(str)
    vibration_df_json.to_json(os.path.join(vibration_path, 'vibration_sensor_data.json'), 
                              orient='records', force_ascii=False, indent=2)
    
    # Excel
    with pd.ExcelWriter(os.path.join(vibration_path, 'vibration_sensor_data.xlsx'), 
                        engine='openpyxl') as writer:
        vibration_df.to_excel(writer, sheet_name='Vibration_Data', index=False)
        
        # ì„¼ì„œë³„ í†µê³„
        sensor_stats = vibration_df.groupby('sensor_id').agg({
            'rms_mm_s': ['mean', 'max', 'std'],
            'threshold_exceeded': 'sum',
            'maintenance_required': 'sum'
        }).round(4)
        sensor_stats.columns = ['í‰ê· _RMS', 'ìµœëŒ€_RMS', 'RMS_í‘œì¤€í¸ì°¨', 'ì„ê³„ê°’_ì´ˆê³¼_íšŸìˆ˜', 'ìœ ì§€ë³´ìˆ˜_í•„ìš”_íšŸìˆ˜']
        sensor_stats.to_excel(writer, sheet_name='Sensor_Statistics')
    
    print("âœ… ì§„ë™ì„¼ì„œ ë°ì´í„° ì €ì¥ ì™„ë£Œ")
    
    # í†µí•© ë¶„ì„ ë¦¬í¬íŠ¸
    print("\nğŸ“Š í†µí•© ë¶„ì„ ë¦¬í¬íŠ¸ ìƒì„± ì¤‘...")
    
    # ì‹œê°„ëŒ€ë³„ ìƒê´€ê´€ê³„ ë¶„ì„
    mcs_hourly = mcs_df.set_index('timestamp').resample('H').size()
    vibration_hourly = vibration_df[vibration_df['threshold_exceeded']].set_index('timestamp').resample('H').size()
    
    correlation_df = pd.DataFrame({
        'MCS_ì´ë²¤íŠ¸_ìˆ˜': mcs_hourly,
        'ì§„ë™_ì„ê³„ê°’_ì´ˆê³¼': vibration_hourly
    }).fillna(0)
    
    with pd.ExcelWriter(os.path.join(output_dir, 'integrated_analysis_report.xlsx'), 
                        engine='openpyxl') as writer:
        correlation_df.to_excel(writer, sheet_name='Hourly_Correlation')
        
        # ìš”ì•½ ì •ë³´
        summary_data = {
            'í•­ëª©': ['MCS ì´ ì´ë²¤íŠ¸', 'MCS ì•ŒëŒ ë°œìƒ', 'ì§„ë™ì„¼ì„œ ì„ê³„ê°’ ì´ˆê³¼', 
                    'ì§„ë™ì„¼ì„œ ìœ ì§€ë³´ìˆ˜ í•„ìš”', 'ë¶„ì„ ê¸°ê°„(ì¼)'],
            'ê°’': [
                len(mcs_df),
                len(mcs_df[mcs_df['event_type'] == 'ALARM_OCCURRED']),
                vibration_df['threshold_exceeded'].sum(),
                vibration_df['maintenance_required'].sum(),
                (mcs_df['timestamp'].max() - mcs_df['timestamp'].min()).days
            ]
        }
        summary_df = pd.DataFrame(summary_data)
        summary_df.to_excel(writer, sheet_name='Summary', index=False)
    
    print("âœ… í†µí•© ë¶„ì„ ë¦¬í¬íŠ¸ ì €ì¥ ì™„ë£Œ")
    
    return output_dir


def main():
    """
    ë©”ì¸ ì‹¤í–‰ í•¨ìˆ˜
    """
    print("="*60)
    print("ğŸ­ ë°˜ë„ì²´ ë¬¼ë¥˜ ì˜ˆì¸¡ ì‹œìŠ¤í…œ - í…ŒìŠ¤íŠ¸ ë°ì´í„° ìƒì„±")
    print("="*60)
    print(f"ì‹¤í–‰ ì‹œê°„: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
    print()
    
    # 1. MCS ë°ì´í„° ìƒì„±
    print("1ï¸âƒ£ MCS ë°ì´í„° ìƒì„± ì¤‘...")
    mcs_df = generate_semiconductor_mcs_data(100)
    print(f"   - ìƒì„±ëœ ë ˆì½”ë“œ: {len(mcs_df)}ê°œ")
    print(f"   - ê¸°ê°„: {mcs_df['timestamp'].min()} ~ {mcs_df['timestamp'].max()}")
    
    # 2. ì§„ë™ì„¼ì„œ ë°ì´í„° ìƒì„±
    print("\n2ï¸âƒ£ ì§„ë™ì„¼ì„œ ë°ì´í„° ìƒì„± ì¤‘...")
    vibration_df = generate_vibration_sensor_data(100)
    print(f"   - ìƒì„±ëœ ë ˆì½”ë“œ: {len(vibration_df)}ê°œ")
    print(f"   - ì„¼ì„œ ìˆ˜: {vibration_df['sensor_id'].nunique()}ê°œ")
    
    # 3. íŒŒì¼ ì €ì¥
    print("\n3ï¸âƒ£ ë°ì´í„° íŒŒì¼ ì €ì¥ ì¤‘...")
    output_dir = save_data_files(mcs_df, vibration_df)
    
    # 4. ê²°ê³¼ ìš”ì•½
    print("\n" + "="*60)
    print("âœ¨ í…ŒìŠ¤íŠ¸ ë°ì´í„° ìƒì„± ì™„ë£Œ!")
    print("="*60)
    print(f"\nğŸ“ ìƒì„±ëœ íŒŒì¼ ìœ„ì¹˜: {os.path.abspath(output_dir)}")
    print("\nğŸ“„ ìƒì„±ëœ íŒŒì¼ ëª©ë¡:")
    print("  MCS ë°ì´í„°:")
    print("    - semiconductor_mcs_data.csv")
    print("    - semiconductor_mcs_data.json")
    print("    - semiconductor_mcs_data.xlsx")
    print("\n  ì§„ë™ì„¼ì„œ ë°ì´í„°:")
    print("    - vibration_sensor_data.csv")
    print("    - vibration_sensor_data.json")
    print("    - vibration_sensor_data.xlsx")
    print("\n  í†µí•© ë¶„ì„:")
    print("    - integrated_analysis_report.xlsx")
    
    # 5. ì‚¬ìš© ì•ˆë‚´
    print("\nğŸ“Œ ì‚¬ìš© ë°©ë²•:")
    print("1. ë…¸ë“œ ì—ë””í„°ë¥¼ ì‹¤í–‰í•˜ì„¸ìš”")
    print("2. 'ë°ì´í„° ì…ë ¥' ë…¸ë“œë¥¼ ì¶”ê°€í•˜ê³  ìƒì„±ëœ CSV íŒŒì¼ì„ ì„ íƒí•˜ì„¸ìš”")
    print("3. ì „ì²˜ë¦¬ â†’ ë¶„ì„ â†’ í”„ë¡¬í”„íŠ¸ â†’ LLM ìˆœì„œë¡œ ë…¸ë“œë¥¼ ì—°ê²°í•˜ì„¸ìš”")
    print("4. íŒŒì´í”„ë¼ì¸ì„ ì‹¤í–‰í•˜ì—¬ ì˜ˆì¸¡ ê²°ê³¼ë¥¼ í™•ì¸í•˜ì„¸ìš”")
    
    # 6. ìƒ˜í”Œ ë°ì´í„° ë¯¸ë¦¬ë³´ê¸°
    print("\nğŸ“Š MCS ìƒ˜í”Œ ë°ì´í„° (ì²˜ìŒ 3ê°œ):")
    print(mcs_df[['timestamp', 'event_type', 'lot_id', 'from_location', 'to_location']].head(3))
    
    print("\nğŸ“Š ì§„ë™ì„¼ì„œ ìƒ˜í”Œ ë°ì´í„° (ì²˜ìŒ 3ê°œ):")
    print(vibration_df[['timestamp', 'sensor_id', 'rms_mm_s', 'vibration_state']].head(3))
    
    return mcs_df, vibration_df


if __name__ == "__main__":
    # pandas ì˜µì…˜ ì„¤ì •
    pd.set_option('display.max_columns', None)
    pd.set_option('display.width', None)
    pd.set_option('display.max_colwidth', 50)
    
    # ë©”ì¸ í•¨ìˆ˜ ì‹¤í–‰
    mcs_df, vibration_df = main()