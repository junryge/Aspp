# -*- coding: utf-8 -*-

pip install llama-cpp-python --force-reinstall --no-cache-dir

# ê¸°ì¡´ ì‚­ì œ
pip uninstall llama-cpp-python -y

# Python 3.11 Windows CPU ë²„ì „ ì§ì ‘ ì„¤ì¹˜
pip install https://github.com/abetlen/llama-cpp-python/releases/download/v0.2.90/llama_cpp_python-0.2.90-cp311-cp311-win_amd64.whl

# ì„¤ì¹˜ í™•ì¸ í…ŒìŠ¤íŠ¸
python -c "from llama_cpp import Llama; print('âœ… ì„¤ì¹˜ ì„±ê³µ!')"


# ì»´íŒŒì¼ ì¤‘ë‹¨: Ctrl + C

# ìºì‹œ ì‚­ì œ í›„ ì¬ì‹œë„
pip cache purge
pip install llama-cpp-python --prefer-binary --no-build-isolation
"""
ì—ì´ì „í‹± AI ì‹œìŠ¤í…œ - GGUF ëª¨ë¸ ê¸°ë°˜ ììœ¨ AI ì–´ì‹œìŠ¤í„´íŠ¸
Multi-Agent Architecture with GGUF Model Integration
"""

import os
import sys
import json
import time
import threading
import asyncio
from typing import Dict, List, Optional, Any, Callable
from dataclasses import dataclass, field
from enum import Enum
import customtkinter as ctk
from tkinter import filedialog, messagebox, ttk
from pathlib import Path
import logging
from datetime import datetime
import traceback
from abc import ABC, abstractmethod
import queue
import subprocess
import webbrowser
import sqlite3

# llama-cpp-python ì§ì ‘ import
try:
    from llama_cpp import Llama
    LLAMA_CPP_AVAILABLE = True
except ImportError:
    LLAMA_CPP_AVAILABLE = False
    print("llama-cpp-pythonê°€ ì„¤ì¹˜ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤. ì„¤ì¹˜í•´ì£¼ì„¸ìš”: pip install llama-cpp-python")

# ë¡œê¹… ì„¤ì •
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[logging.FileHandler("agentic_ai.log"), logging.StreamHandler()]
)
logger = logging.getLogger(__name__)

# í˜„ëŒ€ì  í…Œë§ˆ ì„¤ì •
MODERN_THEME = {
    'primary': '#6366F1',      # Indigo
    'secondary': '#8B5CF6',    # Purple
    'accent': '#EC4899',       # Pink
    'success': '#10B981',      # Emerald
    'warning': '#F59E0B',      # Amber
    'error': '#EF4444',        # Red
    'info': '#3B82F6',         # Blue
    'dark': '#1F2937',         # Gray-800
    'light': '#F9FAFB',        # Gray-50
    'surface': '#FFFFFF',
    'text': '#111827',         # Gray-900
    'text_secondary': '#6B7280', # Gray-500
    'border': '#E5E7EB',       # Gray-200
    'hover': '#4F46E5',        # Indigo-600
    'gradient_start': '#6366F1',
    'gradient_end': '#8B5CF6'
}

# ============= GGUF ëª¨ë¸ ê´€ë¦¬ì =============
class GGUFModelManager:
    """GGUF ëª¨ë¸ ê´€ë¦¬ì"""
    
    def __init__(self):
        self.model = None
        self.model_path = ""
        self.model_loaded = False
        self.context_size = 2048
        self.temperature = 0.7
        self.max_tokens = 1000
        self.top_p = 0.95
        self.top_k = 40
        self.repeat_penalty = 1.1
        self.n_threads = 4
        self.n_gpu_layers = 0
        
    def load_model(self, model_path: str, **kwargs) -> bool:
        """GGUF ëª¨ë¸ ë¡œë“œ"""
        if not LLAMA_CPP_AVAILABLE:
            raise ImportError("llama-cpp-pythonì´ ì„¤ì¹˜ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.")
        
        if not os.path.exists(model_path):
            raise FileNotFoundError(f"ëª¨ë¸ íŒŒì¼ì´ ì¡´ì¬í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤: {model_path}")
        
        # íŒŒì¼ í¬ê¸° í™•ì¸ (ë„ˆë¬´ ì‘ìœ¼ë©´ ì†ìƒëœ íŒŒì¼ì¼ ê°€ëŠ¥ì„±)
        file_size = os.path.getsize(model_path)
        if file_size < 1024 * 1024:  # 1MB ë¯¸ë§Œ
            raise ValueError(f"ëª¨ë¸ íŒŒì¼ì´ ë„ˆë¬´ ì‘ìŠµë‹ˆë‹¤. ì†ìƒë˜ì—ˆì„ ê°€ëŠ¥ì„±ì´ ìˆìŠµë‹ˆë‹¤: {file_size} bytes")
        
        try:
            # ê¸°ì¡´ ëª¨ë¸ ì •ë¦¬
            if self.model:
                try:
                    del self.model
                except:
                    pass
                self.model = None
                self.model_loaded = False
            
            # ì„¤ì • ì—…ë°ì´íŠ¸
            self.context_size = kwargs.get('context_size', self.context_size)
            self.n_threads = kwargs.get('n_threads', self.n_threads)
            self.n_gpu_layers = kwargs.get('n_gpu_layers', self.n_gpu_layers)
            
            # ì•ˆì „í•œ ê¸°ë³¸ê°’ìœ¼ë¡œ ì‹œì‘
            logger.info(f"ëª¨ë¸ ë¡œë“œ ì‹œë„: {model_path}")
            logger.info(f"ì„¤ì • - Context: {self.context_size}, Threads: {self.n_threads}, GPU Layers: {self.n_gpu_layers}")
            
            # ëª¨ë¸ ë¡œë“œ (verbose=Trueë¡œ ë””ë²„ê¹… ì •ë³´ ì¶œë ¥)
            try:
                self.model = Llama(
                    model_path=model_path,
                    n_ctx=self.context_size,
                    n_threads=self.n_threads,
                    n_gpu_layers=self.n_gpu_layers,
                    verbose=True,  # ë””ë²„ê¹…ì„ ìœ„í•´ Trueë¡œ ì„¤ì •
                    seed=-1,
                    n_batch=512,  # ë°°ì¹˜ í¬ê¸° ëª…ì‹œ
                    f16_kv=True,  # Half precision
                    logits_all=False,
                    vocab_only=False,
                    use_mmap=True,  # ë©”ëª¨ë¦¬ ë§µ ì‚¬ìš©
                    use_mlock=False  # ë©”ëª¨ë¦¬ ë½ ë¹„í™œì„±í™”
                )
            except Exception as model_error:
                # GPU ë ˆì´ì–´ ë¬¸ì œì¼ ìˆ˜ ìˆìœ¼ë¯€ë¡œ CPU ì „ìš©ìœ¼ë¡œ ì¬ì‹œë„
                logger.warning(f"GPU ë¡œë“œ ì‹¤íŒ¨, CPU ëª¨ë“œë¡œ ì¬ì‹œë„: {str(model_error)}")
                self.n_gpu_layers = 0
                self.model = Llama(
                    model_path=model_path,
                    n_ctx=min(self.context_size, 512),  # ì»¨í…ìŠ¤íŠ¸ í¬ê¸° ì¤„ì—¬ì„œ ì¬ì‹œë„
                    n_threads=self.n_threads,
                    n_gpu_layers=0,  # GPU ë¹„í™œì„±í™”
                    verbose=False,
                    seed=-1,
                    use_mmap=False,  # ë©”ëª¨ë¦¬ ë§µ ë¹„í™œì„±í™”
                    use_mlock=False
                )
            
            self.model_path = model_path
            self.model_loaded = True
            logger.info(f"GGUF ëª¨ë¸ ë¡œë“œ ì„±ê³µ: {model_path}")
            return True
            
        except OSError as e:
            error_msg = f"ëª¨ë¸ íŒŒì¼ ì ‘ê·¼ ì˜¤ë¥˜: {str(e)}"
            logger.error(error_msg)
            self.model_loaded = False
            self.model = None
            raise RuntimeError(error_msg)
            
        except MemoryError as e:
            error_msg = f"ë©”ëª¨ë¦¬ ë¶€ì¡±: ëª¨ë¸ì´ ë„ˆë¬´ í½ë‹ˆë‹¤. ë” ì‘ì€ ëª¨ë¸ì„ ì‚¬ìš©í•˜ê±°ë‚˜ ì»¨í…ìŠ¤íŠ¸ í¬ê¸°ë¥¼ ì¤„ì´ì„¸ìš”."
            logger.error(error_msg)
            self.model_loaded = False
            self.model = None
            raise RuntimeError(error_msg)
            
        except Exception as e:
            error_msg = f"ëª¨ë¸ ë¡œë“œ ì˜¤ë¥˜: {str(e)}"
            logger.error(error_msg)
            logger.error(f"ì˜¤ë¥˜ íƒ€ì…: {type(e).__name__}")
            self.model_loaded = False
            self.model = None
            raise RuntimeError(error_msg)
    
    def generate(self, prompt: str, **kwargs) -> str:
        """í…ìŠ¤íŠ¸ ìƒì„±"""
        if not self.model_loaded or not self.model:
            raise RuntimeError("ëª¨ë¸ì´ ë¡œë“œë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.")
        
        # ìƒì„± íŒŒë¼ë¯¸í„°
        temperature = kwargs.get('temperature', self.temperature)
        max_tokens = kwargs.get('max_tokens', self.max_tokens)
        top_p = kwargs.get('top_p', self.top_p)
        top_k = kwargs.get('top_k', self.top_k)
        repeat_penalty = kwargs.get('repeat_penalty', self.repeat_penalty)
        
        try:
            # ì‘ë‹µ ìƒì„±
            response = self.model(
                prompt,
                max_tokens=max_tokens,
                temperature=temperature,
                top_p=top_p,
                top_k=top_k,
                repeat_penalty=repeat_penalty,
                echo=False,
                stop=["User:", "Human:", "Assistant:"]
            )
            
            # í…ìŠ¤íŠ¸ ì¶”ì¶œ
            if isinstance(response, dict) and "choices" in response:
                return response["choices"][0]["text"].strip()
            else:
                return str(response).strip()
                
        except Exception as e:
            logger.error(f"í…ìŠ¤íŠ¸ ìƒì„± ì˜¤ë¥˜: {str(e)}")
            raise
    
    def is_loaded(self) -> bool:
        """ëª¨ë¸ ë¡œë“œ ìƒíƒœ í™•ì¸"""
        return self.model_loaded

# ============= ì—ì´ì „íŠ¸ íƒ€ì… ì •ì˜ =============
class AgentType(Enum):
    """ì—ì´ì „íŠ¸ íƒ€ì… ì •ì˜"""
    ORCHESTRATOR = "orchestrator"     # ì „ì²´ ì¡°ì •ì
    PLANNER = "planner"               # ê³„íš ìˆ˜ë¦½
    EXECUTOR = "executor"             # ì‹¤í–‰ ë‹´ë‹¹
    RESEARCHER = "researcher"         # ì •ë³´ ìˆ˜ì§‘
    ANALYZER = "analyzer"             # ë¶„ì„ ë‹´ë‹¹
    CREATOR = "creator"               # ì½˜í…ì¸  ìƒì„±
    REVIEWER = "reviewer"             # ê²€í†  ë‹´ë‹¹

class TaskStatus(Enum):
    """ì‘ì—… ìƒíƒœ"""
    PENDING = "pending"
    IN_PROGRESS = "in_progress"
    COMPLETED = "completed"
    FAILED = "failed"
    CANCELLED = "cancelled"

# ============= ë„êµ¬ ì¸í„°í˜ì´ìŠ¤ =============
class Tool(ABC):
    """ë„êµ¬ ê¸°ë³¸ í´ë˜ìŠ¤"""
    
    def __init__(self, name: str, description: str):
        self.name = name
        self.description = description
    
    @abstractmethod
    async def execute(self, *args, **kwargs) -> Any:
        """ë„êµ¬ ì‹¤í–‰"""
        pass

class WebSearchTool(Tool):
    """ì›¹ ê²€ìƒ‰ ë„êµ¬"""
    
    def __init__(self):
        super().__init__(
            name="web_search",
            description="ì›¹ì—ì„œ ì •ë³´ë¥¼ ê²€ìƒ‰í•©ë‹ˆë‹¤"
        )
    
    async def execute(self, query: str) -> str:
        """ì›¹ ê²€ìƒ‰ ì‹¤í–‰"""
        await asyncio.sleep(0.5)
        # ì‹¤ì œë¡œëŠ” ê²€ìƒ‰ API í˜¸ì¶œ
        return f"[ì›¹ ê²€ìƒ‰ ê²°ê³¼]\nì£¼ì œ: {query}\n- ê´€ë ¨ ì •ë³´ 1\n- ê´€ë ¨ ì •ë³´ 2\n- ê´€ë ¨ ì •ë³´ 3"

class FileSystemTool(Tool):
    """íŒŒì¼ ì‹œìŠ¤í…œ ë„êµ¬"""
    
    def __init__(self):
        super().__init__(
            name="file_system",
            description="íŒŒì¼ì„ ì½ê³  ì“¸ ìˆ˜ ìˆìŠµë‹ˆë‹¤"
        )
    
    async def execute(self, action: str, path: str, content: str = None) -> str:
        """íŒŒì¼ ì‘ì—… ì‹¤í–‰"""
        if action == "read":
            try:
                with open(path, 'r', encoding='utf-8') as f:
                    return f.read()
            except Exception as e:
                return f"íŒŒì¼ ì½ê¸° ì‹¤íŒ¨: {str(e)}"
        elif action == "write":
            try:
                os.makedirs(os.path.dirname(path), exist_ok=True)
                with open(path, 'w', encoding='utf-8') as f:
                    f.write(content)
                return f"íŒŒì¼ ì €ì¥ ì™„ë£Œ: {path}"
            except Exception as e:
                return f"íŒŒì¼ ì“°ê¸° ì‹¤íŒ¨: {str(e)}"
        elif action == "list":
            try:
                files = os.listdir(os.path.dirname(path) or '.')
                return f"íŒŒì¼ ëª©ë¡: {', '.join(files)}"
            except Exception as e:
                return f"ë””ë ‰í† ë¦¬ ì½ê¸° ì‹¤íŒ¨: {str(e)}"
        return "ì§€ì›í•˜ì§€ ì•ŠëŠ” ì‘ì—…ì…ë‹ˆë‹¤."

class CodeExecutorTool(Tool):
    """ì½”ë“œ ì‹¤í–‰ ë„êµ¬"""
    
    def __init__(self):
        super().__init__(
            name="code_executor",
            description="Python ì½”ë“œë¥¼ ì‹¤í–‰í•©ë‹ˆë‹¤"
        )
    
    async def execute(self, code: str) -> str:
        """ì½”ë“œ ì‹¤í–‰"""
        try:
            # ê°„ë‹¨í•œ ìˆ˜ì‹ ê³„ì‚°ë§Œ í—ˆìš© (ë³´ì•ˆìƒ)
            if len(code) < 100 and not any(danger in code for danger in ['import', 'exec', 'eval', '__']):
                result = eval(code)
                return f"ì‹¤í–‰ ê²°ê³¼: {result}"
            else:
                return "ë³´ì•ˆìƒ ì‹¤í–‰í•  ìˆ˜ ì—†ëŠ” ì½”ë“œì…ë‹ˆë‹¤."
        except Exception as e:
            return f"ì‹¤í–‰ ì˜¤ë¥˜: {str(e)}"

class DatabaseTool(Tool):
    """ë°ì´í„°ë² ì´ìŠ¤ ë„êµ¬"""
    
    def __init__(self):
        super().__init__(
            name="database",
            description="ë°ì´í„°ë² ì´ìŠ¤ ì‘ì—…ì„ ìˆ˜í–‰í•©ë‹ˆë‹¤"
        )
        self.conn = None
        self.init_db()
    
    def init_db(self):
        """ë°ì´í„°ë² ì´ìŠ¤ ì´ˆê¸°í™”"""
        self.conn = sqlite3.connect('agentic_ai.db', check_same_thread=False)
        cursor = self.conn.cursor()
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS tasks (
                id TEXT PRIMARY KEY,
                title TEXT NOT NULL,
                description TEXT,
                status TEXT,
                agent_type TEXT,
                priority INTEGER,
                result TEXT,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                completed_at TIMESTAMP
            )
        ''')
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS agent_memory (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                agent_name TEXT,
                content TEXT,
                timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            )
        ''')
        self.conn.commit()
    
    async def execute(self, action: str, **kwargs) -> str:
        """ë°ì´í„°ë² ì´ìŠ¤ ì‘ì—… ì‹¤í–‰"""
        try:
            cursor = self.conn.cursor()
            
            if action == "save_task":
                cursor.execute(
                    "INSERT INTO tasks (id, title, description, status, agent_type, priority) VALUES (?, ?, ?, ?, ?, ?)",
                    (kwargs.get('id'), kwargs.get('title'), kwargs.get('description'), 
                     kwargs.get('status'), kwargs.get('agent_type'), kwargs.get('priority'))
                )
                self.conn.commit()
                return "ì‘ì—…ì´ ë°ì´í„°ë² ì´ìŠ¤ì— ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤."
                
            elif action == "update_task":
                cursor.execute(
                    "UPDATE tasks SET status = ?, result = ?, completed_at = ? WHERE id = ?",
                    (kwargs.get('status'), kwargs.get('result'), datetime.now(), kwargs.get('id'))
                )
                self.conn.commit()
                return "ì‘ì—… ìƒíƒœê°€ ì—…ë°ì´íŠ¸ë˜ì—ˆìŠµë‹ˆë‹¤."
                
            elif action == "get_tasks":
                cursor.execute("SELECT * FROM tasks ORDER BY created_at DESC LIMIT 10")
                tasks = cursor.fetchall()
                return f"ìµœê·¼ ì‘ì—… {len(tasks)}ê°œë¥¼ ê°€ì ¸ì™”ìŠµë‹ˆë‹¤."
                
            elif action == "save_memory":
                cursor.execute(
                    "INSERT INTO agent_memory (agent_name, content) VALUES (?, ?)",
                    (kwargs.get('agent_name'), kwargs.get('content'))
                )
                self.conn.commit()
                return "ë©”ëª¨ë¦¬ê°€ ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤."
                
            else:
                return "ì§€ì›í•˜ì§€ ì•ŠëŠ” ë°ì´í„°ë² ì´ìŠ¤ ì‘ì—…ì…ë‹ˆë‹¤."
                
        except Exception as e:
            return f"ë°ì´í„°ë² ì´ìŠ¤ ì˜¤ë¥˜: {str(e)}"

# ============= ì‘ì—… ì •ì˜ =============
@dataclass
class Task:
    """ì‘ì—… ì •ì˜"""
    id: str
    title: str
    description: str
    agent_type: AgentType
    status: TaskStatus = TaskStatus.PENDING
    priority: int = 5
    dependencies: List[str] = field(default_factory=list)
    result: Any = None
    error: str = None
    created_at: datetime = field(default_factory=datetime.now)
    completed_at: Optional[datetime] = None

# ============= ì—ì´ì „íŠ¸ í´ë˜ìŠ¤ =============
class Agent:
    """GGUF ëª¨ë¸ ê¸°ë°˜ ì—ì´ì „íŠ¸"""
    
    def __init__(self, name: str, agent_type: AgentType, model_manager: GGUFModelManager = None):
        self.name = name
        self.agent_type = agent_type
        self.model_manager = model_manager
        self.tools: Dict[str, Tool] = {}
        self.memory: List[Dict] = []
        self.current_task: Optional[Task] = None
        
    def add_tool(self, tool: Tool):
        """ë„êµ¬ ì¶”ê°€"""
        self.tools[tool.name] = tool
        logger.info(f"ë„êµ¬ ì¶”ê°€: {tool.name} -> {self.name}")
        
    async def process_task(self, task: Task) -> Any:
        """ì‘ì—… ì²˜ë¦¬"""
        self.current_task = task
        task.status = TaskStatus.IN_PROGRESS
        
        try:
            # ëª¨ë¸ì´ ë¡œë“œë˜ì–´ ìˆìœ¼ë©´ AI ê¸°ë°˜ ì²˜ë¦¬
            if self.model_manager and self.model_manager.is_loaded():
                result = await self.process_with_ai(task)
            else:
                # ëª¨ë¸ì´ ì—†ìœ¼ë©´ ê¸°ë³¸ ì²˜ë¦¬
                result = await self.process_without_ai(task)
            
            task.status = TaskStatus.COMPLETED
            task.completed_at = datetime.now()
            task.result = result
            
            # ë©”ëª¨ë¦¬ì— ì €ì¥
            self.memory.append({
                'task': task.title,
                'result': result,
                'timestamp': datetime.now()
            })
            
            # ë°ì´í„°ë² ì´ìŠ¤ì— ì €ì¥
            if 'database' in self.tools:
                await self.tools['database'].execute(
                    'update_task',
                    id=task.id,
                    status='completed',
                    result=str(result)
                )
            
            return result
            
        except Exception as e:
            task.status = TaskStatus.FAILED
            task.error = str(e)
            logger.error(f"Agent {self.name} failed: {str(e)}")
            raise
    
    async def process_with_ai(self, task: Task) -> str:
        """AI ëª¨ë¸ì„ ì‚¬ìš©í•œ ì‘ì—… ì²˜ë¦¬"""
        # 1. ì‘ì—… ë¶„ì„ í”„ë¡¬í”„íŠ¸ ìƒì„±
        analysis_prompt = f"""
ë‹¹ì‹ ì€ {self.agent_type.value} ì—­í• ì„ ìˆ˜í–‰í•˜ëŠ” AI ì—ì´ì „íŠ¸ì…ë‹ˆë‹¤.

ì‘ì—…: {task.title}
ì„¤ëª…: {task.description}

ì‚¬ìš© ê°€ëŠ¥í•œ ë„êµ¬: {', '.join(self.tools.keys())}

ì´ ì‘ì—…ì„ ì–´ë–»ê²Œ ìˆ˜í–‰í•˜ì‹œê² ìŠµë‹ˆê¹Œ? ë‹¨ê³„ë³„ë¡œ ì„¤ëª…í•´ì£¼ì„¸ìš”.
"""
        
        # 2. AI ëª¨ë¸ë¡œ ê³„íš ìƒì„±
        try:
            plan = self.model_manager.generate(analysis_prompt, max_tokens=500)
            
            # 3. ë„êµ¬ ì‹¤í–‰ ì—¬ë¶€ ê²°ì •
            result_parts = [f"[{self.name}ì˜ ë¶„ì„]\n{plan}\n"]
            
            # 4. í•„ìš”í•œ ë„êµ¬ ì‹¤í–‰
            for tool_name, tool in self.tools.items():
                if tool_name in task.description.lower() or tool_name in plan.lower():
                    if tool_name == "web_search":
                        search_result = await tool.execute(task.title)
                        result_parts.append(f"\n{search_result}")
                    elif tool_name == "file_system":
                        # ê²°ê³¼ë¥¼ íŒŒì¼ë¡œ ì €ì¥
                        file_path = f"outputs/{task.id}.txt"
                        await tool.execute("write", file_path, plan)
                        result_parts.append(f"\nê²°ê³¼ê°€ {file_path}ì— ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤.")
            
            # 5. ìµœì¢… ì‘ë‹µ ìƒì„±
            final_prompt = f"""
ì‘ì—… ë¶„ì„ ê²°ê³¼:
{plan}

ìœ„ ë¶„ì„ì„ ë°”íƒ•ìœ¼ë¡œ ì‚¬ìš©ìì—ê²Œ ì œê³µí•  ìµœì¢… ë‹µë³€ì„ ì‘ì„±í•´ì£¼ì„¸ìš”.
"""
            
            final_response = self.model_manager.generate(final_prompt, max_tokens=500)
            result_parts.append(f"\n[ìµœì¢… ë‹µë³€]\n{final_response}")
            
            return "\n".join(result_parts)
            
        except Exception as e:
            logger.error(f"AI ì²˜ë¦¬ ì¤‘ ì˜¤ë¥˜: {str(e)}")
            return await self.process_without_ai(task)
    
    async def process_without_ai(self, task: Task) -> str:
        """AI ëª¨ë¸ ì—†ì´ ê¸°ë³¸ ì²˜ë¦¬"""
        results = [f"[{self.name}ê°€ ì‘ì—…ì„ ì²˜ë¦¬ì¤‘ì…ë‹ˆë‹¤]"]
        
        # ê¸°ë³¸ì ì¸ ë„êµ¬ ì‹¤í–‰
        if "ê²€ìƒ‰" in task.description or "search" in task.description.lower():
            if "web_search" in self.tools:
                result = await self.tools["web_search"].execute(task.title)
                results.append(result)
        
        if "íŒŒì¼" in task.description or "ì €ì¥" in task.description:
            if "file_system" in self.tools:
                file_path = f"outputs/{task.id}.txt"
                result = await self.tools["file_system"].execute(
                    "write", file_path, f"ì‘ì—…: {task.title}\në‚´ìš©: {task.description}"
                )
                results.append(result)
        
        if "ê³„ì‚°" in task.description:
            if "code_executor" in self.tools:
                # ê°„ë‹¨í•œ ê³„ì‚° ì¶”ì¶œ ì‹œë„
                import re
                numbers = re.findall(r'\d+', task.description)
                if len(numbers) >= 2:
                    calc = f"{numbers[0]} + {numbers[1]}"
                    result = await self.tools["code_executor"].execute(calc)
                    results.append(result)
        
        if len(results) == 1:
            results.append(f"ì‘ì—… '{task.title}'ì„(ë¥¼) ì™„ë£Œí–ˆìŠµë‹ˆë‹¤.")
        
        return "\n".join(results)

# ============= ë©€í‹° ì—ì´ì „íŠ¸ ì˜¤ì¼€ìŠ¤íŠ¸ë ˆì´í„° =============
class AgentOrchestrator:
    """ë©€í‹° ì—ì´ì „íŠ¸ ì‹œìŠ¤í…œ ì¡°ì •ì"""
    
    def __init__(self, model_manager: GGUFModelManager = None):
        self.model_manager = model_manager
        self.agents: Dict[str, Agent] = {}
        self.task_queue: queue.Queue = queue.Queue()
        self.completed_tasks: List[Task] = []
        self.running = False
        self.db_tool = DatabaseTool()
        
    def add_agent(self, agent: Agent):
        """ì—ì´ì „íŠ¸ ì¶”ê°€"""
        self.agents[agent.name] = agent
        logger.info(f"Agent added: {agent.name} ({agent.agent_type.value})")
        
    def submit_task(self, task: Task):
        """ì‘ì—… ì œì¶œ"""
        self.task_queue.put(task)
        
        # ë°ì´í„°ë² ì´ìŠ¤ì— ì €ì¥
        try:
            asyncio.create_task(self.db_tool.execute(
                'save_task',
                id=task.id,
                title=task.title,
                description=task.description,
                status=task.status.value,
                agent_type=task.agent_type.value,
                priority=task.priority
            ))
        except:
            pass
        
        logger.info(f"Task submitted: {task.title}")
        
    async def process_tasks(self):
        """ì‘ì—… ì²˜ë¦¬ ë£¨í”„"""
        self.running = True
        
        while self.running:
            if not self.task_queue.empty():
                task = self.task_queue.get()
                
                # ì ì ˆí•œ ì—ì´ì „íŠ¸ ì„ íƒ
                agent = self.select_agent(task)
                
                if agent:
                    try:
                        result = await agent.process_task(task)
                        self.completed_tasks.append(task)
                        logger.info(f"Task completed: {task.title}")
                    except Exception as e:
                        logger.error(f"Task failed: {task.title} - {str(e)}")
                else:
                    logger.warning(f"No suitable agent for task: {task.title}")
                    
            await asyncio.sleep(0.1)
            
    def select_agent(self, task: Task) -> Optional[Agent]:
        """ì‘ì—…ì— ì í•©í•œ ì—ì´ì „íŠ¸ ì„ íƒ"""
        # ì§€ì •ëœ íƒ€ì…ì˜ ì—ì´ì „íŠ¸ ì°¾ê¸°
        for agent in self.agents.values():
            if agent.agent_type == task.agent_type:
                return agent
        
        # ì—†ìœ¼ë©´ ì‹¤í–‰ì ì—ì´ì „íŠ¸ ë°˜í™˜
        for agent in self.agents.values():
            if agent.agent_type == AgentType.EXECUTOR:
                return agent
                
        # ê·¸ë˜ë„ ì—†ìœ¼ë©´ ì²« ë²ˆì§¸ ì—ì´ì „íŠ¸
        return list(self.agents.values())[0] if self.agents else None
        
    def stop(self):
        """ì˜¤ì¼€ìŠ¤íŠ¸ë ˆì´í„° ì¤‘ì§€"""
        self.running = False

# ============= ë©”ì¸ ì• í”Œë¦¬ì¼€ì´ì…˜ UI =============
class AgenticAIApp(ctk.CTk):
    """ì—ì´ì „í‹± AI ì‹œìŠ¤í…œ UI"""
    
    def __init__(self):
        super().__init__()
        
        # ì•± ì´ˆê¸°í™”
        self.title("ğŸ¤– Agentic AI System - GGUF ëª¨ë¸ ê¸°ë°˜ ììœ¨ AI")
        self.geometry("1400x900")
        
        # ë””ë ‰í† ë¦¬ ìƒì„±
        self.create_directories()
        
        # ëª¨ë¸ ê´€ë¦¬ì ì´ˆê¸°í™”
        self.model_manager = GGUFModelManager()
        
        # ì‹œìŠ¤í…œ ì´ˆê¸°í™”
        self.orchestrator = AgentOrchestrator(self.model_manager)
        self.setup_agents()
        
        # ë¹„ë™ê¸° ì´ë²¤íŠ¸ ë£¨í”„
        self.loop = asyncio.new_event_loop()
        self.async_thread = threading.Thread(target=self.run_async_loop, daemon=True)
        self.async_thread.start()
        
        # UI ì„¤ì •
        self.setup_modern_ui()
        
        # ì‹œì‘ ë©”ì‹œì§€
        self.add_system_message("ğŸš€ ì—ì´ì „í‹± AI ì‹œìŠ¤í…œì´ ì‹œì‘ë˜ì—ˆìŠµë‹ˆë‹¤!")
        self.add_system_message("âš ï¸ GGUF ëª¨ë¸ì„ ë¡œë“œí•˜ë©´ ë” ê°•ë ¥í•œ AI ê¸°ëŠ¥ì„ ì‚¬ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.")
        
    def create_directories(self):
        """í•„ìš” ë””ë ‰í† ë¦¬ ìƒì„±"""
        dirs = ["models", "agents", "tasks", "outputs", "memory", "tools", "configs"]
        for dir_path in dirs:
            os.makedirs(dir_path, exist_ok=True)
            
    def setup_agents(self):
        """ì—ì´ì „íŠ¸ ì„¤ì •"""
        # ë‹¤ì–‘í•œ ì—ì´ì „íŠ¸ ìƒì„±
        agents_config = [
            ("ì£¼ ì¡°ì •ì", AgentType.ORCHESTRATOR),
            ("ê³„íš ìˆ˜ë¦½ì", AgentType.PLANNER),
            ("ì‹¤í–‰ì", AgentType.EXECUTOR),
            ("ì—°êµ¬ì›", AgentType.RESEARCHER),
            ("ë¶„ì„ê°€", AgentType.ANALYZER),
            ("ì°½ì‘ì", AgentType.CREATOR),
            ("ê²€í† ì", AgentType.REVIEWER)
        ]
        
        for name, agent_type in agents_config:
            agent = Agent(name, agent_type, self.model_manager)
            
            # ë„êµ¬ í• ë‹¹
            if agent_type in [AgentType.RESEARCHER, AgentType.EXECUTOR]:
                agent.add_tool(WebSearchTool())
                agent.add_tool(FileSystemTool())
            
            if agent_type == AgentType.EXECUTOR:
                agent.add_tool(CodeExecutorTool())
                agent.add_tool(DatabaseTool())
            
            if agent_type == AgentType.ANALYZER:
                agent.add_tool(CodeExecutorTool())
                agent.add_tool(DatabaseTool())
            
            if agent_type == AgentType.CREATOR:
                agent.add_tool(FileSystemTool())
                
            self.orchestrator.add_agent(agent)
            
    def run_async_loop(self):
        """ë¹„ë™ê¸° ì´ë²¤íŠ¸ ë£¨í”„ ì‹¤í–‰"""
        asyncio.set_event_loop(self.loop)
        self.loop.run_until_complete(self.orchestrator.process_tasks())
        
    def setup_modern_ui(self):
        """í˜„ëŒ€ì  UI êµ¬ì„±"""
        # í…Œë§ˆ ì„¤ì •
        ctk.set_appearance_mode("dark")
        ctk.set_default_color_theme("blue")
        
        # ê·¸ë¦¬ë“œ ì„¤ì •
        self.grid_columnconfigure(0, weight=0)  # ì‚¬ì´ë“œë°”
        self.grid_columnconfigure(1, weight=1)  # ë©”ì¸ ì˜ì—­
        self.grid_rowconfigure(0, weight=1)
        
        # ì‚¬ì´ë“œë°”
        self.setup_sidebar()
        
        # ë©”ì¸ ì˜ì—­
        self.setup_main_area()
        
    def setup_sidebar(self):
        """ì‚¬ì´ë“œë°” êµ¬ì„±"""
        sidebar = ctk.CTkFrame(self, width=280, corner_radius=0, fg_color=MODERN_THEME['dark'])
        sidebar.grid(row=0, column=0, sticky="nsew")
        sidebar.grid_rowconfigure(7, weight=1)
        
        # ë¡œê³  ì˜ì—­
        logo_frame = ctk.CTkFrame(sidebar, fg_color="transparent")
        logo_frame.grid(row=0, column=0, padx=20, pady=(20, 10), sticky="ew")
        
        ctk.CTkLabel(
            logo_frame,
            text="ğŸ¤– Agentic AI",
            font=("SF Pro Display", 28, "bold"),
            text_color=MODERN_THEME['light']
        ).pack()
        
        ctk.CTkLabel(
            logo_frame,
            text="GGUF Model Powered System",
            font=("SF Pro Text", 12),
            text_color=MODERN_THEME['text_secondary']
        ).pack()
        
        # ëª¨ë¸ ìƒíƒœ
        self.model_status_frame = ctk.CTkFrame(sidebar, fg_color="#2D3748", corner_radius=10)
        self.model_status_frame.grid(row=1, column=0, padx=20, pady=10, sticky="ew")
        
        ctk.CTkLabel(
            self.model_status_frame,
            text="GGUF Model Status",
            font=("SF Pro Display", 14, "bold"),
            text_color=MODERN_THEME['light']
        ).pack(pady=(10, 5))
        
        self.model_status_label = ctk.CTkLabel(
            self.model_status_frame,
            text="âŒ No Model Loaded",
            font=("SF Pro Text", 12),
            text_color=MODERN_THEME['error']
        )
        self.model_status_label.pack(pady=(0, 5))
        
        self.model_name_label = ctk.CTkLabel(
            self.model_status_frame,
            text="",
            font=("SF Pro Text", 10),
            text_color=MODERN_THEME['text_secondary']
        )
        self.model_name_label.pack(pady=(0, 10))
        
        # ëª¨ë¸ ë¡œë“œ ë²„íŠ¼
        self.load_model_button = ctk.CTkButton(
            sidebar,
            text="ğŸ“‚ Load GGUF Model",
            command=self.load_model,
            font=("SF Pro Display", 13, "bold"),
            height=40,
            corner_radius=8,
            fg_color=MODERN_THEME['accent'],
            hover_color="#D946A6"
        )
        self.load_model_button.grid(row=2, column=0, padx=20, pady=10, sticky="ew")
        
        # ì—ì´ì „íŠ¸ ìƒíƒœ
        self.agent_status_frame = ctk.CTkFrame(sidebar, fg_color=MODERN_THEME['surface'], corner_radius=10)
        self.agent_status_frame.grid(row=3, column=0, padx=20, pady=10, sticky="ew")
        
        ctk.CTkLabel(
            self.agent_status_frame,
            text="Active Agents",
            font=("SF Pro Display", 14, "bold"),
            text_color=MODERN_THEME['text']
        ).pack(pady=(10, 5))
        
        # ì—ì´ì „íŠ¸ ë¦¬ìŠ¤íŠ¸
        for agent_name, agent in self.orchestrator.agents.items():
            agent_item = ctk.CTkFrame(self.agent_status_frame, fg_color="transparent")
            agent_item.pack(fill="x", padx=10, pady=2)
            
            status_color = MODERN_THEME['success']
            ctk.CTkLabel(
                agent_item,
                text="â—",
                font=("SF Pro Text", 12),
                text_color=status_color,
                width=20
            ).pack(side="left")
            
            ctk.CTkLabel(
                agent_item,
                text=agent_name,
                font=("SF Pro Text", 12),
                text_color=MODERN_THEME['text_secondary']
            ).pack(side="left", padx=(5, 0))
        
        # ì‘ì—… í†µê³„
        stats_frame = ctk.CTkFrame(sidebar, fg_color=MODERN_THEME['surface'], corner_radius=10)
        stats_frame.grid(row=4, column=0, padx=20, pady=10, sticky="ew")
        
        ctk.CTkLabel(
            stats_frame,
            text="Task Statistics",
            font=("SF Pro Display", 14, "bold"),
            text_color=MODERN_THEME['text']
        ).pack(pady=(10, 5))
        
        self.stats_labels = {}
        stats = [
            ("Pending", "pending", MODERN_THEME['warning']),
            ("In Progress", "progress", MODERN_THEME['info']),
            ("Completed", "completed", MODERN_THEME['success']),
            ("Failed", "failed", MODERN_THEME['error'])
        ]
        
        for stat_name, stat_key, color in stats:
            stat_item = ctk.CTkFrame(stats_frame, fg_color="transparent")
            stat_item.pack(fill="x", padx=15, pady=2)
            
            ctk.CTkLabel(
                stat_item,
                text=stat_name,
                font=("SF Pro Text", 11),
                text_color=MODERN_THEME['text_secondary']
            ).pack(side="left")
            
            label = ctk.CTkLabel(
                stat_item,
                text="0",
                font=("SF Pro Display", 12, "bold"),
                text_color=color
            )
            label.pack(side="right")
            self.stats_labels[stat_key] = label
        
        # ì•¡ì…˜ ë²„íŠ¼ë“¤
        action_frame = ctk.CTkFrame(sidebar, fg_color="transparent")
        action_frame.grid(row=5, column=0, padx=20, pady=10, sticky="ew")
        
        ctk.CTkButton(
            action_frame,
            text="â• New Task",
            command=self.show_new_task_dialog,
            font=("SF Pro Display", 13, "bold"),
            height=40,
            corner_radius=8,
            fg_color=MODERN_THEME['primary'],
            hover_color=MODERN_THEME['hover']
        ).pack(fill="x", pady=5)
        
        ctk.CTkButton(
            action_frame,
            text="âš™ï¸ Model Settings",
            command=self.show_model_settings,
            font=("SF Pro Display", 13, "bold"),
            height=40,
            corner_radius=8,
            fg_color=MODERN_THEME['secondary'],
            hover_color=MODERN_THEME['hover']
        ).pack(fill="x", pady=5)
        
        # í•˜ë‹¨ ì •ë³´
        info_frame = ctk.CTkFrame(sidebar, fg_color="transparent")
        info_frame.grid(row=8, column=0, padx=20, pady=(0, 20), sticky="ew")
        
        ctk.CTkLabel(
            info_frame,
            text="Powered by llama-cpp-python",
            font=("SF Pro Text", 10),
            text_color=MODERN_THEME['text_secondary']
        ).pack()
        
    def setup_main_area(self):
        """ë©”ì¸ ì˜ì—­ êµ¬ì„±"""
        main_frame = ctk.CTkFrame(self, fg_color=MODERN_THEME['light'])
        main_frame.grid(row=0, column=1, sticky="nsew", padx=(0, 0), pady=0)
        main_frame.grid_columnconfigure(0, weight=1)
        main_frame.grid_rowconfigure(1, weight=1)
        
        # í—¤ë”
        header_frame = ctk.CTkFrame(main_frame, height=80, fg_color=MODERN_THEME['surface'], corner_radius=0)
        header_frame.grid(row=0, column=0, sticky="ew", padx=0, pady=0)
        header_frame.grid_columnconfigure(1, weight=1)
        
        ctk.CTkLabel(
            header_frame,
            text="Task Console",
            font=("SF Pro Display", 24, "bold"),
            text_color=MODERN_THEME['text']
        ).grid(row=0, column=0, padx=30, pady=25)
        
        # ìƒíƒœ í‘œì‹œ
        self.status_label = ctk.CTkLabel(
            header_frame,
            text="ğŸŸ¢ System Online",
            font=("SF Pro Text", 14),
            text_color=MODERN_THEME['success']
        )
        self.status_label.grid(row=0, column=1, padx=30, pady=25, sticky="e")
        
        # íƒ­ ë·°
        self.tabview = ctk.CTkTabview(main_frame, corner_radius=10)
        self.tabview.grid(row=1, column=0, sticky="nsew", padx=20, pady=20)
        
        # ëŒ€í™” íƒ­
        chat_tab = self.tabview.add("ğŸ’¬ Chat")
        self.setup_chat_tab(chat_tab)
        
        # ì‘ì—… ëª¨ë‹ˆí„° íƒ­
        monitor_tab = self.tabview.add("ğŸ“Š Task Monitor")
        self.setup_monitor_tab(monitor_tab)
        
        # ë©”ëª¨ë¦¬ ë·° íƒ­
        memory_tab = self.tabview.add("ğŸ§  Agent Memory")
        self.setup_memory_tab(memory_tab)
        
    def setup_chat_tab(self, parent):
        """ëŒ€í™” íƒ­ ì„¤ì •"""
        parent.grid_columnconfigure(0, weight=1)
        parent.grid_rowconfigure(0, weight=1)
        
        # ëŒ€í™” ì˜ì—­
        self.chat_frame = ctk.CTkScrollableFrame(
            parent,
            fg_color=MODERN_THEME['surface'],
            corner_radius=10
        )
        self.chat_frame.grid(row=0, column=0, sticky="nsew", padx=10, pady=10)
        
        # ì…ë ¥ ì˜ì—­
        input_frame = ctk.CTkFrame(parent, fg_color="transparent", height=100)
        input_frame.grid(row=1, column=0, sticky="ew", padx=10, pady=(0, 10))
        input_frame.grid_columnconfigure(0, weight=1)
        
        self.input_box = ctk.CTkTextbox(
            input_frame,
            height=80,
            wrap="word",
            font=("SF Pro Text", 14),
            border_width=2,
            border_color=MODERN_THEME['border'],
            fg_color=MODERN_THEME['surface'],
            corner_radius=10
        )
        self.input_box.grid(row=0, column=0, sticky="ew", padx=(0, 10))
        self.input_box.bind("<Return>", self.handle_return)
        
        # ì „ì†¡ ë²„íŠ¼
        self.send_button = ctk.CTkButton(
            input_frame,
            text="Send Task",
            command=self.send_task,
            width=120,
            height=80,
            font=("SF Pro Display", 14, "bold"),
            corner_radius=10,
            fg_color=MODERN_THEME['primary'],
            hover_color=MODERN_THEME['hover']
        )
        self.send_button.grid(row=0, column=1)
        
    def setup_monitor_tab(self, parent):
        """ì‘ì—… ëª¨ë‹ˆí„° íƒ­ ì„¤ì •"""
        parent.grid_columnconfigure(0, weight=1)
        parent.grid_rowconfigure(0, weight=1)
        
        # ì‘ì—… ë¦¬ìŠ¤íŠ¸
        self.task_tree = ttk.Treeview(
            parent,
            columns=('ID', 'Title', 'Agent', 'Status', 'Priority', 'Created'),
            show='headings',
            height=20
        )
        
        # ì»¬ëŸ¼ ì„¤ì •
        columns = [
            ('ID', 150),
            ('Title', 300),
            ('Agent', 120),
            ('Status', 100),
            ('Priority', 80),
            ('Created', 150)
        ]
        
        for col, width in columns:
            self.task_tree.heading(col, text=col)
            self.task_tree.column(col, width=width)
        
        self.task_tree.grid(row=0, column=0, sticky="nsew", padx=10, pady=10)
        
        # ìŠ¤í¬ë¡¤ë°”
        scrollbar = ttk.Scrollbar(parent, orient="vertical", command=self.task_tree.yview)
        scrollbar.grid(row=0, column=1, sticky="ns", pady=10)
        self.task_tree.configure(yscrollcommand=scrollbar.set)
        
    def setup_memory_tab(self, parent):
        """ë©”ëª¨ë¦¬ ë·° íƒ­ ì„¤ì •"""
        parent.grid_columnconfigure(0, weight=1)
        parent.grid_rowconfigure(0, weight=1)
        
        self.memory_text = ctk.CTkTextbox(
            parent,
            font=("SF Pro Mono", 12),
            fg_color=MODERN_THEME['dark'],
            text_color=MODERN_THEME['light']
        )
        self.memory_text.grid(row=0, column=0, sticky="nsew", padx=10, pady=10)
        
    def load_model(self):
        """GGUF ëª¨ë¸ ë¡œë“œ"""
        model_file = filedialog.askopenfilename(
            title="GGUF ëª¨ë¸ íŒŒì¼ ì„ íƒ",
            filetypes=[("GGUF íŒŒì¼", "*.gguf"), ("ëª¨ë“  íŒŒì¼", "*.*")],
            initialdir="models"
        )
        
        if not model_file:
            return
        
        # ë¡œë”© ëŒ€í™”ìƒì
        loading_dialog = self.create_loading_dialog("GGUF ëª¨ë¸ ë¡œë“œ ì¤‘...")
        
        # ë³„ë„ ìŠ¤ë ˆë“œì—ì„œ ëª¨ë¸ ë¡œë“œ
        threading.Thread(
            target=self._load_model_thread,
            args=(model_file, loading_dialog),
            daemon=True
        ).start()
    
    def _load_model_thread(self, model_file, loading_dialog):
        """ëª¨ë¸ ë¡œë“œ ìŠ¤ë ˆë“œ"""
        try:
            # ëª¨ë¸ ë¡œë“œ ì „ íŒŒì¼ ê²€ì¦
            if not os.path.exists(model_file):
                raise FileNotFoundError(f"íŒŒì¼ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤: {model_file}")
            
            file_size_mb = os.path.getsize(model_file) / (1024 * 1024)
            logger.info(f"ëª¨ë¸ íŒŒì¼ í¬ê¸°: {file_size_mb:.2f} MB")
            
            # ë©”ëª¨ë¦¬ ì²´í¬ (psutilì´ ìˆëŠ” ê²½ìš°ë§Œ)
            try:
                import psutil
                available_memory = psutil.virtual_memory().available / (1024 * 1024 * 1024)  # GB
                logger.info(f"ì‚¬ìš© ê°€ëŠ¥í•œ ë©”ëª¨ë¦¬: {available_memory:.2f} GB")
                
                # íŒŒì¼ í¬ê¸°ê°€ ì‚¬ìš© ê°€ëŠ¥í•œ ë©”ëª¨ë¦¬ë³´ë‹¤ í¬ë©´ ê²½ê³ 
                if file_size_mb > available_memory * 1024 * 0.8:  # 80% ì´ìƒ ì‚¬ìš© ì‹œ ê²½ê³ 
                    logger.warning("ë©”ëª¨ë¦¬ ë¶€ì¡± ê°€ëŠ¥ì„±ì´ ìˆìŠµë‹ˆë‹¤. ë” ì‘ì€ ëª¨ë¸ì„ ì‚¬ìš©í•˜ëŠ” ê²ƒì„ ê¶Œì¥í•©ë‹ˆë‹¤.")
            except ImportError:
                logger.info("psutilì´ ì„¤ì¹˜ë˜ì§€ ì•Šì•„ ë©”ëª¨ë¦¬ ì²´í¬ë¥¼ ê±´ë„ˆëœë‹ˆë‹¤.")
            
            # ëª¨ë¸ ë¡œë“œ ì‹œë„
            self.model_manager.load_model(
                model_file,
                context_size=2048,
                n_threads=4,
                n_gpu_layers=0  # ê¸°ë³¸ì ìœ¼ë¡œ GPU ë¹„í™œì„±í™”
            )
            
            # UI ì—…ë°ì´íŠ¸
            self.after(100, lambda: self._handle_model_load_success(model_file, loading_dialog))
            
        except FileNotFoundError as e:
            error_msg = f"íŒŒì¼ ì˜¤ë¥˜: {str(e)}"
            logger.error(error_msg)
            self.after(100, lambda msg=error_msg: self._handle_model_load_error(msg, loading_dialog))
            
        except MemoryError:
            error_msg = "ë©”ëª¨ë¦¬ ë¶€ì¡±: ì‹œìŠ¤í…œ ë©”ëª¨ë¦¬ê°€ ë¶€ì¡±í•©ë‹ˆë‹¤. ë” ì‘ì€ ëª¨ë¸ì„ ì‚¬ìš©í•´ì£¼ì„¸ìš”."
            logger.error(error_msg)
            self.after(100, lambda msg=error_msg: self._handle_model_load_error(msg, loading_dialog))
            
        except ImportError as e:
            error_msg = f"ë¼ì´ë¸ŒëŸ¬ë¦¬ ì˜¤ë¥˜: {str(e)}\nllama-cpp-pythonì„ ë‹¤ì‹œ ì„¤ì¹˜í•´ë³´ì„¸ìš”."
            logger.error(error_msg)
            self.after(100, lambda msg=error_msg: self._handle_model_load_error(msg, loading_dialog))
            
        except RuntimeError as e:
            # GGUFModelManagerì—ì„œ ë°œìƒí•œ RuntimeError
            error_msg = str(e)
            logger.error(error_msg)
            self.after(100, lambda msg=error_msg: self._handle_model_load_error(msg, loading_dialog))
            
        except Exception as e:
            # ê¸°íƒ€ ëª¨ë“  ì˜ˆì™¸ ì²˜ë¦¬
            error_msg = f"ì˜ˆìƒì¹˜ ëª»í•œ ì˜¤ë¥˜: {str(e)}\níƒ€ì…: {type(e).__name__}"
            logger.error(error_msg)
            logger.error(f"ìƒì„¸ ì˜¤ë¥˜:\n{traceback.format_exc()}")
            
            # Access Violation ê°™ì€ ì¹˜ëª…ì  ì˜¤ë¥˜ ì²˜ë¦¬
            if "access violation" in str(e).lower():
                error_msg += "\n\ní•´ê²° ë°©ë²•:\n"
                error_msg += "1. ëª¨ë¸ íŒŒì¼ì´ ì†ìƒë˜ì§€ ì•Šì•˜ëŠ”ì§€ í™•ì¸\n"
                error_msg += "2. llama-cpp-python ì¬ì„¤ì¹˜: pip uninstall llama-cpp-python && pip install llama-cpp-python\n"
                error_msg += "3. Visual C++ Redistributable ì„¤ì¹˜ í™•ì¸\n"
                error_msg += "4. ë‹¤ë¥¸ GGUF ëª¨ë¸ íŒŒì¼ë¡œ ì‹œë„"
            
            self.after(100, lambda msg=error_msg: self._handle_model_load_error(msg, loading_dialog))
    
    def _handle_model_load_success(self, model_file, loading_dialog):
        """ëª¨ë¸ ë¡œë“œ ì„±ê³µ ì²˜ë¦¬"""
        loading_dialog.destroy()
        
        model_name = os.path.basename(model_file)
        self.model_status_label.configure(
            text="âœ… Model Loaded",
            text_color=MODERN_THEME['success']
        )
        self.model_name_label.configure(text=model_name[:30] + "..." if len(model_name) > 30 else model_name)
        
        self.add_system_message(f"âœ… GGUF ëª¨ë¸ì´ ì„±ê³µì ìœ¼ë¡œ ë¡œë“œë˜ì—ˆìŠµë‹ˆë‹¤: {model_name}")
        self.add_system_message("ğŸš€ ì´ì œ AI ì—ì´ì „íŠ¸ë“¤ì´ ê°•í™”ëœ ê¸°ëŠ¥ì„ ì‚¬ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤!")
        
        messagebox.showinfo("ì„±ê³µ", f"ëª¨ë¸ì´ ì„±ê³µì ìœ¼ë¡œ ë¡œë“œë˜ì—ˆìŠµë‹ˆë‹¤:\n{model_name}")
    
    def _handle_model_load_error(self, error_msg, loading_dialog):
        """ëª¨ë¸ ë¡œë“œ ì‹¤íŒ¨ ì²˜ë¦¬"""
        loading_dialog.destroy()
        
        self.add_system_message(f"âŒ ëª¨ë¸ ë¡œë“œ ì‹¤íŒ¨: {error_msg}")
        messagebox.showerror("ì˜¤ë¥˜", f"ëª¨ë¸ ë¡œë“œì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤:\n{error_msg}")
    
    def create_loading_dialog(self, message):
        """ë¡œë”© ëŒ€í™”ìƒì ìƒì„±"""
        dialog = ctk.CTkToplevel(self)
        dialog.title("ì²˜ë¦¬ ì¤‘")
        dialog.geometry("300x150")
        dialog.transient(self)
        dialog.grab_set()
        
        # ì¤‘ì•™ ë°°ì¹˜
        dialog.update_idletasks()
        width = dialog.winfo_width()
        height = dialog.winfo_height()
        x = (dialog.winfo_screenwidth() // 2) - (width // 2)
        y = (dialog.winfo_screenheight() // 2) - (height // 2)
        dialog.geometry(f'+{x}+{y}')
        
        ctk.CTkLabel(
            dialog,
            text=message,
            font=("SF Pro Display", 14, "bold")
        ).pack(pady=(20, 10))
        
        progress = ctk.CTkProgressBar(dialog, width=250)
        progress.pack(pady=(0, 20))
        progress.configure(mode="indeterminate")
        progress.start()
        
        return dialog
    
    def show_model_settings(self):
        """ëª¨ë¸ ì„¤ì • ëŒ€í™”ìƒì"""
        dialog = ctk.CTkToplevel(self)
        dialog.title("Model Settings")
        dialog.geometry("500x600")
        dialog.transient(self)
        dialog.grab_set()
        
        # ì¤‘ì•™ ë°°ì¹˜
        dialog.update_idletasks()
        width = dialog.winfo_width()
        height = dialog.winfo_height()
        x = (dialog.winfo_screenwidth() // 2) - (width // 2)
        y = (dialog.winfo_screenheight() // 2) - (height // 2)
        dialog.geometry(f'+{x}+{y}')
        
        # ì„¤ì • í”„ë ˆì„
        settings_frame = ctk.CTkScrollableFrame(dialog)
        settings_frame.pack(fill="both", expand=True, padx=20, pady=20)
        
        ctk.CTkLabel(
            settings_frame,
            text="GGUF Model Settings",
            font=("SF Pro Display", 20, "bold")
        ).pack(pady=(0, 20))
        
        # ì„¤ì • í•­ëª©ë“¤
        settings = [
            ("Context Size", "context_size", self.model_manager.context_size, 512, 8192),
            ("Temperature", "temperature", self.model_manager.temperature, 0.0, 2.0),
            ("Max Tokens", "max_tokens", self.model_manager.max_tokens, 100, 4000),
            ("Top P", "top_p", self.model_manager.top_p, 0.0, 1.0),
            ("Top K", "top_k", self.model_manager.top_k, 1, 100),
            ("Repeat Penalty", "repeat_penalty", self.model_manager.repeat_penalty, 0.0, 2.0),
            ("Threads", "n_threads", self.model_manager.n_threads, 1, 16),
            ("GPU Layers", "n_gpu_layers", self.model_manager.n_gpu_layers, 0, 100),
        ]
        
        self.setting_vars = {}
        
        for label, key, value, min_val, max_val in settings:
            frame = ctk.CTkFrame(settings_frame, fg_color="transparent")
            frame.pack(fill="x", pady=10)
            
            ctk.CTkLabel(
                frame,
                text=label,
                font=("SF Pro Text", 14),
                width=150,
                anchor="w"
            ).pack(side="left")
            
            if key in ["temperature", "top_p", "repeat_penalty"]:
                slider = ctk.CTkSlider(
                    frame,
                    from_=min_val,
                    to=max_val,
                    width=200
                )
                slider.set(value)
                slider.pack(side="left", padx=(10, 10))
                
                value_label = ctk.CTkLabel(
                    frame,
                    text=f"{value:.2f}",
                    font=("SF Pro Mono", 12),
                    width=60
                )
                value_label.pack(side="left")
                
                slider.configure(command=lambda v, l=value_label: l.configure(text=f"{v:.2f}"))
                self.setting_vars[key] = slider
            else:
                entry = ctk.CTkEntry(
                    frame,
                    width=100,
                    font=("SF Pro Mono", 12)
                )
                entry.insert(0, str(value))
                entry.pack(side="left", padx=(10, 0))
                self.setting_vars[key] = entry
        
        # ë²„íŠ¼
        button_frame = ctk.CTkFrame(dialog, fg_color="transparent")
        button_frame.pack(fill="x", padx=20, pady=(0, 20))
        
        ctk.CTkButton(
            button_frame,
            text="Cancel",
            command=dialog.destroy,
            width=100,
            fg_color=MODERN_THEME['error']
        ).pack(side="left", padx=10)
        
        ctk.CTkButton(
            button_frame,
            text="Apply",
            command=lambda: self.apply_model_settings(dialog),
            width=100,
            fg_color=MODERN_THEME['success']
        ).pack(side="right", padx=10)
    
    def apply_model_settings(self, dialog):
        """ëª¨ë¸ ì„¤ì • ì ìš©"""
        try:
            for key, widget in self.setting_vars.items():
                if isinstance(widget, ctk.CTkSlider):
                    value = widget.get()
                else:
                    value = widget.get()
                    if key in ["context_size", "max_tokens", "top_k", "n_threads", "n_gpu_layers"]:
                        value = int(value)
                    else:
                        value = float(value)
                
                setattr(self.model_manager, key, value)
            
            self.add_system_message("âœ… ëª¨ë¸ ì„¤ì •ì´ ì—…ë°ì´íŠ¸ë˜ì—ˆìŠµë‹ˆë‹¤.")
            dialog.destroy()
            
        except ValueError as e:
            messagebox.showerror("ì˜¤ë¥˜", "ì˜ëª»ëœ ê°’ì´ ì…ë ¥ë˜ì—ˆìŠµë‹ˆë‹¤.")
    
    def add_system_message(self, message):
        """ì‹œìŠ¤í…œ ë©”ì‹œì§€ ì¶”ê°€"""
        container = ctk.CTkFrame(self.chat_frame, fg_color=MODERN_THEME['info'], corner_radius=10)
        container.pack(fill="x", padx=10, pady=5)
        
        ctk.CTkLabel(
            container,
            text=message,
            font=("SF Pro Text", 13),
            text_color="white",
            wraplength=800,
            justify="left"
        ).pack(padx=15, pady=10, anchor="w")
        
        # ìŠ¤í¬ë¡¤ ë‹¤ìš´
        self.chat_frame._parent_canvas.yview_moveto(1.0)
        
    def add_user_message(self, message):
        """ì‚¬ìš©ì ë©”ì‹œì§€ ì¶”ê°€"""
        container = ctk.CTkFrame(self.chat_frame, fg_color="#D6EAF8", corner_radius=10)
        container.pack(fill="x", padx=10, pady=5)
        
        ctk.CTkLabel(
            container,
            text=f"ğŸ‘¤ User",
            font=("SF Pro Display", 12, "bold"),
            text_color=MODERN_THEME['primary']
        ).pack(padx=15, pady=(10, 5), anchor="w")
        
        ctk.CTkLabel(
            container,
            text=message,
            font=("SF Pro Text", 13),
            text_color=MODERN_THEME['text'],
            wraplength=800,
            justify="left"
        ).pack(padx=15, pady=(0, 10), anchor="w")
        
        # ìŠ¤í¬ë¡¤ ë‹¤ìš´
        self.chat_frame._parent_canvas.yview_moveto(1.0)
        
    def add_agent_message(self, agent_name, message):
        """ì—ì´ì „íŠ¸ ë©”ì‹œì§€ ì¶”ê°€"""
        container = ctk.CTkFrame(self.chat_frame, fg_color="#E0E7FF", corner_radius=10)
        container.pack(fill="x", padx=10, pady=5)
        
        # ì—ì´ì „íŠ¸ ì´ë¦„
        ctk.CTkLabel(
            container,
            text=f"ğŸ¤– {agent_name}",
            font=("SF Pro Display", 12, "bold"),
            text_color=MODERN_THEME['primary']
        ).pack(padx=15, pady=(10, 5), anchor="w")
        
        # ë©”ì‹œì§€
        ctk.CTkLabel(
            container,
            text=message,
            font=("SF Pro Text", 13),
            text_color=MODERN_THEME['text'],
            wraplength=800,
            justify="left"
        ).pack(padx=15, pady=(0, 10), anchor="w")
        
        # ìŠ¤í¬ë¡¤ ë‹¤ìš´
        self.chat_frame._parent_canvas.yview_moveto(1.0)
        
    def send_task(self):
        """ì‘ì—… ì „ì†¡"""
        task_description = self.input_box.get("0.0", "end").strip()
        
        if not task_description:
            return
            
        # ì…ë ¥ ì´ˆê¸°í™”
        self.input_box.delete("0.0", "end")
        
        # ì‚¬ìš©ì ë©”ì‹œì§€ í‘œì‹œ
        self.add_user_message(task_description)
        
        # ì‘ì—… ìœ í˜• ìë™ ê²°ì •
        agent_type = self.determine_agent_type(task_description)
        
        # ì‘ì—… ìƒì„±
        task = Task(
            id=f"TASK-{datetime.now().strftime('%Y%m%d%H%M%S')}",
            title=task_description[:50] + "..." if len(task_description) > 50 else task_description,
            description=task_description,
            agent_type=agent_type,
            priority=5
        )
        
        # ì‘ì—… ì œì¶œ
        self.orchestrator.submit_task(task)
        
        # UI ì—…ë°ì´íŠ¸
        self.add_system_message(f"ğŸ“‹ ì‘ì—…ì´ {agent_type.value} ì—ì´ì „íŠ¸ì—ê²Œ í• ë‹¹ë˜ì—ˆìŠµë‹ˆë‹¤.")
        self.update_task_monitor(task)
        self.update_stats()
        
        # ë¹„ë™ê¸°ë¡œ ì‘ì—… ì²˜ë¦¬ ë° ê²°ê³¼ í‘œì‹œ
        threading.Thread(
            target=self._process_task_async,
            args=(task,),
            daemon=True
        ).start()
    
    def determine_agent_type(self, description: str) -> AgentType:
        """ì‘ì—… ì„¤ëª…ì„ ê¸°ë°˜ìœ¼ë¡œ ì ì ˆí•œ ì—ì´ì „íŠ¸ íƒ€ì… ê²°ì •"""
        desc_lower = description.lower()
        
        if any(word in desc_lower for word in ["ê³„íš", "plan", "ì „ëµ", "strategy"]):
            return AgentType.PLANNER
        elif any(word in desc_lower for word in ["ê²€ìƒ‰", "search", "ì°¾", "find", "ì •ë³´"]):
            return AgentType.RESEARCHER
        elif any(word in desc_lower for word in ["ë¶„ì„", "analyze", "í†µê³„", "ë°ì´í„°"]):
            return AgentType.ANALYZER
        elif any(word in desc_lower for word in ["ë§Œë“¤", "create", "ì‘ì„±", "write", "ìƒì„±"]):
            return AgentType.CREATOR
        elif any(word in desc_lower for word in ["ê²€í† ", "review", "í™•ì¸", "check"]):
            return AgentType.REVIEWER
        else:
            return AgentType.EXECUTOR
    
    def _process_task_async(self, task):
        """ë¹„ë™ê¸° ì‘ì—… ì²˜ë¦¬"""
        # ì‘ì—…ì´ ì²˜ë¦¬ë  ë•Œê¹Œì§€ ëŒ€ê¸°
        max_wait = 30  # ìµœëŒ€ 30ì´ˆ ëŒ€ê¸°
        wait_time = 0
        
        while wait_time < max_wait:
            if task.status == TaskStatus.COMPLETED:
                # ê²°ê³¼ í‘œì‹œ
                agent = self.orchestrator.select_agent(task)
                if agent and task.result:
                    self.after(100, lambda: self.add_agent_message(agent.name, str(task.result)))
                break
            elif task.status == TaskStatus.FAILED:
                self.after(100, lambda: self.add_system_message(f"âŒ ì‘ì—… ì‹¤íŒ¨: {task.error}"))
                break
            
            time.sleep(0.5)
            wait_time += 0.5
        
        # í†µê³„ ì—…ë°ì´íŠ¸
        self.after(100, self.update_stats)
        
    def update_task_monitor(self, task):
        """ì‘ì—… ëª¨ë‹ˆí„° ì—…ë°ì´íŠ¸"""
        self.task_tree.insert('', 'end', values=(
            task.id,
            task.title,
            task.agent_type.value,
            task.status.value,
            task.priority,
            task.created_at.strftime('%Y-%m-%d %H:%M')
        ))
        
    def update_stats(self):
        """í†µê³„ ì—…ë°ì´íŠ¸"""
        # ì‹¤ì œ í†µê³„ ê³„ì‚°
        stats = {
            'pending': sum(1 for t in self.orchestrator.task_queue.queue if t.status == TaskStatus.PENDING),
            'progress': 0,  # í˜„ì¬ ì²˜ë¦¬ ì¤‘ì¸ ì‘ì—…
            'completed': len(self.orchestrator.completed_tasks),
            'failed': sum(1 for t in self.orchestrator.completed_tasks if t.status == TaskStatus.FAILED)
        }
        
        for key, value in stats.items():
            if key in self.stats_labels:
                self.stats_labels[key].configure(text=str(value))
                
    def show_new_task_dialog(self):
        """ìƒˆ ì‘ì—… ëŒ€í™”ìƒì"""
        dialog = ctk.CTkToplevel(self)
        dialog.title("New Task")
        dialog.geometry("600x500")
        dialog.transient(self)
        dialog.grab_set()
        
        # ì¤‘ì•™ ë°°ì¹˜
        dialog.update_idletasks()
        width = dialog.winfo_width()
        height = dialog.winfo_height()
        x = (dialog.winfo_screenwidth() // 2) - (width // 2)
        y = (dialog.winfo_screenheight() // 2) - (height // 2)
        dialog.geometry(f'+{x}+{y}')
        
        # ë‚´ìš©
        ctk.CTkLabel(
            dialog,
            text="Create New Task",
            font=("SF Pro Display", 20, "bold")
        ).pack(pady=(20, 10))
        
        # ì‘ì—… ì œëª©
        ctk.CTkLabel(dialog, text="Task Title:").pack(pady=(10, 5))
        title_entry = ctk.CTkEntry(dialog, width=400)
        title_entry.pack(pady=(0, 10))
        
        # ì‘ì—… ì„¤ëª…
        ctk.CTkLabel(dialog, text="Description:").pack(pady=(10, 5))
        desc_text = ctk.CTkTextbox(dialog, width=400, height=150)
        desc_text.pack(pady=(0, 10))
        
        # ì—ì´ì „íŠ¸ ì„ íƒ
        ctk.CTkLabel(dialog, text="Agent Type:").pack(pady=(10, 5))
        agent_var = ctk.StringVar(value=AgentType.EXECUTOR.value)
        agent_menu = ctk.CTkComboBox(
            dialog,
            values=[t.value for t in AgentType],
            variable=agent_var,
            width=400
        )
        agent_menu.pack(pady=(0, 10))
        
        # ìš°ì„ ìˆœìœ„
        ctk.CTkLabel(dialog, text="Priority (1-10):").pack(pady=(10, 5))
        priority_slider = ctk.CTkSlider(dialog, from_=1, to=10, width=400)
        priority_slider.set(5)
        priority_slider.pack(pady=(0, 20))
        
        # ë²„íŠ¼
        button_frame = ctk.CTkFrame(dialog, fg_color="transparent")
        button_frame.pack(pady=20)
        
        ctk.CTkButton(
            button_frame,
            text="Cancel",
            command=dialog.destroy,
            width=100,
            fg_color=MODERN_THEME['error']
        ).pack(side="left", padx=10)
        
        ctk.CTkButton(
            button_frame,
            text="Create",
            command=lambda: self.create_task_from_dialog(
                dialog,
                title_entry.get(),
                desc_text.get("0.0", "end"),
                agent_var.get(),
                int(priority_slider.get())
            ),
            width=100,
            fg_color=MODERN_THEME['success']
        ).pack(side="left", padx=10)
        
    def create_task_from_dialog(self, dialog, title, description, agent_type, priority):
        """ëŒ€í™”ìƒìì—ì„œ ì‘ì—… ìƒì„±"""
        if not title or not description:
            messagebox.showwarning("Warning", "Please fill in all fields")
            return
            
        task = Task(
            id=f"TASK-{datetime.now().strftime('%Y%m%d%H%M%S')}",
            title=title,
            description=description.strip(),
            agent_type=AgentType(agent_type),
            priority=priority
        )
        
        self.orchestrator.submit_task(task)
        self.add_system_message(f"ğŸ“‹ ìƒˆ ì‘ì—… ìƒì„±: {task.title}")
        self.update_task_monitor(task)
        self.update_stats()
        
        dialog.destroy()
        
    def handle_return(self, event):
        """Enter í‚¤ ì²˜ë¦¬"""
        if event.state & 0x1:  # Shift key
            return None
        else:
            self.send_task()
            return "break"
            
    def on_closing(self):
        """ì•± ì¢…ë£Œ ì²˜ë¦¬"""
        self.orchestrator.stop()
        self.loop.call_soon_threadsafe(self.loop.stop)
        self.quit()
        self.destroy()

# ============= ë©”ì¸ ì‹¤í–‰ =============
if __name__ == "__main__":
    if not LLAMA_CPP_AVAILABLE:
        import tkinter as tk
        from tkinter import messagebox
        root = tk.Tk()
        root.withdraw()
        messagebox.showerror(
            "ì˜¤ë¥˜", 
            "llama-cpp-pythonì´ ì„¤ì¹˜ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.\n\n"
            "ë‹¤ìŒ ëª…ë ¹ì–´ë¡œ ì„¤ì¹˜í•´ì£¼ì„¸ìš”:\n"
            "pip install llama-cpp-python"
        )
        root.destroy()
        sys.exit(1)
    
    try:
        app = AgenticAIApp()
        app.protocol("WM_DELETE_WINDOW", app.on_closing)
        app.mainloop()
    except Exception as e:
        error_message = f"ì• í”Œë¦¬ì¼€ì´ì…˜ ì‹œì‘ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤:\n{str(e)}\n\n{traceback.format_exc()}"
        print(error_message)
        
        try:
            import tkinter as tk
            from tkinter import messagebox
            root = tk.Tk()
            root.withdraw()
            messagebox.showerror("ì˜¤ë¥˜", error_message)
            root.destroy()
        except:
            pass
        
        sys.exit(1)