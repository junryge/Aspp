# -*- coding: utf-8 -*-
"""
ì™„ì „í•œ GGUF ì˜¤ì¼€ìŠ¤íŠ¸ë ˆì´í„° LLM ì‹œìŠ¤í…œ
ë¡œì»¬ í™˜ê²½ì—ì„œ ë‹¤ì¤‘ AI ëª¨ë¸ì„ ì§€ëŠ¥ì ìœ¼ë¡œ ê´€ë¦¬í•˜ê³  ì¡°ìœ¨í•˜ëŠ” ì‹œìŠ¤í…œ
"""

import os
import sys
import json
import time
import threading
import queue
import psutil
import hashlib
from dataclasses import dataclass, field
from typing import Dict, List, Optional, Any, Tuple, Callable
from enum import Enum
from pathlib import Path
import logging
from datetime import datetime
import traceback
import customtkinter as ctk
from tkinter import filedialog, messagebox, ttk
import tkinter as tk

# llama-cpp-python import
try:
    from llama_cpp import Llama
    LLAMA_CPP_AVAILABLE = True
except ImportError:
    LLAMA_CPP_AVAILABLE = False
    print("llama-cpp-python ì„¤ì¹˜ í•„ìš”: pip install llama-cpp-python")

# ë¡œê¹… ì„¤ì •
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler("orchestrator.log", encoding='utf-8'),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger(__name__)

# ==================== ì‹œìŠ¤í…œ ìƒìˆ˜ ====================
MAX_CONTEXT_LENGTH = 4096
DEFAULT_MAX_TOKENS = 1024
MEMORY_SAFETY_MARGIN = 0.8  # ë©”ëª¨ë¦¬ì˜ 80%ë§Œ ì‚¬ìš©

# ==================== 1. ì—ì´ì „íŠ¸ íƒ€ì… ë° ì—­í•  ì •ì˜ ====================
class AgentRole(Enum):
    """ì—ì´ì „íŠ¸ ì—­í•  ì •ì˜"""
    ROUTER = "router"              # ì‘ì—… ë¶„ë¥˜ ë° ë¼ìš°íŒ…
    ANALYZER = "analyzer"          # ì…ë ¥ ë¶„ì„
    CODER = "coder"               # ì½”ë“œ ìƒì„±
    DEBUGGER = "debugger"         # ì½”ë“œ ë””ë²„ê¹…
    WRITER = "writer"             # ë¬¸ì„œ ì‘ì„±
    TRANSLATOR = "translator"     # ë²ˆì—­
    SUMMARIZER = "summarizer"     # ìš”ì•½
    VALIDATOR = "validator"       # ê²€ì¦
    CREATIVE = "creative"         # ì°½ì‘
    MATH = "math"                 # ìˆ˜í•™/ê³„ì‚°
    DATA_ANALYST = "data_analyst" # ë°ì´í„° ë¶„ì„
    GENERAL = "general"           # ì¼ë°˜ ëŒ€í™”

class TaskPriority(Enum):
    """ì‘ì—… ìš°ì„ ìˆœìœ„"""
    CRITICAL = 1
    HIGH = 2
    NORMAL = 3
    LOW = 4

class TaskStatus(Enum):
    """ì‘ì—… ìƒíƒœ"""
    PENDING = "pending"
    ANALYZING = "analyzing"
    ROUTING = "routing"
    PROCESSING = "processing"
    COMPLETED = "completed"
    FAILED = "failed"
    CANCELLED = "cancelled"

# ==================== 2. ì‹œìŠ¤í…œ ëª¨ë‹ˆí„°ë§ ====================
class SystemMonitor:
    """ì‹œìŠ¤í…œ ë¦¬ì†ŒìŠ¤ ëª¨ë‹ˆí„°ë§"""
    
    @staticmethod
    def get_memory_info() -> Dict[str, float]:
        """ë©”ëª¨ë¦¬ ì •ë³´ ê°€ì ¸ì˜¤ê¸°"""
        memory = psutil.virtual_memory()
        return {
            "total_gb": memory.total / (1024**3),
            "available_gb": memory.available / (1024**3),
            "used_gb": memory.used / (1024**3),
            "percent": memory.percent
        }
    
    @staticmethod
    def get_cpu_info() -> Dict[str, float]:
        """CPU ì •ë³´ ê°€ì ¸ì˜¤ê¸°"""
        return {
            "percent": psutil.cpu_percent(interval=1),
            "cores": psutil.cpu_count(logical=False),
            "threads": psutil.cpu_count(logical=True)
        }
    
    @staticmethod
    def can_load_model(model_size_gb: float) -> bool:
        """ëª¨ë¸ ë¡œë“œ ê°€ëŠ¥ ì—¬ë¶€ í™•ì¸"""
        memory_info = SystemMonitor.get_memory_info()
        available = memory_info["available_gb"]
        required = model_size_gb * 1.2  # 20% ì—¬ìœ  ê³µê°„
        return available > required

# ==================== 3. ì‘ì—… ì •ì˜ ====================
@dataclass
class Task:
    """ì‘ì—… ë‹¨ìœ„"""
    id: str
    content: str
    role: Optional[AgentRole] = None
    priority: TaskPriority = TaskPriority.NORMAL
    status: TaskStatus = TaskStatus.PENDING
    metadata: Dict[str, Any] = field(default_factory=dict)
    dependencies: List[str] = field(default_factory=list)
    result: Optional[str] = None
    error: Optional[str] = None
    created_at: datetime = field(default_factory=datetime.now)
    started_at: Optional[datetime] = None
    completed_at: Optional[datetime] = None
    assigned_agent: Optional[str] = None
    
    def __lt__(self, other):
        """ìš°ì„ ìˆœìœ„ ë¹„êµ"""
        return self.priority.value < other.priority.value

# ==================== 4. ì—ì´ì „íŠ¸ ì •ì˜ ====================
@dataclass
class AgentProfile:
    """ì—ì´ì „íŠ¸ í”„ë¡œí•„"""
    name: str
    role: AgentRole
    model_path: str
    model_size_gb: float
    context_size: int = 2048
    temperature: float = 0.7
    max_tokens: int = 1024
    system_prompt: str = ""
    capabilities: List[str] = field(default_factory=list)
    performance_score: float = 1.0  # ì„±ëŠ¥ ì ìˆ˜ (0-1)
    total_tasks: int = 0
    successful_tasks: int = 0
    average_response_time: float = 0.0

class Agent:
    """ì§€ëŠ¥í˜• ì—ì´ì „íŠ¸"""
    
    def __init__(self, profile: AgentProfile):
        self.profile = profile
        self.model: Optional[Llama] = None
        self.is_loaded = False
        self.is_busy = False
        self.current_task: Optional[Task] = None
        self.history: List[Task] = []
        self.lock = threading.Lock()
        
    def load(self) -> bool:
        """ëª¨ë¸ ë¡œë“œ"""
        if self.is_loaded:
            return True
            
        if not SystemMonitor.can_load_model(self.profile.model_size_gb):
            logger.warning(f"ë©”ëª¨ë¦¬ ë¶€ì¡±ìœ¼ë¡œ {self.profile.name} ë¡œë“œ ë¶ˆê°€")
            return False
            
        try:
            logger.info(f"ì—ì´ì „íŠ¸ '{self.profile.name}' ë¡œë“œ ì‹œì‘...")
            self.model = Llama(
                model_path=self.profile.model_path,
                n_ctx=self.profile.context_size,
                n_threads=psutil.cpu_count(logical=False),
                n_gpu_layers=-1 if self._check_gpu() else 0,
                verbose=False
            )
            self.is_loaded = True
            logger.info(f"ì—ì´ì „íŠ¸ '{self.profile.name}' ë¡œë“œ ì™„ë£Œ")
            return True
        except Exception as e:
            logger.error(f"ì—ì´ì „íŠ¸ ë¡œë“œ ì‹¤íŒ¨: {str(e)}")
            return False
    
    def unload(self):
        """ëª¨ë¸ ì–¸ë¡œë“œ"""
        if self.model:
            del self.model
            self.model = None
            self.is_loaded = False
            logger.info(f"ì—ì´ì „íŠ¸ '{self.profile.name}' ì–¸ë¡œë“œ")
    
    def _check_gpu(self) -> bool:
        """GPU ì‚¬ìš© ê°€ëŠ¥ ì—¬ë¶€ í™•ì¸"""
        # ê°„ë‹¨í•œ GPU ì²´í¬ (ì‹¤ì œë¡œëŠ” ë” ì •êµí•œ í™•ì¸ í•„ìš”)
        try:
            import torch
            return torch.cuda.is_available()
        except:
            return False
    
    def can_handle(self, task: Task) -> float:
        """ì‘ì—… ì²˜ë¦¬ ê°€ëŠ¥ ì—¬ë¶€ ë° ì í•©ë„ ë°˜í™˜ (0-1)"""
        if not self.is_loaded or self.is_busy:
            return 0.0
            
        # ì—­í•  ë§¤ì¹­
        if task.role and task.role != self.profile.role:
            return 0.0
            
        # ì í•©ë„ ê³„ì‚°
        suitability = self.profile.performance_score
        
        # ì‘ì—… ë‚´ìš© ë¶„ì„ (í‚¤ì›Œë“œ ê¸°ë°˜)
        content_lower = task.content.lower()
        role_keywords = {
            AgentRole.CODER: ["code", "ì½”ë“œ", "function", "í•¨ìˆ˜", "class", "í´ë˜ìŠ¤"],
            AgentRole.TRANSLATOR: ["translate", "ë²ˆì—­", "translation"],
            AgentRole.SUMMARIZER: ["summarize", "ìš”ì•½", "summary"],
            AgentRole.MATH: ["calculate", "ê³„ì‚°", "math", "ìˆ˜í•™"],
            AgentRole.WRITER: ["write", "ì‘ì„±", "document", "ë¬¸ì„œ"],
        }
        
        if self.profile.role in role_keywords:
            keywords = role_keywords[self.profile.role]
            if any(keyword in content_lower for keyword in keywords):
                suitability *= 1.5  # í‚¤ì›Œë“œ ë§¤ì¹­ì‹œ ë³´ë„ˆìŠ¤
                
        return min(suitability, 1.0)
    
    def process(self, task: Task) -> str:
        """ì‘ì—… ì²˜ë¦¬"""
        with self.lock:
            if not self.is_loaded or self.is_busy:
                raise RuntimeError(f"ì—ì´ì „íŠ¸ {self.profile.name}ì´ ì‚¬ìš© ë¶ˆê°€ëŠ¥")
                
            self.is_busy = True
            self.current_task = task
            
        try:
            start_time = time.time()
            
            # í”„ë¡¬í”„íŠ¸ êµ¬ì„±
            prompt = self._build_prompt(task)
            
            # ëª¨ë¸ ì‹¤í–‰
            response = self.model(
                prompt,
                max_tokens=self.profile.max_tokens,
                temperature=self.profile.temperature,
                top_p=0.95,
                repeat_penalty=1.1,
                echo=False
            )
            
            # ì‘ë‹µ ì¶”ì¶œ
            if isinstance(response, dict) and "choices" in response:
                result = response["choices"][0]["text"].strip()
            else:
                result = str(response).strip()
            
            # ì„±ëŠ¥ í†µê³„ ì—…ë°ì´íŠ¸
            elapsed_time = time.time() - start_time
            self._update_performance(task, elapsed_time, success=True)
            
            return result
            
        except Exception as e:
            logger.error(f"ì‘ì—… ì²˜ë¦¬ ì‹¤íŒ¨: {str(e)}")
            self._update_performance(task, 0, success=False)
            raise
            
        finally:
            with self.lock:
                self.is_busy = False
                self.current_task = None
                self.history.append(task)
    
    def _build_prompt(self, task: Task) -> str:
        """í”„ë¡¬í”„íŠ¸ êµ¬ì„±"""
        parts = []
        
        # ì‹œìŠ¤í…œ í”„ë¡¬í”„íŠ¸
        if self.profile.system_prompt:
            parts.append(f"System: {self.profile.system_prompt}")
        
        # ì‘ì—… ì»¨í…ìŠ¤íŠ¸
        if task.metadata.get("context"):
            parts.append(f"Context: {task.metadata['context']}")
        
        # ì´ì „ ê²°ê³¼ ì°¸ì¡°
        if task.dependencies:
            parts.append("Previous Results:")
            for dep_id in task.dependencies:
                if dep_id in task.metadata.get("dependency_results", {}):
                    parts.append(f"- {dep_id}: {task.metadata['dependency_results'][dep_id][:200]}...")
        
        # ë©”ì¸ ì‘ì—…
        parts.append(f"User: {task.content}")
        parts.append("Assistant:")
        
        return "\n\n".join(parts)
    
    def _update_performance(self, task: Task, elapsed_time: float, success: bool):
        """ì„±ëŠ¥ ì§€í‘œ ì—…ë°ì´íŠ¸"""
        self.profile.total_tasks += 1
        if success:
            self.profile.successful_tasks += 1
            
        # í‰ê·  ì‘ë‹µ ì‹œê°„ ì—…ë°ì´íŠ¸
        alpha = 0.1  # ì§€ìˆ˜ ì´ë™ í‰ê·  ê°€ì¤‘ì¹˜
        if elapsed_time > 0:
            if self.profile.average_response_time == 0:
                self.profile.average_response_time = elapsed_time
            else:
                self.profile.average_response_time = (
                    alpha * elapsed_time + 
                    (1 - alpha) * self.profile.average_response_time
                )
        
        # ì„±ëŠ¥ ì ìˆ˜ ì—…ë°ì´íŠ¸
        if self.profile.total_tasks > 0:
            success_rate = self.profile.successful_tasks / self.profile.total_tasks
            speed_score = min(1.0, 10.0 / max(self.profile.average_response_time, 0.1))
            self.profile.performance_score = (success_rate * 0.7 + speed_score * 0.3)

# ==================== 5. ì§€ëŠ¥í˜• ë¼ìš°í„° ====================
class IntelligentRouter:
    """ì‘ì—…ì„ ë¶„ì„í•˜ê³  ì ì ˆí•œ ì—ì´ì „íŠ¸ë¡œ ë¼ìš°íŒ…"""
    
    def __init__(self):
        self.routing_rules = self._init_routing_rules()
        self.routing_history = []
        
    def _init_routing_rules(self) -> Dict[str, AgentRole]:
        """ë¼ìš°íŒ… ê·œì¹™ ì´ˆê¸°í™”"""
        return {
            # ì½”ë”© ê´€ë ¨
            "code": AgentRole.CODER,
            "ì½”ë“œ": AgentRole.CODER,
            "function": AgentRole.CODER,
            "í•¨ìˆ˜": AgentRole.CODER,
            "debug": AgentRole.DEBUGGER,
            "ë””ë²„ê·¸": AgentRole.DEBUGGER,
            "error": AgentRole.DEBUGGER,
            "ì—ëŸ¬": AgentRole.DEBUGGER,
            
            # ë²ˆì—­
            "translate": AgentRole.TRANSLATOR,
            "ë²ˆì—­": AgentRole.TRANSLATOR,
            "translation": AgentRole.TRANSLATOR,
            
            # ìš”ì•½
            "summarize": AgentRole.SUMMARIZER,
            "ìš”ì•½": AgentRole.SUMMARIZER,
            "summary": AgentRole.SUMMARIZER,
            
            # ìˆ˜í•™
            "calculate": AgentRole.MATH,
            "ê³„ì‚°": AgentRole.MATH,
            "math": AgentRole.MATH,
            "ìˆ˜í•™": AgentRole.MATH,
            
            # ë°ì´í„° ë¶„ì„
            "analyze": AgentRole.DATA_ANALYST,
            "ë¶„ì„": AgentRole.DATA_ANALYST,
            "data": AgentRole.DATA_ANALYST,
            "ë°ì´í„°": AgentRole.DATA_ANALYST,
            
            # ì‘ì„±
            "write": AgentRole.WRITER,
            "ì‘ì„±": AgentRole.WRITER,
            "document": AgentRole.WRITER,
            "ë¬¸ì„œ": AgentRole.WRITER,
        }
    
    def analyze_task(self, task: Task) -> AgentRole:
        """ì‘ì—… ë¶„ì„ ë° ì ì ˆí•œ ì—­í•  ê²°ì •"""
        content_lower = task.content.lower()
        
        # í‚¤ì›Œë“œ ê¸°ë°˜ ë¼ìš°íŒ…
        for keyword, role in self.routing_rules.items():
            if keyword in content_lower:
                logger.info(f"ì‘ì—… '{task.id}'ë¥¼ {role.value} ì—­í• ë¡œ ë¼ìš°íŒ…")
                return role
        
        # ê¸°ë³¸ê°’
        return AgentRole.GENERAL
    
    def route(self, task: Task, agents: Dict[str, Agent]) -> Optional[Agent]:
        """ì‘ì—…ì„ ìµœì ì˜ ì—ì´ì „íŠ¸ë¡œ ë¼ìš°íŒ…"""
        
        # ì‘ì—… ì—­í•  ë¶„ì„
        if not task.role:
            task.role = self.analyze_task(task)
        
        # ìµœì  ì—ì´ì „íŠ¸ ì„ íƒ
        best_agent = None
        best_score = 0.0
        
        for agent in agents.values():
            score = agent.can_handle(task)
            if score > best_score:
                best_score = score
                best_agent = agent
        
        if best_agent:
            logger.info(f"ì‘ì—… '{task.id}'ë¥¼ ì—ì´ì „íŠ¸ '{best_agent.profile.name}'ë¡œ í• ë‹¹ (ì ìˆ˜: {best_score:.2f})")
            self.routing_history.append({
                "task_id": task.id,
                "agent": best_agent.profile.name,
                "score": best_score,
                "timestamp": datetime.now()
            })
            
        return best_agent

# ==================== 6. íŒŒì´í”„ë¼ì¸ ë§¤ë‹ˆì € ====================
class Pipeline:
    """ë³µì¡í•œ ì‘ì—…ì„ ë‹¨ê³„ë³„ë¡œ ì²˜ë¦¬í•˜ëŠ” íŒŒì´í”„ë¼ì¸"""
    
    def __init__(self, name: str):
        self.name = name
        self.stages: List[Dict[str, Any]] = []
        self.results: Dict[str, Any] = {}
        
    def add_stage(self, name: str, role: AgentRole, 
                  prompt_template: str, **kwargs):
        """íŒŒì´í”„ë¼ì¸ ë‹¨ê³„ ì¶”ê°€"""
        stage = {
            "name": name,
            "role": role,
            "prompt_template": prompt_template,
            "kwargs": kwargs
        }
        self.stages.append(stage)
        logger.info(f"íŒŒì´í”„ë¼ì¸ '{self.name}'ì— ë‹¨ê³„ '{name}' ì¶”ê°€")
        
    def execute(self, orchestrator, initial_input: str) -> Dict[str, Any]:
        """íŒŒì´í”„ë¼ì¸ ì‹¤í–‰"""
        current_input = initial_input
        
        for i, stage in enumerate(self.stages):
            logger.info(f"íŒŒì´í”„ë¼ì¸ ë‹¨ê³„ {i+1}/{len(self.stages)}: {stage['name']}")
            
            # í”„ë¡¬í”„íŠ¸ ìƒì„±
            prompt = stage["prompt_template"].format(
                input=current_input,
                **self.results
            )
            
            # ì‘ì—… ìƒì„±
            task = Task(
                id=f"{self.name}_{stage['name']}_{int(time.time())}",
                content=prompt,
                role=stage["role"],
                priority=TaskPriority.HIGH,
                metadata=stage.get("kwargs", {})
            )
            
            # ì˜ì¡´ì„± ì„¤ì •
            if i > 0:
                task.dependencies = [prev_task_id]
                task.metadata["dependency_results"] = {prev_task_id: current_input}
            
            # ì‘ì—… ì‹¤í–‰
            result = orchestrator.execute_task_sync(task)
            
            if result:
                self.results[stage["name"]] = result
                current_input = result
                prev_task_id = task.id
            else:
                raise RuntimeError(f"íŒŒì´í”„ë¼ì¸ ë‹¨ê³„ ì‹¤íŒ¨: {stage['name']}")
        
        return self.results

# ==================== 7. ë©”ì¸ ì˜¤ì¼€ìŠ¤íŠ¸ë ˆì´í„° ====================
class Orchestrator:
    """ì¤‘ì•™ ì˜¤ì¼€ìŠ¤íŠ¸ë ˆì´í„° - ëª¨ë“  ì—ì´ì „íŠ¸ì™€ ì‘ì—…ì„ ê´€ë¦¬"""
    
    def __init__(self, max_workers: int = 3):
        self.agents: Dict[str, Agent] = {}
        self.router = IntelligentRouter()
        self.task_queue: queue.PriorityQueue = queue.PriorityQueue()
        self.completed_tasks: Dict[str, Task] = {}
        self.active_tasks: Dict[str, Task] = {}
        self.max_workers = max_workers
        self.workers: List[threading.Thread] = []
        self.running = False
        self.lock = threading.Lock()
        
        # ì½œë°±
        self.on_task_complete: Optional[Callable] = None
        self.on_task_error: Optional[Callable] = None
        self.on_status_update: Optional[Callable] = None
        
        # í†µê³„
        self.stats = {
            "total_tasks": 0,
            "completed_tasks": 0,
            "failed_tasks": 0,
            "average_completion_time": 0.0
        }
        
    def register_agent(self, agent: Agent) -> bool:
        """ì—ì´ì „íŠ¸ ë“±ë¡"""
        if agent.load():
            self.agents[agent.profile.name] = agent
            logger.info(f"ì—ì´ì „íŠ¸ '{agent.profile.name}' ë“±ë¡ ì™„ë£Œ")
            return True
        return False
    
    def unregister_agent(self, agent_name: str):
        """ì—ì´ì „íŠ¸ ë“±ë¡ í•´ì œ"""
        if agent_name in self.agents:
            self.agents[agent_name].unload()
            del self.agents[agent_name]
            logger.info(f"ì—ì´ì „íŠ¸ '{agent_name}' ë“±ë¡ í•´ì œ")
    
    def submit_task(self, task: Task) -> str:
        """ì‘ì—… ì œì¶œ"""
        if not task.id:
            task.id = f"task_{int(time.time() * 1000)}"
        
        with self.lock:
            self.task_queue.put((task.priority.value, time.time(), task))
            self.active_tasks[task.id] = task
            self.stats["total_tasks"] += 1
            
        logger.info(f"ì‘ì—… ì œì¶œ: {task.id}")
        
        if self.on_status_update:
            self.on_status_update(f"ì‘ì—… ì œì¶œ: {task.id}")
            
        return task.id
    
    def execute_task_sync(self, task: Task, timeout: float = 60) -> Optional[str]:
        """ë™ê¸°ì ìœ¼ë¡œ ì‘ì—… ì‹¤í–‰ (íŒŒì´í”„ë¼ì¸ìš©)"""
        task_id = self.submit_task(task)
        
        # ì‘ì—… ì™„ë£Œ ëŒ€ê¸°
        start_time = time.time()
        while time.time() - start_time < timeout:
            if task_id in self.completed_tasks:
                completed_task = self.completed_tasks[task_id]
                if completed_task.status == TaskStatus.COMPLETED:
                    return completed_task.result
                else:
                    return None
            time.sleep(0.1)
            
        return None
    
    def start(self):
        """ì˜¤ì¼€ìŠ¤íŠ¸ë ˆì´í„° ì‹œì‘"""
        if self.running:
            return
            
        self.running = True
        
        # ì›Œì»¤ ìŠ¤ë ˆë“œ ìƒì„±
        for i in range(self.max_workers):
            worker = threading.Thread(
                target=self._worker_loop,
                name=f"Worker-{i+1}",
                daemon=True
            )
            worker.start()
            self.workers.append(worker)
            
        logger.info(f"ì˜¤ì¼€ìŠ¤íŠ¸ë ˆì´í„° ì‹œì‘ (ì›Œì»¤: {self.max_workers}ê°œ)")
        
        if self.on_status_update:
            self.on_status_update(f"ì˜¤ì¼€ìŠ¤íŠ¸ë ˆì´í„° ì‹œì‘")
    
    def stop(self):
        """ì˜¤ì¼€ìŠ¤íŠ¸ë ˆì´í„° ì¤‘ì§€"""
        self.running = False
        
        for worker in self.workers:
            worker.join(timeout=5)
            
        self.workers.clear()
        logger.info("ì˜¤ì¼€ìŠ¤íŠ¸ë ˆì´í„° ì¤‘ì§€")
        
        if self.on_status_update:
            self.on_status_update("ì˜¤ì¼€ìŠ¤íŠ¸ë ˆì´í„° ì¤‘ì§€")
    
    def _worker_loop(self):
        """ì›Œì»¤ ë£¨í”„"""
        while self.running:
            try:
                # ì‘ì—… ê°€ì ¸ì˜¤ê¸°
                priority, timestamp, task = self.task_queue.get(timeout=1)
                
                # ì‘ì—… ì²˜ë¦¬
                self._process_task(task)
                
            except queue.Empty:
                continue
            except Exception as e:
                logger.error(f"ì›Œì»¤ ì˜¤ë¥˜: {str(e)}")
    
    def _process_task(self, task: Task):
        """ì‘ì—… ì²˜ë¦¬"""
        try:
            task.status = TaskStatus.ROUTING
            task.started_at = datetime.now()
            
            # ì—ì´ì „íŠ¸ ì„ íƒ
            agent = self.router.route(task, self.agents)
            
            if not agent:
                raise RuntimeError("ì í•©í•œ ì—ì´ì „íŠ¸ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŒ")
            
            task.assigned_agent = agent.profile.name
            task.status = TaskStatus.PROCESSING
            
            if self.on_status_update:
                self.on_status_update(f"ì‘ì—… ì²˜ë¦¬ ì¤‘: {task.id} â†’ {agent.profile.name}")
            
            # ì‘ì—… ì‹¤í–‰
            result = agent.process(task)
            
            # ì‘ì—… ì™„ë£Œ
            task.result = result
            task.status = TaskStatus.COMPLETED
            task.completed_at = datetime.now()
            
            with self.lock:
                del self.active_tasks[task.id]
                self.completed_tasks[task.id] = task
                self.stats["completed_tasks"] += 1
                
                # í‰ê·  ì™„ë£Œ ì‹œê°„ ì—…ë°ì´íŠ¸
                if task.started_at and task.completed_at:
                    completion_time = (task.completed_at - task.started_at).total_seconds()
                    alpha = 0.1
                    if self.stats["average_completion_time"] == 0:
                        self.stats["average_completion_time"] = completion_time
                    else:
                        self.stats["average_completion_time"] = (
                            alpha * completion_time + 
                            (1 - alpha) * self.stats["average_completion_time"]
                        )
            
            logger.info(f"ì‘ì—… ì™„ë£Œ: {task.id}")
            
            if self.on_task_complete:
                self.on_task_complete(task)
                
        except Exception as e:
            # ì‘ì—… ì‹¤íŒ¨
            task.status = TaskStatus.FAILED
            task.error = str(e)
            task.completed_at = datetime.now()
            
            with self.lock:
                if task.id in self.active_tasks:
                    del self.active_tasks[task.id]
                self.completed_tasks[task.id] = task
                self.stats["failed_tasks"] += 1
            
            logger.error(f"ì‘ì—… ì‹¤íŒ¨: {task.id} - {str(e)}")
            
            if self.on_task_error:
                self.on_task_error(task, e)
    
    def get_statistics(self) -> Dict[str, Any]:
        """í†µê³„ ì •ë³´ ë°˜í™˜"""
        with self.lock:
            stats = self.stats.copy()
            stats["active_tasks"] = len(self.active_tasks)
            stats["queued_tasks"] = self.task_queue.qsize()
            stats["agents"] = {
                name: {
                    "role": agent.profile.role.value,
                    "loaded": agent.is_loaded,
                    "busy": agent.is_busy,
                    "performance": agent.profile.performance_score,
                    "tasks_completed": agent.profile.successful_tasks
                }
                for name, agent in self.agents.items()
            }
            return stats

# ==================== 8. ê³ ê¸‰ UI ====================
class OrchestratorUI(ctk.CTk):
    """ì˜¤ì¼€ìŠ¤íŠ¸ë ˆì´í„° ê³ ê¸‰ UI"""
    
    def __init__(self):
        super().__init__()
        
        self.title("GGUF ì˜¤ì¼€ìŠ¤íŠ¸ë ˆì´í„° LLM ì‹œìŠ¤í…œ")
        self.geometry("1400x900")
        
        # í…Œë§ˆ ì„¤ì •
        ctk.set_appearance_mode("dark")
        ctk.set_default_color_theme("blue")
        
        # ì˜¤ì¼€ìŠ¤íŠ¸ë ˆì´í„° ì´ˆê¸°í™”
        self.orchestrator = Orchestrator(max_workers=3)
        self.orchestrator.on_task_complete = self.on_task_complete
        self.orchestrator.on_task_error = self.on_task_error
        self.orchestrator.on_status_update = self.on_status_update
        
        # íŒŒì´í”„ë¼ì¸
        self.pipelines: Dict[str, Pipeline] = {}
        
        # UI êµ¬ì„±
        self.setup_ui()
        
        # ì‹œìŠ¤í…œ ëª¨ë‹ˆí„°ë§ ì‹œì‘
        self.start_monitoring()
        
        # ì˜¤ì¼€ìŠ¤íŠ¸ë ˆì´í„° ì‹œì‘
        self.orchestrator.start()
        
    def setup_ui(self):
        """UI êµ¬ì„±"""
        # ë©”ì¸ ì»¨í…Œì´ë„ˆ
        main_container = ctk.CTkFrame(self)
        main_container.pack(fill="both", expand=True, padx=10, pady=10)
        
        # ìƒë‹¨ ì •ë³´ ë°”
        self.setup_info_bar(main_container)
        
        # ë©”ì¸ ì½˜í…ì¸  ì˜ì—­
        content_frame = ctk.CTkFrame(main_container)
        content_frame.pack(fill="both", expand=True, pady=(10, 0))
        
        # 3ë‹¨ ë ˆì´ì•„ì›ƒ
        # ì¢Œì¸¡: ì—ì´ì „íŠ¸ ê´€ë¦¬
        left_frame = ctk.CTkFrame(content_frame, width=350)
        left_frame.pack(side="left", fill="y", padx=(0, 5))
        left_frame.pack_propagate(False)
        self.setup_agent_panel(left_frame)
        
        # ì¤‘ì•™: ì‘ì—… ê´€ë¦¬
        center_frame = ctk.CTkFrame(content_frame)
        center_frame.pack(side="left", fill="both", expand=True, padx=5)
        self.setup_task_panel(center_frame)
        
        # ìš°ì¸¡: ëª¨ë‹ˆí„°ë§
        right_frame = ctk.CTkFrame(content_frame, width=350)
        right_frame.pack(side="right", fill="y", padx=(5, 0))
        right_frame.pack_propagate(False)
        self.setup_monitoring_panel(right_frame)
        
    def setup_info_bar(self, parent):
        """ìƒë‹¨ ì •ë³´ ë°”"""
        info_bar = ctk.CTkFrame(parent, height=80)
        info_bar.pack(fill="x")
        info_bar.pack_propagate(False)
        
        # ì‹œìŠ¤í…œ ìƒíƒœ
        status_frame = ctk.CTkFrame(info_bar)
        status_frame.pack(side="left", padx=20, pady=10)
        
        ctk.CTkLabel(status_frame, text="ì‹œìŠ¤í…œ ìƒíƒœ", 
                     font=("Helvetica", 14, "bold")).pack()
        self.status_label = ctk.CTkLabel(status_frame, text="ì¤€ë¹„", 
                                         font=("Helvetica", 12))
        self.status_label.pack()
        
        # ë©”ëª¨ë¦¬ ì •ë³´
        memory_frame = ctk.CTkFrame(info_bar)
        memory_frame.pack(side="left", padx=20, pady=10)
        
        ctk.CTkLabel(memory_frame, text="ë©”ëª¨ë¦¬", 
                     font=("Helvetica", 14, "bold")).pack()
        self.memory_label = ctk.CTkLabel(memory_frame, text="0.0 GB / 0.0 GB",
                                        font=("Helvetica", 12))
        self.memory_label.pack()
        
        # CPU ì •ë³´
        cpu_frame = ctk.CTkFrame(info_bar)
        cpu_frame.pack(side="left", padx=20, pady=10)
        
        ctk.CTkLabel(cpu_frame, text="CPU", 
                     font=("Helvetica", 14, "bold")).pack()
        self.cpu_label = ctk.CTkLabel(cpu_frame, text="0%",
                                     font=("Helvetica", 12))
        self.cpu_label.pack()
        
        # ì‘ì—… í†µê³„
        stats_frame = ctk.CTkFrame(info_bar)
        stats_frame.pack(side="left", padx=20, pady=10)
        
        ctk.CTkLabel(stats_frame, text="ì‘ì—… í†µê³„", 
                     font=("Helvetica", 14, "bold")).pack()
        self.stats_label = ctk.CTkLabel(stats_frame, text="ì™„ë£Œ: 0 / ì‹¤íŒ¨: 0",
                                       font=("Helvetica", 12))
        self.stats_label.pack()
        
    def setup_agent_panel(self, parent):
        """ì—ì´ì „íŠ¸ ê´€ë¦¬ íŒ¨ë„"""
        # ì œëª©
        ctk.CTkLabel(parent, text="ì—ì´ì „íŠ¸ ê´€ë¦¬", 
                     font=("Helvetica", 18, "bold")).pack(pady=10)
        
        # ì—ì´ì „íŠ¸ ì¶”ê°€ ë²„íŠ¼
        add_agent_btn = ctk.CTkButton(
            parent, 
            text="+ ì—ì´ì „íŠ¸ ì¶”ê°€",
            command=self.show_add_agent_dialog,
            height=35
        )
        add_agent_btn.pack(padx=10, pady=5)
        
        # ì—ì´ì „íŠ¸ ëª©ë¡
        ctk.CTkLabel(parent, text="í™œì„± ì—ì´ì „íŠ¸:", 
                     font=("Helvetica", 14)).pack(anchor="w", padx=10, pady=(10, 5))
        
        self.agent_listbox = ctk.CTkTextbox(parent, height=300)
        self.agent_listbox.pack(fill="both", expand=True, padx=10, pady=5)
        
        # ë¹ ë¥¸ ì—ì´ì „íŠ¸ ì¶”ê°€ (ì˜ˆì œ)
        quick_add_frame = ctk.CTkFrame(parent)
        quick_add_frame.pack(fill="x", padx=10, pady=10)
        
        ctk.CTkLabel(quick_add_frame, text="ë¹ ë¥¸ ì¶”ê°€:", 
                     font=("Helvetica", 12)).pack(anchor="w")
        
        ctk.CTkButton(
            quick_add_frame,
            text="ì¼ë°˜ ëŒ€í™” ì—ì´ì „íŠ¸",
            command=lambda: self.quick_add_agent("general"),
            width=140,
            height=28
        ).pack(side="left", padx=2, pady=2)
        
        ctk.CTkButton(
            quick_add_frame,
            text="ì½”ë”© ì—ì´ì „íŠ¸",
            command=lambda: self.quick_add_agent("coder"),
            width=140,
            height=28
        ).pack(side="left", padx=2, pady=2)
        
    def setup_task_panel(self, parent):
        """ì‘ì—… ê´€ë¦¬ íŒ¨ë„"""
        # ì œëª©
        ctk.CTkLabel(parent, text="ì‘ì—… ê´€ë¦¬", 
                     font=("Helvetica", 18, "bold")).pack(pady=10)
        
        # íƒ­ë·°
        tabview = ctk.CTkTabview(parent)
        tabview.pack(fill="both", expand=True, padx=10, pady=5)
        
        # ë‹¨ì¼ ì‘ì—… íƒ­
        single_tab = tabview.add("ë‹¨ì¼ ì‘ì—…")
        self.setup_single_task_tab(single_tab)
        
        # íŒŒì´í”„ë¼ì¸ íƒ­
        pipeline_tab = tabview.add("íŒŒì´í”„ë¼ì¸")
        self.setup_pipeline_tab(pipeline_tab)
        
        # ì‘ì—… í íƒ­
        queue_tab = tabview.add("ì‘ì—… í")
        self.setup_queue_tab(queue_tab)
        
    def setup_single_task_tab(self, parent):
        """ë‹¨ì¼ ì‘ì—… íƒ­"""
        # ì‘ì—… íƒ€ì… ì„ íƒ
        type_frame = ctk.CTkFrame(parent)
        type_frame.pack(fill="x", pady=5)
        
        ctk.CTkLabel(type_frame, text="ì‘ì—… íƒ€ì…:").pack(side="left", padx=5)
        self.task_type_var = ctk.StringVar(value=AgentRole.GENERAL.value)
        task_type_menu = ctk.CTkOptionMenu(
            type_frame,
            variable=self.task_type_var,
            values=[role.value for role in AgentRole]
        )
        task_type_menu.pack(side="left", padx=5)
        
        # ìš°ì„ ìˆœìœ„ ì„ íƒ
        ctk.CTkLabel(type_frame, text="ìš°ì„ ìˆœìœ„:").pack(side="left", padx=(20, 5))
        self.priority_var = ctk.StringVar(value=TaskPriority.NORMAL.name)
        priority_menu = ctk.CTkOptionMenu(
            type_frame,
            variable=self.priority_var,
            values=[p.name for p in TaskPriority]
        )
        priority_menu.pack(side="left", padx=5)
        
        # í”„ë¡¬í”„íŠ¸ ì…ë ¥
        ctk.CTkLabel(parent, text="í”„ë¡¬í”„íŠ¸:").pack(anchor="w", pady=(10, 5))
        self.prompt_input = ctk.CTkTextbox(parent, height=150)
        self.prompt_input.pack(fill="x", pady=5)
        
        # ì œì¶œ ë²„íŠ¼
        submit_btn = ctk.CTkButton(
            parent,
            text="ì‘ì—… ì œì¶œ",
            command=self.submit_single_task,
            height=40,
            font=("Helvetica", 14, "bold")
        )
        submit_btn.pack(pady=10)
        
        # ê²°ê³¼ í‘œì‹œ
        ctk.CTkLabel(parent, text="ê²°ê³¼:").pack(anchor="w", pady=(10, 5))
        self.result_box = ctk.CTkTextbox(parent, height=200)
        self.result_box.pack(fill="both", expand=True, pady=5)
        
    def setup_pipeline_tab(self, parent):
        """íŒŒì´í”„ë¼ì¸ íƒ­"""
        # íŒŒì´í”„ë¼ì¸ ì„ íƒ
        pipeline_frame = ctk.CTkFrame(parent)
        pipeline_frame.pack(fill="x", pady=5)
        
        ctk.CTkLabel(pipeline_frame, text="íŒŒì´í”„ë¼ì¸:").pack(side="left", padx=5)
        self.pipeline_var = ctk.StringVar(value="ìƒˆ íŒŒì´í”„ë¼ì¸")
        self.pipeline_menu = ctk.CTkOptionMenu(
            pipeline_frame,
            variable=self.pipeline_var,
            values=["ìƒˆ íŒŒì´í”„ë¼ì¸", "ì½”ë“œ ë¦¬ë·°", "ë²ˆì—­ íŒŒì´í”„ë¼ì¸"]
        )
        self.pipeline_menu.pack(side="left", padx=5)
        
        ctk.CTkButton(
            pipeline_frame,
            text="íŒŒì´í”„ë¼ì¸ ìƒì„±",
            command=self.create_pipeline,
            width=120
        ).pack(side="left", padx=10)
        
        # íŒŒì´í”„ë¼ì¸ ë‹¨ê³„
        ctk.CTkLabel(parent, text="íŒŒì´í”„ë¼ì¸ ë‹¨ê³„:").pack(anchor="w", pady=(10, 5))
        self.pipeline_stages_box = ctk.CTkTextbox(parent, height=150)
        self.pipeline_stages_box.pack(fill="x", pady=5)
        
        # ì…ë ¥
        ctk.CTkLabel(parent, text="ì…ë ¥:").pack(anchor="w", pady=(10, 5))
        self.pipeline_input = ctk.CTkTextbox(parent, height=100)
        self.pipeline_input.pack(fill="x", pady=5)
        
        # ì‹¤í–‰ ë²„íŠ¼
        execute_btn = ctk.CTkButton(
            parent,
            text="íŒŒì´í”„ë¼ì¸ ì‹¤í–‰",
            command=self.execute_pipeline,
            height=40,
            font=("Helvetica", 14, "bold")
        )
        execute_btn.pack(pady=10)
        
        # íŒŒì´í”„ë¼ì¸ ê²°ê³¼
        ctk.CTkLabel(parent, text="íŒŒì´í”„ë¼ì¸ ê²°ê³¼:").pack(anchor="w", pady=(10, 5))
        self.pipeline_result_box = ctk.CTkTextbox(parent, height=150)
        self.pipeline_result_box.pack(fill="both", expand=True, pady=5)
        
    def setup_queue_tab(self, parent):
        """ì‘ì—… í íƒ­"""
        # í ìƒíƒœ
        ctk.CTkLabel(parent, text="ì‘ì—… í ìƒíƒœ", 
                     font=("Helvetica", 16, "bold")).pack(pady=10)
        
        # í™œì„± ì‘ì—…
        ctk.CTkLabel(parent, text="ì²˜ë¦¬ ì¤‘:").pack(anchor="w", pady=5)
        self.active_tasks_box = ctk.CTkTextbox(parent, height=150)
        self.active_tasks_box.pack(fill="x", pady=5)
        
        # ëŒ€ê¸° ì¤‘ì¸ ì‘ì—…
        ctk.CTkLabel(parent, text="ëŒ€ê¸° ì¤‘:").pack(anchor="w", pady=5)
        self.queued_tasks_box = ctk.CTkTextbox(parent, height=150)
        self.queued_tasks_box.pack(fill="x", pady=5)
        
        # ì™„ë£Œëœ ì‘ì—…
        ctk.CTkLabel(parent, text="ìµœê·¼ ì™„ë£Œ:").pack(anchor="w", pady=5)
        self.completed_tasks_box = ctk.CTkTextbox(parent, height=150)
        self.completed_tasks_box.pack(fill="both", expand=True, pady=5)
        
    def setup_monitoring_panel(self, parent):
        """ëª¨ë‹ˆí„°ë§ íŒ¨ë„"""
        # ì œëª©
        ctk.CTkLabel(parent, text="ì‹œìŠ¤í…œ ëª¨ë‹ˆí„°ë§", 
                     font=("Helvetica", 18, "bold")).pack(pady=10)
        
        # ì‹¤ì‹œê°„ ë¡œê·¸
        ctk.CTkLabel(parent, text="ì‹¤ì‹œê°„ ë¡œê·¸:", 
                     font=("Helvetica", 14)).pack(anchor="w", padx=10, pady=5)
        
        self.log_box = ctk.CTkTextbox(parent, height=250)
        self.log_box.pack(fill="x", padx=10, pady=5)
        
        # ì—ì´ì „íŠ¸ ì„±ëŠ¥
        ctk.CTkLabel(parent, text="ì—ì´ì „íŠ¸ ì„±ëŠ¥:", 
                     font=("Helvetica", 14)).pack(anchor="w", padx=10, pady=(10, 5))
        
        self.performance_box = ctk.CTkTextbox(parent, height=200)
        self.performance_box.pack(fill="x", padx=10, pady=5)
        
        # ì œì–´ ë²„íŠ¼
        control_frame = ctk.CTkFrame(parent)
        control_frame.pack(fill="x", padx=10, pady=10)
        
        ctk.CTkButton(
            control_frame,
            text="í†µê³„ ì´ˆê¸°í™”",
            command=self.reset_stats,
            width=100
        ).pack(side="left", padx=5)
        
        ctk.CTkButton(
            control_frame,
            text="ë¡œê·¸ ì§€ìš°ê¸°",
            command=lambda: self.log_box.delete("1.0", "end"),
            width=100
        ).pack(side="left", padx=5)
        
    def show_add_agent_dialog(self):
        """ì—ì´ì „íŠ¸ ì¶”ê°€ ëŒ€í™”ìƒì"""
        dialog = ctk.CTkToplevel(self)
        dialog.title("ì—ì´ì „íŠ¸ ì¶”ê°€")
        dialog.geometry("500x600")
        dialog.transient(self)
        dialog.grab_set()
        
        # ì¤‘ì•™ ì •ë ¬
        dialog.update_idletasks()
        x = (dialog.winfo_screenwidth() // 2) - (250)
        y = (dialog.winfo_screenheight() // 2) - (300)
        dialog.geometry(f"+{x}+{y}")
        
        # ì…ë ¥ í•„ë“œ
        ctk.CTkLabel(dialog, text="ì—ì´ì „íŠ¸ ì´ë¦„:").pack(pady=5)
        name_entry = ctk.CTkEntry(dialog, width=300)
        name_entry.pack(pady=5)
        
        ctk.CTkLabel(dialog, text="ì—­í• :").pack(pady=5)
        role_var = ctk.StringVar(value=AgentRole.GENERAL.value)
        role_menu = ctk.CTkOptionMenu(
            dialog,
            variable=role_var,
            values=[role.value for role in AgentRole],
            width=300
        )
        role_menu.pack(pady=5)
        
        ctk.CTkLabel(dialog, text="ëª¨ë¸ íŒŒì¼:").pack(pady=5)
        model_path_var = ctk.StringVar()
        model_path_label = ctk.CTkLabel(dialog, text="ì„ íƒë˜ì§€ ì•ŠìŒ", 
                                       text_color="gray")
        model_path_label.pack(pady=5)
        
        def select_model():
            path = filedialog.askopenfilename(
                title="GGUF ëª¨ë¸ ì„ íƒ",
                filetypes=[("GGUF íŒŒì¼", "*.gguf"), ("ëª¨ë“  íŒŒì¼", "*.*")]
            )
            if path:
                model_path_var.set(path)
                model_path_label.configure(text=os.path.basename(path))
        
        ctk.CTkButton(dialog, text="ëª¨ë¸ íŒŒì¼ ì„ íƒ", 
                     command=select_model).pack(pady=5)
        
        ctk.CTkLabel(dialog, text="ëª¨ë¸ í¬ê¸° (GB):").pack(pady=5)
        size_entry = ctk.CTkEntry(dialog, width=300)
        size_entry.insert(0, "3.0")
        size_entry.pack(pady=5)
        
        ctk.CTkLabel(dialog, text="ì‹œìŠ¤í…œ í”„ë¡¬í”„íŠ¸:").pack(pady=5)
        prompt_text = ctk.CTkTextbox(dialog, width=300, height=100)
        prompt_text.pack(pady=5)
        
        # ê³ ê¸‰ ì„¤ì •
        advanced_frame = ctk.CTkFrame(dialog)
        advanced_frame.pack(fill="x", padx=20, pady=10)
        
        ctk.CTkLabel(advanced_frame, text="ì»¨í…ìŠ¤íŠ¸ í¬ê¸°:").grid(row=0, column=0, padx=5, pady=2, sticky="w")
        context_entry = ctk.CTkEntry(advanced_frame, width=100)
        context_entry.insert(0, "2048")
        context_entry.grid(row=0, column=1, padx=5, pady=2)
        
        ctk.CTkLabel(advanced_frame, text="Temperature:").grid(row=1, column=0, padx=5, pady=2, sticky="w")
        temp_entry = ctk.CTkEntry(advanced_frame, width=100)
        temp_entry.insert(0, "0.7")
        temp_entry.grid(row=1, column=1, padx=5, pady=2)
        
        ctk.CTkLabel(advanced_frame, text="Max Tokens:").grid(row=2, column=0, padx=5, pady=2, sticky="w")
        tokens_entry = ctk.CTkEntry(advanced_frame, width=100)
        tokens_entry.insert(0, "1024")
        tokens_entry.grid(row=2, column=1, padx=5, pady=2)
        
        # ë²„íŠ¼
        button_frame = ctk.CTkFrame(dialog)
        button_frame.pack(pady=20)
        
        def add_agent():
            try:
                profile = AgentProfile(
                    name=name_entry.get(),
                    role=AgentRole(role_var.get()),
                    model_path=model_path_var.get(),
                    model_size_gb=float(size_entry.get()),
                    context_size=int(context_entry.get()),
                    temperature=float(temp_entry.get()),
                    max_tokens=int(tokens_entry.get()),
                    system_prompt=prompt_text.get("1.0", "end").strip()
                )
                
                agent = Agent(profile)
                if self.orchestrator.register_agent(agent):
                    self.update_agent_list()
                    dialog.destroy()
                    messagebox.showinfo("ì„±ê³µ", f"ì—ì´ì „íŠ¸ '{profile.name}' ì¶”ê°€ ì™„ë£Œ")
                else:
                    messagebox.showerror("ì˜¤ë¥˜", "ì—ì´ì „íŠ¸ ë¡œë“œ ì‹¤íŒ¨")
                    
            except Exception as e:
                messagebox.showerror("ì˜¤ë¥˜", str(e))
        
        ctk.CTkButton(button_frame, text="ì¶”ê°€", command=add_agent,
                     width=100).pack(side="left", padx=5)
        ctk.CTkButton(button_frame, text="ì·¨ì†Œ", command=dialog.destroy,
                     width=100).pack(side="left", padx=5)
        
    def quick_add_agent(self, agent_type: str):
        """ë¹ ë¥¸ ì—ì´ì „íŠ¸ ì¶”ê°€"""
        # ì˜ˆì œ ì„¤ì • (ì‹¤ì œ ì‚¬ìš©ì‹œ ìˆ˜ì • í•„ìš”)
        configs = {
            "general": {
                "name": f"general_agent_{int(time.time())}",
                "role": AgentRole.GENERAL,
                "model_path": "models/llama-2-7b.gguf",  # ì‹¤ì œ ê²½ë¡œë¡œ ë³€ê²½
                "model_size_gb": 7.0,
                "system_prompt": "You are a helpful AI assistant."
            },
            "coder": {
                "name": f"coder_agent_{int(time.time())}",
                "role": AgentRole.CODER,
                "model_path": "models/codellama-7b.gguf",  # ì‹¤ì œ ê²½ë¡œë¡œ ë³€ê²½
                "model_size_gb": 7.0,
                "system_prompt": "You are an expert programmer."
            }
        }
        
        if agent_type in configs:
            try:
                config = configs[agent_type]
                profile = AgentProfile(**config)
                agent = Agent(profile)
                
                if self.orchestrator.register_agent(agent):
                    self.update_agent_list()
                    self.log(f"ì—ì´ì „íŠ¸ '{profile.name}' ì¶”ê°€ ì™„ë£Œ")
                else:
                    messagebox.showerror("ì˜¤ë¥˜", "ì—ì´ì „íŠ¸ ë¡œë“œ ì‹¤íŒ¨")
                    
            except Exception as e:
                messagebox.showerror("ì˜¤ë¥˜", str(e))
    
    def submit_single_task(self):
        """ë‹¨ì¼ ì‘ì—… ì œì¶œ"""
        content = self.prompt_input.get("1.0", "end").strip()
        if not content:
            return
        
        task = Task(
            id="",
            content=content,
            role=AgentRole(self.task_type_var.get()),
            priority=TaskPriority[self.priority_var.get()]
        )
        
        task_id = self.orchestrator.submit_task(task)
        self.log(f"ì‘ì—… ì œì¶œ: {task_id}")
        
        # ì…ë ¥ ì´ˆê¸°í™”
        self.prompt_input.delete("1.0", "end")
    
    def create_pipeline(self):
        """íŒŒì´í”„ë¼ì¸ ìƒì„±"""
        name = self.pipeline_var.get()
        
        if name == "ì½”ë“œ ë¦¬ë·°":
            pipeline = Pipeline("code_review")
            pipeline.add_stage("analyze", AgentRole.ANALYZER, 
                             "Analyze this code: {input}")
            pipeline.add_stage("debug", AgentRole.DEBUGGER,
                             "Find potential bugs in: {input}")
            pipeline.add_stage("improve", AgentRole.CODER,
                             "Suggest improvements for: {input}")
            self.pipelines[name] = pipeline
            self.pipeline_stages_box.insert("1.0", 
                "1. ì½”ë“œ ë¶„ì„ (Analyzer)\n2. ë²„ê·¸ ê²€ì‚¬ (Debugger)\n3. ê°œì„  ì œì•ˆ (Coder)\n")
            
        elif name == "ë²ˆì—­ íŒŒì´í”„ë¼ì¸":
            pipeline = Pipeline("translation")
            pipeline.add_stage("translate", AgentRole.TRANSLATOR,
                             "Translate to English: {input}")
            pipeline.add_stage("validate", AgentRole.VALIDATOR,
                             "Validate translation: {input}")
            self.pipelines[name] = pipeline
            self.pipeline_stages_box.insert("1.0",
                "1. ë²ˆì—­ (Translator)\n2. ê²€ì¦ (Validator)\n")
            
        self.log(f"íŒŒì´í”„ë¼ì¸ '{name}' ìƒì„± ì™„ë£Œ")
    
    def execute_pipeline(self):
        """íŒŒì´í”„ë¼ì¸ ì‹¤í–‰"""
        pipeline_name = self.pipeline_var.get()
        if pipeline_name not in self.pipelines:
            messagebox.showwarning("ê²½ê³ ", "ë¨¼ì € íŒŒì´í”„ë¼ì¸ì„ ìƒì„±í•˜ì„¸ìš”")
            return
        
        input_text = self.pipeline_input.get("1.0", "end").strip()
        if not input_text:
            return
        
        pipeline = self.pipelines[pipeline_name]
        
        # ë¹„ë™ê¸° ì‹¤í–‰
        def run_pipeline():
            try:
                results = pipeline.execute(self.orchestrator, input_text)
                
                # ê²°ê³¼ í‘œì‹œ
                result_text = "=== íŒŒì´í”„ë¼ì¸ ì‹¤í–‰ ê²°ê³¼ ===\n\n"
                for stage_name, result in results.items():
                    result_text += f"[{stage_name}]\n{result}\n\n"
                
                self.after(0, lambda: self.pipeline_result_box.insert("1.0", result_text))
                
            except Exception as e:
                self.after(0, lambda: messagebox.showerror("ì˜¤ë¥˜", str(e)))
        
        threading.Thread(target=run_pipeline, daemon=True).start()
        self.log(f"íŒŒì´í”„ë¼ì¸ '{pipeline_name}' ì‹¤í–‰ ì‹œì‘")
    
    def update_agent_list(self):
        """ì—ì´ì „íŠ¸ ëª©ë¡ ì—…ë°ì´íŠ¸"""
        self.agent_listbox.delete("1.0", "end")
        
        for name, agent in self.orchestrator.agents.items():
            status = "ğŸŸ¢" if agent.is_loaded else "ğŸ”´"
            busy = "ğŸ”„" if agent.is_busy else "âœ…"
            info = f"{status} {name} ({agent.profile.role.value}) {busy}\n"
            info += f"  ì„±ëŠ¥: {agent.profile.performance_score:.2f}\n"
            info += f"  ì‘ì—…: {agent.profile.successful_tasks}/{agent.profile.total_tasks}\n"
            info += "â”€" * 30 + "\n"
            self.agent_listbox.insert("end", info)
    
    def start_monitoring(self):
        """ì‹œìŠ¤í…œ ëª¨ë‹ˆí„°ë§ ì‹œì‘"""
        def monitor():
            while True:
                try:
                    # ì‹œìŠ¤í…œ ì •ë³´
                    memory_info = SystemMonitor.get_memory_info()
                    cpu_info = SystemMonitor.get_cpu_info()
                    
                    # í†µê³„
                    stats = self.orchestrator.get_statistics()
                    
                    # UI ì—…ë°ì´íŠ¸
                    self.after(0, lambda: self.update_monitoring(memory_info, cpu_info, stats))
                    
                    time.sleep(1)
                except:
                    pass
        
        thread = threading.Thread(target=monitor, daemon=True)
        thread.start()
    
    def update_monitoring(self, memory_info, cpu_info, stats):
        """ëª¨ë‹ˆí„°ë§ ì •ë³´ ì—…ë°ì´íŠ¸"""
        # ë©”ëª¨ë¦¬
        self.memory_label.configure(
            text=f"{memory_info['used_gb']:.1f} / {memory_info['total_gb']:.1f} GB"
        )
        
        # CPU
        self.cpu_label.configure(text=f"{cpu_info['percent']:.1f}%")
        
        # í†µê³„
        self.stats_label.configure(
            text=f"ì™„ë£Œ: {stats['completed_tasks']} / ì‹¤íŒ¨: {stats['failed_tasks']}"
        )
        
        # í ìƒíƒœ
        self.active_tasks_box.delete("1.0", "end")
        for task_id, task in self.orchestrator.active_tasks.items():
            self.active_tasks_box.insert("end", 
                f"{task_id}: {task.status.value} ({task.assigned_agent})\n")
        
        # ì—ì´ì „íŠ¸ ì„±ëŠ¥
        self.performance_box.delete("1.0", "end")
        for name, agent_stats in stats.get("agents", {}).items():
            perf_text = f"{name}:\n"
            perf_text += f"  ì„±ëŠ¥: {agent_stats['performance']:.2f}\n"
            perf_text += f"  ì™„ë£Œ: {agent_stats['tasks_completed']}\n"
            self.performance_box.insert("end", perf_text)
    
    def on_task_complete(self, task: Task):
        """ì‘ì—… ì™„ë£Œ ì½œë°±"""
        self.after(0, lambda: self._handle_task_complete(task))
    
    def _handle_task_complete(self, task: Task):
        """ì‘ì—… ì™„ë£Œ ì²˜ë¦¬"""
        # ê²°ê³¼ í‘œì‹œ
        result_text = f"=== ì‘ì—… ì™„ë£Œ: {task.id} ===\n"
        result_text += f"ì—ì´ì „íŠ¸: {task.assigned_agent}\n"
        result_text += f"ì†Œìš” ì‹œê°„: {(task.completed_at - task.started_at).total_seconds():.2f}ì´ˆ\n"
        result_text += f"ê²°ê³¼:\n{task.result}\n\n"
        
        self.result_box.insert("1.0", result_text)
        
        # ì™„ë£Œ ëª©ë¡ ì—…ë°ì´íŠ¸
        self.completed_tasks_box.insert("1.0", 
            f"{task.id} ({task.assigned_agent}) âœ…\n")
        
        self.log(f"ì‘ì—… ì™„ë£Œ: {task.id}")
        
        # ì—ì´ì „íŠ¸ ëª©ë¡ ì—…ë°ì´íŠ¸
        self.update_agent_list()
    
    def on_task_error(self, task: Task, error: Exception):
        """ì‘ì—… ì˜¤ë¥˜ ì½œë°±"""
        self.after(0, lambda: self._handle_task_error(task, error))
    
    def _handle_task_error(self, task: Task, error: Exception):
        """ì‘ì—… ì˜¤ë¥˜ ì²˜ë¦¬"""
        self.log(f"ì‘ì—… ì‹¤íŒ¨: {task.id} - {str(error)}", "ERROR")
        
        # ì™„ë£Œ ëª©ë¡ì— ì‹¤íŒ¨ í‘œì‹œ
        self.completed_tasks_box.insert("1.0", 
            f"{task.id} ({task.assigned_agent}) âŒ\n")
    
    def on_status_update(self, message: str):
        """ìƒíƒœ ì—…ë°ì´íŠ¸"""
        self.after(0, lambda: self.status_label.configure(text=message))
    
    def log(self, message: str, level: str = "INFO"):
        """ë¡œê·¸ ë©”ì‹œì§€ ì¶”ê°€"""
        timestamp = datetime.now().strftime("%H:%M:%S")
        log_message = f"[{timestamp}] {level}: {message}\n"
        self.log_box.insert("1.0", log_message)
        
        # ë¡œê±°ì—ë„ ê¸°ë¡
        if level == "ERROR":
            logger.error(message)
        else:
            logger.info(message)
    
    def reset_stats(self):
        """í†µê³„ ì´ˆê¸°í™”"""
        self.orchestrator.stats = {
            "total_tasks": 0,
            "completed_tasks": 0,
            "failed_tasks": 0,
            "average_completion_time": 0.0
        }
        
        for agent in self.orchestrator.agents.values():
            agent.profile.total_tasks = 0
            agent.profile.successful_tasks = 0
            agent.profile.average_response_time = 0.0
            agent.profile.performance_score = 1.0
        
        self.update_agent_list()
        self.log("í†µê³„ ì´ˆê¸°í™” ì™„ë£Œ")
    
    def on_closing(self):
        """ì¢…ë£Œ ì²˜ë¦¬"""
        self.orchestrator.stop()
        
        # ëª¨ë“  ì—ì´ì „íŠ¸ ì–¸ë¡œë“œ
        for agent in self.orchestrator.agents.values():
            agent.unload()
        
        self.destroy()

# ==================== 9. ë©”ì¸ ì‹¤í–‰ ====================
def main():
    """ë©”ì¸ í•¨ìˆ˜"""
    if not LLAMA_CPP_AVAILABLE:
        print("ì˜¤ë¥˜: llama-cpp-pythonì´ ì„¤ì¹˜ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.")
        print("ì„¤ì¹˜: pip install llama-cpp-python")
        return
    
    # ë””ë ‰í† ë¦¬ ìƒì„±
    os.makedirs("models", exist_ok=True)
    os.makedirs("logs", exist_ok=True)
    
    # UI ì‹¤í–‰
    app = OrchestratorUI()
    app.protocol("WM_DELETE_WINDOW", app.on_closing)
    app.mainloop()

if __name__ == "__main__":
    main()