# AMHS 멀티에이전트 시스템 상세 분석 문서

> **문서 버전**: 1.0  
> **분석 일자**: 2026-01-21  
> **대상 시스템**: 반도체 FAB AMHS RAG 시스템

---

## 목차

1. [시스템 개요](#1-시스템-개요)
2. [아키텍처 설계](#2-아키텍처-설계)
3. [파일별 상세 분석](#3-파일별-상세-분석)
   - [config.py](#31-configpy---설정-관리)
   - [_util.py](#32-_utilpy---유틸리티-서비스)
   - [_tool.py](#33-_toolpy---langchain-tools)
   - [_prompt.py](#34-_promptpy---프롬프트-정의)
   - [_node.py](#35-_nodepy---langgraph-노드)
   - [_builder.py](#36-_builderpy---그래프-빌더)
   - [_agent.py](#37-_agentpy---에이전트-정의)
4. [데이터 흐름](#4-데이터-흐름)
5. [에이전트 상호작용 프로토콜](#5-에이전트-상호작용-프로토콜)
6. [개선 권장사항](#6-개선-권장사항)

---

## 1. 시스템 개요

### 1.1 목적

본 시스템은 **반도체 FAB(Fabrication)의 AMHS(Automated Material Handling System)** 데이터를 조회하고 분석하기 위한 **멀티에이전트 기반 RAG 시스템**입니다.

### 1.2 주요 기능

| 기능 | 설명 |
|------|------|
| **반송현황 조회** | FAB별 큐(Queue), 반송, 재공 상태 조회 |
| **위치 추적** | Lot ID 또는 Carrier ID 기반 웨이퍼/캐리어 위치 조회 |
| **로그 분석** | 반송 반려 사유, 에러 로그 분석 (개발 예정) |
| **자연어 질의** | 복합 질문을 자동 분해하여 필요한 정보 수집 |

### 1.3 기술 스택

```
┌─────────────────────────────────────────────────────────────┐
│                      Frontend Layer                         │
│                   (index.html - 제외)                        │
├─────────────────────────────────────────────────────────────┤
│                      Backend Layer                          │
│  ┌─────────────────────────────────────────────────────┐   │
│  │              LangGraph (StateGraph)                  │   │
│  │  ┌──────────┐ ┌──────────┐ ┌──────────┐            │   │
│  │  │Supervisor│→│  Agents  │→│  Final   │            │   │
│  │  └──────────┘ └──────────┘ └──────────┘            │   │
│  └─────────────────────────────────────────────────────┘   │
│  ┌─────────────────────────────────────────────────────┐   │
│  │              LangChain Tools                         │   │
│  │  fab_extract | queue_status | id_extract | location │   │
│  └─────────────────────────────────────────────────────┘   │
├─────────────────────────────────────────────────────────────┤
│                      LLM Layer                              │
│           Hynix Internal API (Qwen3-Next-80B)              │
├─────────────────────────────────────────────────────────────┤
│                      Data Layer                             │
│     ┌──────────┐    ┌──────────┐    ┌──────────┐          │
│     │ STAR DB  │    │  MCS DB  │    │ (Future) │          │
│     │ (Oracle) │    │ (Oracle) │    │  Logs    │          │
│     └──────────┘    └──────────┘    └──────────┘          │
└─────────────────────────────────────────────────────────────┘
```

---

## 2. 아키텍처 설계

### 2.1 멀티에이전트 패턴: Supervisor Pattern

```
                    ┌─────────────────┐
                    │   User Query    │
                    └────────┬────────┘
                             ▼
                    ┌─────────────────┐
          ┌────────│   Supervisor    │────────┐
          │        │  (Router Node)  │        │
          │        └────────┬────────┘        │
          │                 │                 │
          ▼                 ▼                 ▼
┌─────────────────┐ ┌─────────────────┐ ┌─────────────────┐
│  StatusAgent    │ │ LocationAgent   │ │   LogAgent      │
│  (반송현황)      │ │ (위치조회)       │ │  (로그분석)      │
│                 │ │                 │ │                 │
│ Tools:          │ │ Tools:          │ │ Tools:          │
│ - fab_extract   │ │ - id_extract    │ │ - (개발중)       │
│ - queue_status  │ │ - location_search│ │                 │
└────────┬────────┘ └────────┬────────┘ └────────┬────────┘
         │                   │                   │
         └───────────────────┼───────────────────┘
                             ▼
                    ┌─────────────────┐
                    │FinalAnswerAgent │
                    │  (답변 종합)     │
                    └────────┬────────┘
                             ▼
                    ┌─────────────────┐
                    │  Final Answer   │
                    └─────────────────┘
```

### 2.2 상태 관리 (AgentState)

```python
class AgentState(TypedDict):
    messages: Annotated[Sequence[BaseMessage], operator.add]  # 누적 메시지
    next: str      # 다음 실행할 에이전트 ("StatusAgent", "LocationAgent", "FINISH" 등)
    step: int      # 전체 그래프 실행 step 수
```

### 2.3 그래프 흐름

```
START
  │
  ▼
Supervisor ◄──────────────────────────────┐
  │                                       │
  ├──► StatusAgent ───────────────────────┤
  │                                       │
  ├──► LocationAgent ─────────────────────┤
  │                                       │
  ├──► LogAgent ──────────────────────────┤
  │                                       │
  ├──► FinalAnswerAgent ──► END           │
  │                                       │
  └──► FINISH ──► FinalAnswerAgent ──► END
```

---

## 3. 파일별 상세 분석

### 3.1 `config.py` - 설정 관리

#### 3.1.1 LLM API 설정

```python
api_key = "eyJ0eXAi..."  # JWT 토큰

API_BASE = "http://common.llm.skhynix.com/v1"
GET_MODEL_URL = f"{API_BASE}/models"
POST_CHAT_URL = f"{API_BASE}/chat/completions"

model_k = 2  # Qwen3-Next-80B-A3B-Instruct 선택
```

**사용 가능 모델 목록** (index 기준):
| Index | 모델명 |
|-------|--------|
| 0 | gpt-oss-20b |
| 1 | Qwen2.5-VL-72B-Instruct |
| 2 | **Qwen3-Next-80B-A3B-Instruct** (현재 사용) |
| 3 | Qwen3-VL-30B-Instruct |
| 4 | HCP-LLM-Latest |
| 5 | Qwen3-VL-8B-Instruct |

#### 3.1.2 STAR DB 설정 (반송현황 조회용)

| 사이트 | DB Key | IP | Service Name | 용도 |
|--------|--------|-----|--------------|------|
| 이천 | LC | 10.40.41.103 | ICASTARPP | STAR 운영 DB |
| 청주 | CJ | 10.198.212.70 | FC1STARPP | STAR 운영 DB |

```python
STAR_DB_CONFIGS = {
    "LC": {
        "ip": "10.40.41.103",
        "port": 1521,
        "service_name": "ICASTARPP",
        "user": "STAREAD",
        "password": "Stareadadmin123!"
    },
    "CJ": { ... }
}
```

#### 3.1.3 MCS DB 설정 (캐리어 위치 조회용)

**총 18개 FAB DB 연결 정보**:

| FAB | IP | Service Name |
|-----|-----|--------------|
| M14A | 10.125.162.120 | M14MCSQ |
| M14B | 10.125.162.123 | M14MCS7FQ |
| M16A | 10.125.161.125 | M16MCSD |
| M16B | 10.125.161.70 | M16BMCSD |
| PNT4_TSV | 10.125.168.55 | TSVMCSQ |
| WLPKG1 | 10.125.168.52 | WLPMCSQ |
| R3 | 10.125.166.153 | R3MCSQ |
| ICPRB | 10.125.170.194 | IWTPRMCSQ |
| PNT4_WT | 10.125.171.74 | WTMCSD |
| M11A | 10.192.220.52 | M11AMCSQ |
| M11B | 10.192.220.58 | M11BMCSQ |
| M15A | 10.192.226.117 | M15AMCSQ |
| M15B | 10.192.226.120 | M15BMCSQ |
| CJPRB | 10.192.234.168 | CWTMCSQ |
| IPCKG | 10.125.170.156 | ICPKGMCSQ |
| M16_PKT | 10.125.171.76 | ICPKTMCSD |
| CJPKG | 10.192.218.112 | CBEMCSQ |
| CJPKT | 10.192.218.122 | CBETMCSQ |

#### 3.1.4 FAB → DB 매핑

```python
FACTORY_DB_KEY_MAP = {
    # 이천 (LC)
    "M14": "LC", "M14B": "LC", "M16A": "LC", "M16B": "LC",
    "M16E": "LC", "M16HUB": "LC", "M10A": "LC", "M10C": "LC",
    "R3": "LC", "R4": "LC", ...
    
    # 청주 (CJ)
    "M11A": "CJ", "M11B": "CJ", "M15A": "CJ", "M15B": "CJ",
    "CJPRB": "CJ", ...
}
```

#### 3.1.5 FAB → IDC_NM 매핑 (STAR 지표)

각 FAB별로 조회할 수 있는 지표(idc_nm) 목록:

```python
FACTORY_IDC_MAP = {
    'M14': [
        'M14.QUE.ALL.CURRENTQCNT',
        'M14.QUE.LOAD.CURRENTLOADQCNT',
        'M14.QUE.OHT.CURRENTOHTQCNT',
        'M14.QUE.ALL.CURRENTRETICLEQCNT',
        'M14.QUE.LOAD.CURRENTRETICLELOADQCNT',
        'M14.QUE.SENDFAB.VERTICALQUEUECOUNT',
        'M14.QUE.CNV.NORTHCURRENTQCNT',
        'M14.QUE.CNV.SOUTHCURRENTQCNT',
        'M14.QUE.STK.MANUALOUTCOUNT',
        'M14.QUE.ALL.M14ATOM10ACURRENTQCNT',
        'M14.QUE.ALL.M14ATOM10CCURRENTQCNT',
        'M14.QUE.ALL.M14ATOM16MANUAL_CURRENTQCNT'
    ],
    'M16HUB': [
        'M16HUB.QUE.ALL.FABTRANSJOBCNT',
        'M16HUB.QUE.ALL.CURRENTQCNT',
        'M16HUB.QUE.M14TOM16.MESCURRENTQCNT',
        'M16HUB.QUE.M16TOM14.MESCURRENTQCNT',
        ...
    ],
    ...
}
```

---

### 3.2 `_util.py` - 유틸리티 서비스

#### 3.2.1 FactoryStatusService 클래스

**목적**: FAB별 반송/큐 현황을 조회하고 평균 대비 증감률 계산

```python
class FactoryStatusService:
    def __init__(
        self,
        factory_idc_map: dict,      # FAB → idc_nm 매핑
        factory_db_key_map: dict,   # FAB → DB키 매핑
        db_configs: dict,           # DB 접속정보
        current_table: str,         # 현재값 테이블명
        current_value_col: str,     # 현재값 컬럼명
        current_time_col: str,      # 시간 컬럼명
        avg_table: str,             # 평균 테이블명
        avg_value_col: str,         # 평균값 컬럼명
        avg_time_col: str           # 평균 시간 컬럼명
    )
```

**핵심 메서드**:

| 메서드 | 반환 타입 | 설명 |
|--------|----------|------|
| `get_factory_status(fab)` | DataFrame | FAB 현황 전체 조회 |
| `get_factory_status_records(fab)` | List[Dict] | LLM 전달용 dict 리스트 |
| `get_factory_status_markdown(fab)` | str | Markdown 테이블 |

**SQL 쿼리 로직**:

```sql
-- 현재값 조회 (2분 전 1분 구간)
SELECT idc_nm, crt_tm AS current_time, idc_val AS current_value
FROM aws_idc_data_his
WHERE crt_tm >= TRUNC(SYSDATE - INTERVAL '2' MINUTE, 'MI')
  AND crt_tm < TRUNC(SYSDATE - INTERVAL '2' MINUTE, 'MI') + INTERVAL '1' MINUTE
  AND idc_nm IN ('M14.QUE.ALL.CURRENTQCNT', ...)

-- 최근 2일 평균 조회
SELECT idc_nm, ROUND(AVG(avg_val)) AS baseline_mean_2d
FROM aws_idc_daily_sum
WHERE crt_tm > SYSDATE - 2 AND crt_tm <= SYSDATE
  AND idc_nm IN (...)
GROUP BY idc_nm
```

**반환 데이터 구조**:

```python
{
    "factory": "M14",
    "idc_nm": "M14.QUE.ALL.CURRENTQCNT",
    "current_time": datetime(2026, 1, 21, 10, 30),
    "current_value": 1523,
    "baseline_mean_2d": 1450,
    "diff": 73,
    "diff_pct": 5.0  # 5% 증가
}
```

#### 3.2.2 LocationService 클래스

**목적**: Lot ID 또는 Carrier ID로 현재 위치 조회

```python
class LocationService:
    def __init__(
        self,
        db_configs: dict,           # DB 접속정보 (MCS_DB_CONFIGS)
        location_table: str,        # 위치 테이블명 (nt_m_carrier)
        id_col: str = "ID",
        lot_col: str = "LOTID",
        shop_col: str = "SHOPNAME",
        machine_col: str = "MACHINENAME",
        unit_col: str = "UNITNAME",
        time_col: str = "INSTALLTIME",
        db_key_order: list = None   # DB 검색 우선순위
    )
```

**핵심 메서드**:

| 메서드 | 반환 타입 | 설명 |
|--------|----------|------|
| `get_location_df(identifier)` | DataFrame | 위치 정보 DataFrame |
| `get_location_record(identifier)` | Dict \| None | 단일 위치 정보 |
| `get_location_markdown(identifier)` | str | Markdown 테이블 |
| `search_location(identifier)` | Dict \| None | Tool에서 사용하는 메서드 |

**검색 로직**:

```python
# 모든 MCS DB를 순차적으로 검색
for db_key in self.db_key_order:  # ["M14A", "M14B", "M16A", ...]
    df = self._run_query(db_key, sql)
    if not df.empty:
        return df.iloc[0]  # 첫 번째 매칭 반환
return None  # 모든 DB에서 못 찾음
```

**SQL 쿼리**:

```sql
SELECT ID AS carrier_id, LOTID AS lot_id, 
       SHOPNAME AS shopname, MACHINENAME AS machinename,
       UNITNAME AS unitname, INSTALLTIME AS installtime
FROM nt_m_carrier
WHERE ID = '{identifier}' OR LOTID = '{identifier}'
ORDER BY INSTALLTIME DESC
FETCH FIRST 1 ROWS ONLY
```

**반환 데이터 구조**:

```python
{
    "db_key": "M14A",
    "carrier_id": "5NNN3764",
    "lot_id": "5QQ4B74",
    "shopname": "M14",
    "machinename": "EQP001",
    "unitname": "PORT02",
    "installtime": datetime(2026, 1, 21, 14, 23),
    "id_type": "CARRIER"  # 또는 "LOT"
}
```

---

### 3.3 `_tool.py` - LangChain Tools

#### 3.3.1 fab_extract_tool

**목적**: 사용자 질문에서 FAB ID 추출

```python
@tool("fab_extract_tool", description="사용자 질의에서 FAB ID를 추출")
def fab_extract_tool(user_query: str) -> Dict[str, Any]:
    """
    입력: "M14랑 M16A 반송현황 알려줘"
    출력: {"fabs": ["M14", "M16A"]}
    """
```

**내부 동작**:
1. LLM에게 FAB 추출 프롬프트 전달
2. JSON 파싱 (`{"fabs": [...]}`)
3. 중복 제거 및 정제

#### 3.3.2 queue_status_tool

**목적**: 특정 FAB의 반송/큐 현황 DB 조회

```python
@tool("queue_status_tool", description="FAB 반송/큐 현황 조회")
def queue_status_tool(fab: str) -> Dict[str, Any]:
    """
    입력: "M14"
    출력: 
    - 성공: {"ok": True, "fab": "M14", "records": [...]}
    - 실패(잘못된 FAB): {"ok": False, "reason": "invalid_fab", "fab": "M16", "allowed_fabs": [...]}
    - 실패(데이터 없음): {"ok": False, "reason": "no_data", "fab": "M14"}
    """
```

**유효성 검사 흐름**:

```
입력 FAB
    │
    ▼
ALLOWED_FABS에 있는가? ─── No ──► {"ok": False, "reason": "invalid_fab"}
    │
   Yes
    ▼
FactoryStatusService.get_factory_status()
    │
    ▼
데이터가 있는가? ─── No ──► {"ok": False, "reason": "no_data"}
    │
   Yes
    ▼
{"ok": True, "records": [...]}
```

#### 3.3.3 id_extract_tool

**목적**: 사용자 질문에서 Lot/Carrier ID 추출

```python
@tool("id_extract_tool", description="질문에서 LotID/CarrierID 추출")
def id_extract_tool(user_query: str) -> Dict[str, Any]:
    """
    입력: "5NNN3764 어디있어?"
    출력: {"ids": ["5NNN3764"]}
    """
```

**ID 패턴 예시**:
- Lot ID: `5QQ4B74`, `5NA9342`, `S5P499258`
- Carrier ID: `5NNN3764`, `5PNN5557`, `CYTEST06`

#### 3.3.4 location_search_tool

**목적**: ID로 현재 위치 조회

```python
@tool("location_search_tool", description="ID 위치 조회")
def location_search_tool(identifier: str) -> Dict[str, Any]:
    """
    입력: "5NNN3764"
    출력:
    - 성공: {"found": True, "db_key": "M14A", "carrier_id": "5NNN3764", 
             "shopname": "M14", "machinename": "EQP001", ...}
    - 실패: {"found": False, "identifier": "5NNN3764"}
    """
```

---

### 3.4 `_prompt.py` - 프롬프트 정의

#### 3.4.1 Tool 프롬프트

**fab_extract_tool_prompt**:
```
너는 반도체 FAB 관련 질의에서 FAB ID들을 추출하는 도우미이다.
FAB ID 예시: [M14, M16A, M16B, M16E, M16HUB, ...]

출력 형식: {"fabs": ["M14", "M15"]}
```

**id_extract_tool_prompt**:
```
너는 반도체 FAB/AMHS 도메인의 ID 추출 도우미이다.
- Lot ID 예시: 5QQ4B74, 5NA9342, S5P499258
- Carrier ID 예시: 5NNN3764, 5PNN5557, CYTEST06

출력 형식: {"search_terms": ["5NNN3764"]}
```

#### 3.4.2 Agent 프롬프트

**status_agent_prompt** 구조:
```
[사용 도구]
- fab_extract_tool: FAB ID 추출
- queue_status_tool: FAB 반송현황 조회

[유효 FAB 목록]
- M14, M16A, M16B, M16E, M16HUB, ...

[역할]
1. FAB 반송현황 관련 질문인지 판단
2. FAB 후보 추론 (이전 Agent 결과 / 사용자 질문 / fab_extract_tool)
3. queue_status_tool 호출
4. 결과 요약

[출력 형식]
첫 줄: STATUS:SUCCESS; AGENT:STATUS; FABS:[M14]
두 번째 줄~: 자연어 설명
```

**location_agent_prompt** 구조:
```
[사용 도구]
- id_extract_tool: ID 추출
- location_search_tool: 위치 조회

[정보 소스]
1. 현재 사용자 질문
2. 이전 Agent 응답
3. 대화 맥락

[출력 형식]
첫 줄: STATUS:SUCCESS; AGENT:LOCATION; ID:ABC123; FAB:M14
두 번째 줄~: 자연어 설명
```

**log_agent_prompt** (개발 중):
```
항상 다음 형식으로만 응답:
1. STATUS:DEVELOPING; AGENT:LOG
2. "현재 Log Agent는 개발 중입니다."
```

**supervisor_agent_prompt** 구조:
```
[사용 가능한 Agent]
- StatusAgent: FAB 반송현황
- LocationAgent: ID 위치 조회
- LogAgent: 로그 분석
- FinalAnswerAgent: 최종 답변 생성
- FINISH: 종료

[의사결정 절차]
1. 사용자 질문에서 요구 정보 항목 파악
2. 현재까지 수집된 정보 점검 (STATUS 헤더 분석)
3. 다음 Agent 결정

[예시 전략]
- "M14 반송현황" → StatusAgent만
- "abc123 위치" → LocationAgent만
- "abc123 위치한 곳의 반송현황" → LocationAgent → StatusAgent
```

**final_agent_prompt** 핵심 규칙:
```
[핵심 목표]
- 사용자 질문에 대해 정확하고 간결한 답변만 생성
- 질문에서 요구하지 않은 정보는 언급하지 않음

[하지 말 것]
- "추가로," 시작하는 설명
- "향후 문의 시 ~" 가이드
- 요청하지 않은 정보 유형 언급
- 마케팅/상담 문구
```

---

### 3.5 `_node.py` - LangGraph 노드

#### 3.5.1 AgentState 정의

```python
class AgentState(TypedDict):
    messages: Annotated[Sequence[BaseMessage], operator.add]
    next: str
    step: int
```

- `messages`: 대화 히스토리 (누적)
- `next`: 다음 실행할 노드 이름
- `step`: 실행 step 카운터

#### 3.5.2 agent_node 함수

```python
def agent_node(state: AgentState, agent, name: str) -> AgentState:
    """
    ReAct Agent 호출 후 마지막 AI 메시지를 HumanMessage(name=name)으로 변환
    """
    agent_response = agent.invoke(state)
    last = agent_response["messages"][-1]
    new_messages = [HumanMessage(content=last.content, name=name)]
    return {
        "messages": new_messages,
        "step": state.get("step", 0),
        "next": state.get("next", "")
    }
```

**메시지 변환 이유**: Supervisor가 어떤 Agent의 응답인지 식별하기 위해 `name` 필드 추가

#### 3.5.3 노드 정의

```python
# Partial Application으로 각 노드 생성
status_node = functools.partial(agent_node, agent=status_agent, name="StatusAgent")
location_node = functools.partial(agent_node, agent=location_agent, name="LocationAgent")
log_node = functools.partial(agent_node, agent=log_agent, name="LogAgent")

# Final Node는 별도 구현
def final_node(state: AgentState) -> AgentState:
    result = final_agent(state)
    return {
        "messages": result["messages"],
        "step": state.get("step", 0),
        "next": "FINISH"
    }
```

#### 3.5.4 supervisor_node

```python
# Supervisor 라우팅 옵션
options_for_next = ["FINISH", "FinalAnswerAgent", "StatusAgent", "LocationAgent", "LogAgent"]

class RouteResponse(BaseModel):
    next: Literal[tuple(options_for_next)]

def supervisor_node(state: AgentState) -> AgentState:
    supervisor_chain = supervisor_prompt | llm.with_structured_output(RouteResponse)
    route = supervisor_chain.invoke(state)
    return {"next": route.next}
```

**Structured Output 사용**: Pydantic 모델로 응답 형식 강제

---

### 3.6 `_builder.py` - 그래프 빌더

#### 3.6.1 그래프 구성

```python
def build_team_graph():
    workflow = StateGraph(AgentState)
    
    # 노드 등록
    workflow.add_node("Supervisor", supervisor_node)
    workflow.add_node("StatusAgent", status_node)
    workflow.add_node("LocationAgent", location_node)
    workflow.add_node("LogAgent", log_node)
    workflow.add_node("FinalAnswerAgent", final_node)
    
    # 각 Worker → Supervisor 엣지
    for member in ["StatusAgent", "LocationAgent", "LogAgent"]:
        workflow.add_edge(member, "Supervisor")
    
    # Supervisor → 조건부 엣지
    conditional_map = {
        "StatusAgent": "StatusAgent",
        "LocationAgent": "LocationAgent",
        "LogAgent": "LogAgent",
        "FinalAnswerAgent": "FinalAnswerAgent",
        "FINISH": "FinalAnswerAgent"  # FINISH도 FinalAnswerAgent로 이동
    }
    workflow.add_conditional_edges("Supervisor", lambda s: s["next"], conditional_map)
    
    # FinalAnswerAgent → END
    workflow.add_edge("FinalAnswerAgent", END)
    
    # START → Supervisor
    workflow.add_edge(START, "Supervisor")
    
    return workflow.compile()
```

#### 3.6.2 스트리밍 실행 예시

```python
async def stream_final_only(team_graph, user_query: str):
    config = {"configurable": {"thread_id": "test"}, "recursion_limit": 20}
    inputs = {"messages": [{"role": "user", "content": user_query}]}
    
    async for ev in team_graph.astream_events(inputs, config=config, version="v1"):
        md = ev.get("metadata", {}) or {}
        node = md.get("langgraph_node")
        
        # FinalAnswerAgent 토큰만 출력
        if ev.get("event") == "on_chat_model_stream" and node == "FinalAnswerAgent":
            chunk = ev.get("data", {}).get("chunk")
            text = getattr(chunk, "content", None)
            if text:
                print(text, end="", flush=True)
```

---

### 3.7 `_agent.py` - 에이전트 정의

#### 3.7.1 ReAct Agent 생성

```python
# StatusAgent: FAB 반송현황 전문
status_agent = create_react_agent(
    model=llm,
    tools=[fab_extract_tool, queue_status_tool],
    prompt=status_agent_prompt(),
)

# LocationAgent: ID 위치 조회 전문
location_agent = create_react_agent(
    model=llm,
    tools=[id_extract_tool, location_search_tool],
    prompt=location_agent_prompt()
)

# LogAgent: 로그 분석 (개발중, 도구 없음)
log_agent = create_react_agent(
    model=llm,
    tools=[],
    prompt=log_agent_prompt(),
)
```

#### 3.7.2 FinalAnswerAgent 구현

```python
final_prompt = ChatPromptTemplate.from_messages([
    ("system", final_agent_prompt()),
    MessagesPlaceholder("messages"),
])

def build_final_answer_agent():
    def _invoke(state):
        chain = final_prompt | llm
        resp: AIMessage = chain.invoke({"messages": state["messages"]})
        return {"messages": [resp]}
    return _invoke

final_agent = build_final_answer_agent()
```

**FinalAgent 특징**:
- ReAct가 아닌 단순 Chain
- Tool 없음
- 다른 Agent 응답들을 종합해서 최종 답변 생성

---

## 4. 데이터 흐름

### 4.1 단일 의도 질문 예시

**질문**: "M14 반송현황 알려줘"

```
User: "M14 반송현황 알려줘"
    │
    ▼
Supervisor: next="StatusAgent" 결정
    │
    ▼
StatusAgent:
    1. fab_extract_tool("M14 반송현황 알려줘") → {"fabs": ["M14"]}
    2. queue_status_tool("M14") → {"ok": True, "records": [...]}
    3. 응답: "STATUS:SUCCESS; AGENT:STATUS; FABS:[M14]\n현재 M14의 큐는..."
    │
    ▼
Supervisor: STATUS:SUCCESS 확인 → next="FinalAnswerAgent"
    │
    ▼
FinalAnswerAgent: 최종 답변 생성
    │
    ▼
END
```

### 4.2 복합 의도 질문 예시

**질문**: "5NNN3764 위치한 곳의 반송현황 알려줘"

```
User: "5NNN3764 위치한 곳의 반송현황 알려줘"
    │
    ▼
Supervisor: next="LocationAgent" (위치 먼저 확인 필요)
    │
    ▼
LocationAgent:
    1. id_extract_tool(...) → {"ids": ["5NNN3764"]}
    2. location_search_tool("5NNN3764") → {"found": True, "shopname": "M14", ...}
    3. 응답: "STATUS:SUCCESS; AGENT:LOCATION; ID:5NNN3764; FAB:M14\n..."
    │
    ▼
Supervisor: 위치 확인됨(FAB:M14), 반송현황 필요 → next="StatusAgent"
    │
    ▼
StatusAgent:
    1. 이전 LocationAgent 응답에서 FAB:M14 확인
    2. queue_status_tool("M14") → {"ok": True, "records": [...]}
    3. 응답: "STATUS:SUCCESS; AGENT:STATUS; FABS:[M14]\n..."
    │
    ▼
Supervisor: 모든 정보 수집 완료 → next="FinalAnswerAgent"
    │
    ▼
FinalAnswerAgent: 위치 + 반송현황 종합 답변 생성
    │
    ▼
END
```

---

## 5. 에이전트 상호작용 프로토콜

### 5.1 상태 헤더 포맷

모든 Agent는 응답 첫 줄에 상태 헤더를 포함:

```
STATUS:{상태}; AGENT:{에이전트명}; {추가정보}
```

| 상태 | 의미 |
|------|------|
| SUCCESS | 요청 처리 성공 |
| ERROR | 오류 발생 (잘못된 입력, 시스템 오류) |
| NOT_FOUND | 검색 결과 없음 |
| NO_DATA | 데이터 없음 (DB에 해당 기간 데이터 없음) |
| DEVELOPING | 기능 개발 중 |

### 5.2 Agent별 헤더 예시

**StatusAgent**:
```
STATUS:SUCCESS; AGENT:STATUS; FABS:[M14]
STATUS:SUCCESS; AGENT:STATUS; FABS:[M14, M16A]
STATUS:ERROR; AGENT:STATUS; FABS:[]
STATUS:NO_DATA; AGENT:STATUS; FABS:[M14]
```

**LocationAgent**:
```
STATUS:SUCCESS; AGENT:LOCATION; ID:5NNN3764; FAB:M14
STATUS:NOT_FOUND; AGENT:LOCATION; ID:5NNN3764
STATUS:ERROR; AGENT:LOCATION; ID:UNKNOWN
```

**LogAgent**:
```
STATUS:DEVELOPING; AGENT:LOG
```

### 5.3 Supervisor 판단 로직

```python
# Supervisor가 messages를 분석하여 결정
for message in state["messages"]:
    if "STATUS:SUCCESS; AGENT:LOCATION" in message.content:
        # 위치 정보 획득됨
        location_found = True
        fab = extract_fab_from_header(message.content)
    
    if "STATUS:SUCCESS; AGENT:STATUS" in message.content:
        # 반송현황 정보 획득됨
        status_found = True

# 질문 요구사항 vs 획득 정보 비교하여 next 결정
if 질문이_위치_요구 and not location_found:
    return "LocationAgent"
elif 질문이_반송현황_요구 and not status_found:
    return "StatusAgent"
elif 모든_정보_획득:
    return "FinalAnswerAgent"
```

---

## 6. 개선 권장사항

### 6.1 긴급 수정 필요

| 항목 | 현재 상태 | 권장 |
|------|----------|------|
| **LLM temperature** | `2` (매우 높음) | `0.1 ~ 0.3` |
| **API 키 노출** | config.py에 하드코딩 | 환경변수 또는 Secret Manager |
| **DB 비밀번호** | config.py에 하드코딩 | 환경변수 또는 Vault |

### 6.2 기능 개선

| 항목 | 현재 상태 | 권장 |
|------|----------|------|
| **LogAgent** | 개발 중 상태 반환 | 로그 분석 기능 구현 |
| **DB 연결** | 동기 방식 | 비동기 연결 풀 (asyncpg 또는 aiomysql) |
| **에러 처리** | 기본 try-except | 타임아웃, 재시도, Circuit Breaker |
| **캐싱** | 없음 | Redis 캐시 (자주 조회되는 FAB 현황) |

### 6.3 코드 품질

| 항목 | 현재 상태 | 권장 |
|------|----------|------|
| **타입 힌트** | 부분적 | 전체 적용 |
| **로깅** | print문 | logging 모듈 체계화 |
| **테스트** | 없음 | pytest 단위/통합 테스트 |
| **문서화** | 없음 | docstring 추가 |

### 6.4 아키텍처 개선

```
현재: 모든 MCS DB 순차 검색 (18개)
     → 최악의 경우 18번 연결 시도

권장: 
1. FAB-DB 매핑 테이블 활용하여 대상 DB 먼저 특정
2. 또는 통합 조회 API 구축
```

### 6.5 보안 개선

```python
# 현재 (위험)
api_key = "eyJ0eXAi..."

# 권장
import os
api_key = os.environ.get("HYNIX_LLM_API_KEY")
```

---

## 부록 A: 용어 정의

| 용어 | 정의 |
|------|------|
| **AMHS** | Automated Material Handling System, 자동 물류 시스템 |
| **FAB** | Fabrication, 반도체 생산 공장 |
| **Carrier** | 웨이퍼를 담는 용기 (FOUP) |
| **Lot** | 웨이퍼 묶음 단위 |
| **Queue (큐)** | 반송 대기열 |
| **OHT** | Overhead Hoist Transport, 천장 반송 시스템 |
| **STAR DB** | 반송현황 지표 저장 DB |
| **MCS** | Material Control System, 물류 제어 시스템 |

---

## 부록 B: 프로젝트 파일 구조

```
project/
├── app/
│   ├── config.py        # 설정 (API, DB 접속정보, FAB 매핑)
│   ├── _util.py         # 유틸리티 서비스 (FactoryStatusService, LocationService)
│   ├── _db.py           # DB 연결 유틸 (oracle_query)
│   ├── _llm.py          # LLM 클라이언트 (ChatOpenAI)
│   ├── _tool.py         # LangChain Tools (4개)
│   ├── _prompt.py       # 프롬프트 정의
│   ├── _node.py         # LangGraph 노드
│   ├── _agent.py        # Agent 정의
│   └── _builder.py      # 그래프 빌더
├── NODE/LLM_V2/
│   ├── index.html       # 프론트엔드 (분석 제외)
│   └── server.py        # FastAPI 서버 (분석 제외)
└── README.md
```

---

## 부록 C: 실행 예시

```python
from app._builder import build_team_graph
import asyncio

team_graph = build_team_graph()

# 동기 실행
result = team_graph.invoke({
    "messages": [{"role": "user", "content": "M14 반송현황 알려줘"}]
})
print(result["messages"][-1].content)

# 비동기 스트리밍
async def main():
    async for ev in team_graph.astream_events(...):
        ...

asyncio.run(main())
```

---

*문서 끝*