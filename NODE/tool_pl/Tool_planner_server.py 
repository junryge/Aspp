#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Tool Planner 테스트 서버
- 하이닉스 LLM API 사용 (OpenAI 호환)
- TF-IDF 기반 Tool Retrieval
- token.txt에서 API 토큰 로드

필요 패키지:
pip install fastapi uvicorn pydantic requests scikit-learn
"""

import os
import re
import json
import hashlib
import requests
from dataclasses import dataclass, asdict
from typing import Any, Dict, List, Optional, Tuple, Set, Iterable

from fastapi import FastAPI, HTTPException
from fastapi.responses import FileResponse, JSONResponse
from pydantic import BaseModel, Field
import logging

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

app = FastAPI(title="Tool Planner 테스트 시스템")

# =========================================================
# 전역 변수
# =========================================================
tool_specs: Dict[str, Any] = {}
retriever = None
ARTIFACTS_DIR = "test"

# API 설정
API_TOKEN = None
ENV_MODE = "dev"  # "dev" or "prod"

ENV_CONFIG = {
    "dev": {
        "url": "http://dev.assistant.llm.skhynix.com/v1/chat/completions",
        "model": "Qwen3-Coder-30B-A3B-Instruct",
        "name": "개발(30B)"
    },
    "prod": {
        "url": "http://summary.llm.skhynix.com/v1/chat/completions",
        "model": "Qwen3-Next-80B-A3B-Instruct",
        "name": "운영(80B)"
    }
}

API_STATUS = {"available": False, "message": "", "env": "dev"}


# =========================================================
# API 토큰 로드
# =========================================================
def load_api_token():
    """token.txt에서 API 토큰 로드"""
    global API_TOKEN, API_STATUS
    
    token_paths = ["token.txt", "./token.txt", "../token.txt"]
    
    for path in token_paths:
        if os.path.exists(path):
            try:
                with open(path, "r", encoding="utf-8") as f:
                    token = f.read().strip()
                    if token and not token.startswith("#"):
                        API_TOKEN = token
                        API_STATUS = {
                            "available": True,
                            "message": f"토큰 로드 완료 ({path})",
                            "env": ENV_MODE
                        }
                        logger.info(f"✅ token.txt 로드 완료: {path}")
                        return True
            except Exception as e:
                logger.warning(f"⚠️ token.txt 읽기 실패: {e}")
    
    API_STATUS = {"available": False, "message": "token.txt 없음", "env": ENV_MODE}
    return False


# =========================================================
# LLM API 호출
# =========================================================
def call_llm_api(prompt: str, system_prompt: str = "", max_tokens: int = 2000) -> str:
    """하이닉스 LLM API 호출"""
    global API_TOKEN, ENV_MODE
    
    if not API_TOKEN:
        return "ERROR: API 토큰이 없습니다. token.txt를 확인하세요."
    
    config = ENV_CONFIG[ENV_MODE]
    
    headers = {
        "Authorization": f"Bearer {API_TOKEN}",
        "Content-Type": "application/json"
    }
    
    messages = []
    if system_prompt:
        messages.append({"role": "system", "content": system_prompt})
    messages.append({"role": "user", "content": prompt})
    
    data = {
        "model": config["model"],
        "messages": messages,
        "max_tokens": max_tokens,
        "temperature": 0.1
    }
    
    try:
        response = requests.post(config["url"], headers=headers, json=data, timeout=120)
        
        if response.status_code == 200:
            result = response.json()
            content = result["choices"][0]["message"]["content"]
            
            # Qwen3 thinking 태그 제거
            content = re.sub(r'<think>.*?</think>', '', content, flags=re.DOTALL)
            content = re.sub(r'<think>.*', '', content, flags=re.DOTALL)
            
            return content.strip()
        else:
            logger.error(f"API error: {response.status_code} - {response.text}")
            return f"ERROR: API {response.status_code}"
            
    except requests.exceptions.Timeout:
        return "ERROR: API 타임아웃"
    except Exception as e:
        logger.error(f"API 호출 실패: {e}")
        return f"ERROR: {e}"


# =========================================================
# ToolSpec 정의
# =========================================================
@dataclass
class ToolSpec:
    tool_name: str
    tool_type: str
    purpose: str
    required_inputs: Dict[str, str]
    optional_inputs: Dict[str, str]
    outputs: Dict[str, str]
    preconditions: List[str]
    forbidden: List[str]
    failure_modes: List[str]


def tool_to_desc_text(t: ToolSpec) -> str:
    return "\n".join([
        f"[TOOL] {t.tool_name}",
        f"Type: {t.tool_type}",
        f"Purpose: {t.purpose}",
        f"Required Inputs: {json.dumps(t.required_inputs, ensure_ascii=False)}",
        f"Optional Inputs: {json.dumps(t.optional_inputs, ensure_ascii=False)}",
        f"Outputs: {json.dumps(t.outputs, ensure_ascii=False)}",
        f"Preconditions: {t.preconditions}",
        f"Forbidden: {t.forbidden}",
        f"Failure Modes: {t.failure_modes}",
    ])


def sha256_of_registry(registry: List[ToolSpec]) -> str:
    raw = json.dumps([asdict(t) for t in registry], ensure_ascii=False, sort_keys=True).encode("utf-8")
    return hashlib.sha256(raw).hexdigest()


# =========================================================
# Pydantic Models
# =========================================================
class BuildRequest(BaseModel):
    tools: Optional[List[dict]] = None


class TestQueryRequest(BaseModel):
    query: str
    k: int = 4
    max_iters: int = 3
    fab_list: List[str] = ["M12", "M14", "M16"]


class EnvSwitchRequest(BaseModel):
    env: str  # "dev" or "prod"


# =========================================================
# 유틸리티 함수
# =========================================================
def extract_json_object(text: str) -> str:
    if not text:
        return ""
    t = text.strip()
    if t.startswith("```"):
        t = t.strip().strip("`").strip()
        lines = t.splitlines()
        if lines and lines[0].strip().lower().startswith("json"):
            t = "\n".join(lines[1:]).strip()
    s = t.find("{")
    e = t.rfind("}")
    if s == -1 or e == -1 or e <= s:
        return ""
    return t[s:e + 1]


def load_tool_registry_from_file(path: str) -> Dict[str, ToolSpec]:
    with open(path, "r", encoding="utf-8") as f:
        raw = json.load(f)
    specs = {}
    for t in raw:
        specs[t["tool_name"]] = ToolSpec(**t)
    return specs


# =========================================================
# 기본 Tool Registry
# =========================================================
DEFAULT_REGISTRY = [
    ToolSpec(
        tool_name="id_extract_tool",
        tool_type="llm_tool",
        purpose="사용자 질의에서 carrier_id 또는 lot_id 후보를 추출/정규화한다.",
        required_inputs={"query": "string", "fab_list": "list[string]"},
        optional_inputs={},
        outputs={"carrier_id": "string?", "lot_id": "string?", "raw_token": "string?", "confidence": "float"},
        preconditions=[],
        forbidden=[],
        failure_modes=["NO_ID_FOUND", "AMBIGUOUS_ID"]
    ),
    ToolSpec(
        tool_name="fab_extract_tool",
        tool_type="llm_tool",
        purpose="사용자 질의에서 fab 코드를 추출한다(fab_list 기준).",
        required_inputs={"query": "string", "fab_list": "list[string]"},
        optional_inputs={},
        outputs={"fab": "string?", "confidence": "float"},
        preconditions=[],
        forbidden=[],
        failure_modes=["NO_FAB_FOUND", "AMBIGUOUS_FAB"]
    ),
    ToolSpec(
        tool_name="mcs_db_search_tool",
        tool_type="runtime_tool",
        purpose="carrier_id 또는 lot_id로 현재 위치(fab/eqp/port)를 조회한다.",
        required_inputs={"carrier_id": "string?", "lot_id": "string?"},
        optional_inputs={"timestamp": "string?"},
        outputs={"fab": "string", "eqp": "string", "port": "string", "datetime": "string"},
        preconditions=["requires:carrier_id_or_lot_id"],
        forbidden=["do_not_run_without:carrier_id_or_lot_id"],
        failure_modes=["ID_NOT_FOUND", "MULTIPLE_MATCH"]
    ),
    ToolSpec(
        tool_name="star_db_search_tool",
        tool_type="runtime_tool",
        purpose="fab 기반으로 반송(리턴/셔틀) 현황을 조회한다.",
        required_inputs={"fab": "string"},
        optional_inputs={"time_window": "string?"},
        outputs={"fab": "string", "return_status": "string", "queue": "int", "avg_queue": "int", "updated_at": "string"},
        preconditions=["requires:fab"],
        forbidden=["do_not_run_without:fab"],
        failure_modes=["FAB_NOT_FOUND", "DB_TIMEOUT"]
    ),
]


# =========================================================
# Tool Retriever (TF-IDF 기반)
# =========================================================
class ToolRetrieverTFIDF:
    def __init__(self, tool_names: List[str], tool_texts: List[str]):
        from sklearn.feature_extraction.text import TfidfVectorizer
        from sklearn.metrics.pairwise import cosine_similarity
        
        self.tool_names = tool_names
        self.tool_texts = tool_texts
        self.vectorizer = TfidfVectorizer()
        self.tool_vectors = self.vectorizer.fit_transform(tool_texts)
        self._cosine_similarity = cosine_similarity
    
    def retrieve_with_scores(self, query: str, k: int = 4) -> List[Tuple[str, float]]:
        query_vec = self.vectorizer.transform([query])
        sims = self._cosine_similarity(query_vec, self.tool_vectors)[0]
        indices = sims.argsort()[::-1][:k]
        return [(self.tool_names[i], float(sims[i])) for i in indices]


# =========================================================
# Static Validator
# =========================================================
def _parse_requires_key(s: str) -> Optional[str]:
    if s.startswith("requires:"):
        return s.split("requires:", 1)[1].strip()
    return None


def _parse_do_not_run_without_key(s: str) -> Optional[str]:
    if s.startswith("do_not_run_without:"):
        return s.split("do_not_run_without:", 1)[1].strip()
    return None


def _is_present(v: Any) -> bool:
    if v is None:
        return False
    if isinstance(v, str) and v.strip() == "":
        return False
    if isinstance(v, (list, dict)) and len(v) == 0:
        return False
    return True


def _has_any(keys: Iterable[str], args: Dict[str, Any], produced_keys: Set[str], runtime_fillable: Set[str]) -> bool:
    for k in keys:
        if _is_present(args.get(k)) or (k in produced_keys) or (k in runtime_fillable):
            return True
    return False


def static_validate_plan(plan_dict: dict, specs: Dict[str, ToolSpec]) -> dict:
    runtime_fillable = {"query", "fab_list", "timestamp", "time_window", "normalized_query", "fabs", "id_candidates"}
    nullable_inputs = {"carrier_id", "lot_id"}
    
    errors = []
    steps = plan_dict.get("steps", [])
    
    for i, step in enumerate(steps, start=1):
        tool_name = step.get("tool", "")
        if tool_name not in specs:
            errors.append(f"STEP{i}: UNKNOWN_TOOL '{tool_name}'")
    
    if errors:
        return {"ok": False, "errors": errors, "suggested_fix": "Plan에 registry에 없는 tool이 포함되어 있습니다."}
    
    produced_keys: Set[str] = set()
    
    for i, step in enumerate(steps, start=1):
        tool_name = step.get("tool", "")
        spec = specs[tool_name]
        args = step.get("args", {}) or {}
        
        for pc in (spec.preconditions or []):
            key = _parse_requires_key(pc)
            if not key:
                continue
            if key == "carrier_id_or_lot_id":
                if not _has_any(["carrier_id", "lot_id"], args, produced_keys, runtime_fillable):
                    errors.append(f"STEP{i}: PRECONDITION '{pc}' not satisfied for '{tool_name}'")
            else:
                if not _has_any([key], args, produced_keys, runtime_fillable):
                    errors.append(f"STEP{i}: PRECONDITION '{pc}' not satisfied for '{tool_name}'")
        
        for fb in (spec.forbidden or []):
            key = _parse_do_not_run_without_key(fb)
            if not key:
                continue
            if key == "carrier_id_or_lot_id":
                if not _has_any(["carrier_id", "lot_id"], args, produced_keys, runtime_fillable):
                    errors.append(f"STEP{i}: FORBIDDEN '{fb}' violated for '{tool_name}'")
            else:
                if not _has_any([key], args, produced_keys, runtime_fillable):
                    errors.append(f"STEP{i}: FORBIDDEN '{fb}' violated for '{tool_name}'")
        
        for req_key in (spec.required_inputs or {}).keys():
            if req_key in runtime_fillable or req_key in nullable_inputs:
                continue
            if not _has_any([req_key], args, produced_keys, runtime_fillable):
                errors.append(f"STEP{i}: REQUIRED_INPUT '{req_key}' missing for '{tool_name}'")
        
        for out_key in (spec.outputs or {}).keys():
            produced_keys.add(out_key)
    
    ok = len(errors) == 0
    suggested_fix = "" if ok else "정적(I/O) 검증 실패: Plan을 '실행 가능'하게 수정하세요."
    
    return {"ok": ok, "errors": errors, "suggested_fix": suggested_fix}


# =========================================================
# 서버 시작
# =========================================================
@app.on_event("startup")
async def startup():
    global tool_specs, retriever
    
    os.makedirs(ARTIFACTS_DIR, exist_ok=True)
    
    # API 토큰 로드
    load_api_token()
    
    # 기존 아티팩트 로드
    registry_path = os.path.join(ARTIFACTS_DIR, "tool_registry.json")
    index_path = os.path.join(ARTIFACTS_DIR, "tool_index.json")
    
    if os.path.exists(registry_path):
        try:
            tool_specs = load_tool_registry_from_file(registry_path)
            logger.info(f"✅ Tool Registry 로드 완료: {len(tool_specs)} tools")
        except Exception as e:
            logger.warning(f"⚠️ Tool Registry 로드 실패: {e}")
    
    if os.path.exists(index_path):
        try:
            with open(index_path, "r", encoding="utf-8") as f:
                idx_data = json.load(f)
            retriever = ToolRetrieverTFIDF(idx_data["tool_names"], idx_data["tool_texts"])
            logger.info("✅ Tool Index 로드 완료")
        except Exception as e:
            logger.warning(f"⚠️ Tool Index 로드 실패: {e}")


# =========================================================
# API 엔드포인트
# =========================================================
@app.get("/")
async def home():
    return FileResponse("tool_planner_ui.html")


@app.get("/api/status")
async def get_status():
    global tool_specs, retriever, API_STATUS, ENV_MODE
    
    registry_path = os.path.join(ARTIFACTS_DIR, "tool_registry.json")
    index_path = os.path.join(ARTIFACTS_DIR, "tool_index.json")
    
    return {
        "api_available": API_STATUS["available"],
        "api_message": API_STATUS["message"],
        "env_mode": ENV_MODE,
        "env_name": ENV_CONFIG[ENV_MODE]["name"],
        "env_model": ENV_CONFIG[ENV_MODE]["model"],
        "registry_exists": os.path.exists(registry_path),
        "index_exists": os.path.exists(index_path),
        "tool_count": len(tool_specs),
        "retriever_ready": retriever is not None,
        "tools": list(tool_specs.keys()) if tool_specs else []
    }


@app.post("/api/switch_env")
async def switch_env(request: EnvSwitchRequest):
    """개발/운영 환경 전환"""
    global ENV_MODE, API_STATUS
    
    if request.env not in ["dev", "prod"]:
        raise HTTPException(status_code=400, detail="env는 'dev' 또는 'prod'여야 합니다.")
    
    ENV_MODE = request.env
    API_STATUS["env"] = ENV_MODE
    
    config = ENV_CONFIG[ENV_MODE]
    logger.info(f"✅ 환경 전환: {config['name']}")
    
    return {
        "success": True,
        "env": ENV_MODE,
        "name": config["name"],
        "model": config["model"]
    }


@app.post("/api/build")
async def build_artifacts(request: BuildRequest):
    """Tool Registry 및 Index 빌드"""
    global tool_specs, retriever
    
    try:
        if request.tools:
            registry = [ToolSpec(**t) for t in request.tools]
        else:
            registry = DEFAULT_REGISTRY
        
        registry_hash = sha256_of_registry(registry)
        tool_names = [t.tool_name for t in registry]
        tool_texts = [tool_to_desc_text(t) for t in registry]
        
        # Registry 저장
        registry_path = os.path.join(ARTIFACTS_DIR, "tool_registry.json")
        with open(registry_path, "w", encoding="utf-8") as f:
            json.dump([asdict(t) for t in registry], f, ensure_ascii=False, indent=2)
        
        # Index 저장
        index_path = os.path.join(ARTIFACTS_DIR, "tool_index.json")
        with open(index_path, "w", encoding="utf-8") as f:
            json.dump({
                "registry_hash": registry_hash,
                "tool_names": tool_names,
                "tool_texts": tool_texts,
            }, f, ensure_ascii=False, indent=2)
        
        # 전역 변수 업데이트
        tool_specs = {t.tool_name: t for t in registry}
        retriever = ToolRetrieverTFIDF(tool_names, tool_texts)
        
        logger.info(f"✅ 빌드 완료: {len(registry)} tools")
        
        return {
            "success": True,
            "message": f"빌드 완료: {len(registry)} tools",
            "registry_hash": registry_hash,
            "tools": tool_names
        }
        
    except Exception as e:
        logger.error(f"빌드 실패: {e}")
        import traceback
        logger.error(traceback.format_exc())
        raise HTTPException(status_code=500, detail=str(e))


@app.post("/api/test")
async def test_query(request: TestQueryRequest):
    """Tool Planner 테스트"""
    global tool_specs, retriever, API_STATUS
    
    if not retriever:
        raise HTTPException(status_code=400, detail="먼저 빌드를 실행하세요")
    
    if not API_STATUS["available"]:
        raise HTTPException(status_code=400, detail="token.txt가 없습니다. API 토큰을 설정하세요.")
    
    try:
        feedbacks = []
        trace = []
        
        # 1) ReQuery
        requery_system = """너는 Re-Query 정규화기다.
할 일:
1) 입력 문장의 오타/비문을 자연스럽게 고치고 핵심 질문으로 요약한다.
2) fab_list(공식 fab 코드 목록)에 해당한다고 '확신'하면, 그 fab 코드를 fabs 리스트에 넣고, normalized_query에는 fab 코드를 반영한다. (예: '14번 공장' -> 'M14')
3) fab_list에 매핑할 수 없으면(예: ABC123), 억지로 fab로 바꾸지 말고 원문 의미를 유지한다.
4) carrier/lot 등 ID로 보이는 토큰이 있으면 id_candidates에 넣는다(복수 가능).
출력은 순수 JSON만. 코드블록/설명 금지.
스키마:
{
  "normalized_query": "...",
  "fabs": ["M14"],
  "id_candidates": ["ABC123"],
  "notes": "..."
}"""
        
        requery_user = f"""[INPUT QUERY]
{request.query}

[fab_list]
{request.fab_list}

Return JSON only."""
        
        requery_raw = call_llm_api(requery_user, requery_system, max_tokens=500)
        requery_json = extract_json_object(requery_raw)
        
        if requery_json:
            try:
                requery_result = json.loads(requery_json)
            except:
                requery_result = {"normalized_query": request.query, "fabs": [], "id_candidates": [], "notes": "PARSE_FAIL"}
        else:
            requery_result = {"normalized_query": request.query, "fabs": [], "id_candidates": [], "notes": "NO_JSON"}
        
        fabs = [x for x in requery_result.get("fabs", []) if x in request.fab_list]
        normalized_query = requery_result.get("normalized_query", request.query)
        id_candidates = requery_result.get("id_candidates", [])
        
        # 2) Retrieval
        retrieved_scores = retriever.retrieve_with_scores(normalized_query, k=request.k)
        retrieved_tools = [name for name, _ in retrieved_scores]
        
        # 3) Planning Loop
        for it in range(1, request.max_iters + 1):
            # Tool context 생성
            ctx = []
            for name in retrieved_tools:
                spec = tool_specs.get(name)
                if not spec:
                    continue
                ctx.append("\n".join([
                    f"[TOOL] {spec.tool_name}",
                    f"Type: {spec.tool_type}",
                    f"Purpose: {spec.purpose}",
                    f"Required Inputs: {json.dumps(spec.required_inputs, ensure_ascii=False)}",
                    f"Optional Inputs: {json.dumps(spec.optional_inputs, ensure_ascii=False)}",
                    f"Outputs: {json.dumps(spec.outputs, ensure_ascii=False)}",
                    f"Preconditions: {spec.preconditions}",
                    f"Forbidden: {spec.forbidden}",
                    f"Failure Modes: {spec.failure_modes}",
                ]))
            tool_context = "\n\n".join(ctx)
            
            feedback_block = ""
            if feedbacks:
                feedback_block = "\n\n[FEEDBACK]\n" + "\n".join(f"- {x}" for x in feedbacks[-3:])
            
            plan_system = """너는 Tool Planner다. 사용자 질의에 답하기 위해 tool 실행 계획(순서 포함)을 만든다.
출력 규칙(매우 중요):
1) 출력은 순수 JSON만. 코드블록/설명 금지.
2) 최상위 키는 steps, can_answer_after 두 개만.
3) steps의 각 step은 tool, args, expects 키만.
4) expects는 list[str].
5) args에는 placeholder(예: {{...}})를 넣지 말 것. 이전 step 결과가 필요하면 args에서 생략해라(실행기에서 자동 주입한다)."""
            
            plan_user = f"""[ORIGINAL QUERY]
{request.query}

[NORMALIZED QUERY]
{normalized_query}{feedback_block}

[REQUERY ENTITIES]
- fabs: {fabs}
- id_candidates: {id_candidates}

[AVAILABLE TOOLS]
{tool_context}

[CONTEXT]
- fab_list: {request.fab_list}

Return Plan JSON only."""
            
            try:
                plan_raw = call_llm_api(plan_user, plan_system, max_tokens=1000)
                plan_json = extract_json_object(plan_raw)
                
                if not plan_json:
                    raise ValueError("No JSON object found in planner output")
                
                plan_dict = json.loads(plan_json)
                validation = static_validate_plan(plan_dict, tool_specs)
                
                trace.append({
                    "iter": it,
                    "requery": {
                        "normalized_query": normalized_query,
                        "fabs": fabs,
                        "id_candidates": id_candidates,
                        "notes": requery_result.get("notes", "")
                    },
                    "retrieved_scores": [[name, score] for name, score in retrieved_scores],
                    "plan": plan_dict,
                    "static_validation": validation,
                    "feedbacks": list(feedbacks)
                })
                
                if validation["ok"]:
                    break
                
                feedbacks.append("STATIC_VALIDATION_FAIL:\n" + "\n".join(validation["errors"]))
                if validation.get("suggested_fix"):
                    feedbacks.append(validation["suggested_fix"])
                    
            except Exception as e:
                trace.append({
                    "iter": it,
                    "requery": {
                        "normalized_query": normalized_query,
                        "fabs": fabs,
                        "id_candidates": id_candidates
                    },
                    "retrieved_scores": [[name, score] for name, score in retrieved_scores],
                    "plan": None,
                    "static_validation": {
                        "ok": False,
                        "errors": [f"PLANNER_FAILED: {e}"],
                        "suggested_fix": "Planner가 순수 JSON + steps/args/expects 스키마를 지키도록 조정하세요."
                    },
                    "feedbacks": list(feedbacks)
                })
                feedbacks.append(f"PLANNER_FAILED: {e}")
        
        final_ok = bool(trace and trace[-1]["static_validation"]["ok"])
        
        return {
            "success": True,
            "query": request.query,
            "final_ok": final_ok,
            "trace": trace
        }
        
    except Exception as e:
        logger.error(f"테스트 실패: {e}")
        import traceback
        logger.error(traceback.format_exc())
        raise HTTPException(status_code=500, detail=str(e))


@app.get("/api/registry")
async def get_registry():
    """현재 Tool Registry 반환"""
    registry_path = os.path.join(ARTIFACTS_DIR, "tool_registry.json")
    
    if not os.path.exists(registry_path):
        return {"tools": [], "message": "Registry가 없습니다. 먼저 빌드하세요."}
    
    with open(registry_path, "r", encoding="utf-8") as f:
        registry = json.load(f)
    
    return {"tools": registry}


@app.get("/api/default-registry")
async def get_default_registry():
    """기본 Tool Registry 반환"""
    return {"tools": [asdict(t) for t in DEFAULT_REGISTRY]}


if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="127.0.0.1", port=8080)