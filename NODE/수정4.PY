import sys
import json
import math
from typing import Dict, List, Optional, Tuple
from dataclasses import dataclass
from enum import Enum

from PyQt5.QtWidgets import *
from PyQt5.QtCore import *
from PyQt5.QtGui import *


class NodeType(Enum):
    DATA = "data"
    PREPROCESS = "preprocess"
    VECTOR = "vector"
    MODEL = "model"
    ANALYSIS = "analysis"


@dataclass
class NodeConfig:
    """ë…¸ë“œ ì„¤ì • ë°ì´í„° í´ë˜ìŠ¤"""
    node_type: NodeType
    name: str
    color: str
    inputs: int = 1
    outputs: int = 1


# ë…¸ë“œ íƒ€ì…ë³„ ì„¤ì •
NODE_CONFIGS = {
    NodeType.DATA: NodeConfig(NodeType.DATA, "ë°ì´í„° ì…ë ¥", "#3498db", 0, 1),
    NodeType.PREPROCESS: NodeConfig(NodeType.PREPROCESS, "ì „ì²˜ë¦¬", "#e74c3c", 1, 1),
    NodeType.VECTOR: NodeConfig(NodeType.VECTOR, "ë²¡í„° ì €ì¥", "#f39c12", 1, 1),
    NodeType.MODEL: NodeConfig(NodeType.MODEL, "ëª¨ë¸", "#27ae60", 1, 1),
    NodeType.ANALYSIS: NodeConfig(NodeType.ANALYSIS, "ë¶„ì„", "#9b59b6", 1, 1),
}


class Port(QGraphicsEllipseItem):
    """ë…¸ë“œì˜ ì…ì¶œë ¥ í¬íŠ¸"""
    def __init__(self, is_output=True, parent=None):
        super().__init__(-6, -6, 12, 12, parent)
        self.is_output = is_output
        self.connections = []
        self.node = parent
        
        # í¬íŠ¸ ìŠ¤íƒ€ì¼
        self.default_color = QColor("#00CED1") if is_output else QColor("#FFD700")
        self.hover_color = QColor("#00BFFF") if is_output else QColor("#FFA500")
        self.highlight_color = QColor("#FF6347")  # ìŠ¤ëƒ… í•˜ì´ë¼ì´íŠ¸ìš©
        
        self.setBrush(QBrush(self.default_color))
        self.setPen(QPen(QColor("#FFFFFF"), 2))
        self.setAcceptHoverEvents(True)
        self.setZValue(10)
        
    def hoverEnterEvent(self, event):
        self.setBrush(QBrush(self.hover_color))
        super().hoverEnterEvent(event)
        
    def hoverLeaveEvent(self, event):
        self.setBrush(QBrush(self.default_color))
        super().hoverLeaveEvent(event)
        
    def highlight(self, on=True):
        """ìŠ¤ëƒ… í•˜ì´ë¼ì´íŠ¸"""
        if on:
            self.setBrush(QBrush(self.highlight_color))
            self.setPen(QPen(QColor("#FFFFFF"), 3))
        else:
            self.setBrush(QBrush(self.default_color))
            self.setPen(QPen(QColor("#FFFFFF"), 2))
        
    def get_center(self):
        """í¬íŠ¸ ì¤‘ì‹¬ ì¢Œí‘œ ë°˜í™˜ (ì”¬ ì¢Œí‘œ)"""
        return self.scenePos() + self.rect().center()
        
    def can_connect_to(self, other_port):
        """ë‹¤ë¥¸ í¬íŠ¸ì™€ ì—°ê²° ê°€ëŠ¥í•œì§€ í™•ì¸"""
        if not other_port or other_port == self:
            return False
        if self.is_output == other_port.is_output:
            return False
        if self.node == other_port.node:
            return False
        # ì´ë¯¸ ì—°ê²°ë˜ì–´ ìˆëŠ”ì§€ í™•ì¸
        for conn in self.connections:
            if (conn.start_port == other_port or conn.end_port == other_port):
                return False
        return True


class Connection(QGraphicsPathItem):
    """ë…¸ë“œ ê°„ ì—°ê²°ì„ """
    def __init__(self, start_port=None, end_port=None):
        super().__init__()
        self.start_port = start_port
        self.end_port = end_port
        self.temp_end_pos = None
        
        # ì—°ê²°ì„  ìŠ¤íƒ€ì¼
        self.default_pen = QPen(QColor("#3498db"), 3)
        self.hover_pen = QPen(QColor("#5dade2"), 4)
        self.selected_pen = QPen(QColor("#e74c3c"), 4)
        
        # êº¾ì€ì„ ì„ ë¶€ë“œëŸ½ê²Œ ë³´ì´ë„ë¡ ì¡°ì¸ ìŠ¤íƒ€ì¼ ì„¤ì •
        self.default_pen.setCapStyle(Qt.RoundCap)
        self.default_pen.setJoinStyle(Qt.RoundJoin)
        self.hover_pen.setCapStyle(Qt.RoundCap)
        self.hover_pen.setJoinStyle(Qt.RoundJoin)
        self.selected_pen.setCapStyle(Qt.RoundCap)
        self.selected_pen.setJoinStyle(Qt.RoundJoin)
        
        self.setPen(self.default_pen)
        self.setZValue(-1)
        
        # ì„ íƒ ë° í˜¸ë²„ ê°€ëŠ¥
        self.setFlag(QGraphicsItem.ItemIsSelectable, True)
        self.setAcceptHoverEvents(True)
        
        # í™”ì‚´í‘œ
        self.arrow = QGraphicsPolygonItem()
        self.arrow.setBrush(QBrush(QColor("#3498db")))
        self.arrow.setPen(QPen(Qt.NoPen))
        self.arrow.setZValue(-1)
        
        if start_port and end_port:
            start_port.connections.append(self)
            end_port.connections.append(self)
            self.update_path()
            
    def hoverEnterEvent(self, event):
        """ë§ˆìš°ìŠ¤ í˜¸ë²„ ì‹œ"""
        if not self.isSelected():
            self.setPen(self.hover_pen)
            self.arrow.setBrush(QBrush(QColor("#5dade2")))
        super().hoverEnterEvent(event)
        
    def hoverLeaveEvent(self, event):
        """ë§ˆìš°ìŠ¤ í˜¸ë²„ í•´ì œ"""
        if not self.isSelected():
            self.setPen(self.default_pen)
            self.arrow.setBrush(QBrush(QColor("#3498db")))
        super().hoverLeaveEvent(event)
        
    def itemChange(self, change, value):
        """ì„ íƒ ìƒíƒœ ë³€ê²½"""
        if change == QGraphicsItem.ItemSelectedChange:
            if value:
                self.setPen(self.selected_pen)
                self.arrow.setBrush(QBrush(QColor("#e74c3c")))
            else:
                self.setPen(self.default_pen)
                self.arrow.setBrush(QBrush(QColor("#3498db")))
        return super().itemChange(change, value)
        
    def update_path(self, end_pos=None):
        """ì—°ê²°ì„  ê²½ë¡œ ì—…ë°ì´íŠ¸ (ë…¸ë“œ íšŒí”¼ ë¡œì§ í¬í•¨)"""
        if not self.start_port:
            return
            
        start = self.start_port.get_center()
        
        if end_pos:
            end = end_pos
        elif self.end_port:
            end = self.end_port.get_center()
        else:
            return
            
        # ìŠ¤ë§ˆíŠ¸ ê²½ë¡œ ê³„ì‚°
        path = self.calculate_smart_path(start, end)
        self.setPath(path)
        
        # í™”ì‚´í‘œ ì—…ë°ì´íŠ¸
        if self.end_port or end_pos:
            self.update_arrow(path)
            
    def calculate_smart_path(self, start, end):
        """ë…¸ë“œë¥¼ í”¼í•´ê°€ëŠ” ì§ê° ê²½ë¡œ ê³„ì‚°"""
        path = QPainterPath()
        path.moveTo(start)
        
        dx = end.x() - start.x()
        dy = end.y() - start.y()
        
        # ì˜¤í”„ì…‹ ê±°ë¦¬
        offset = 50
        
        # ê±°ë¦¬ê°€ ê°€ê¹Œìš°ë©´ ê·¸ëƒ¥ ì§ì„  ì—°ê²°
        distance = math.sqrt(dx * dx + dy * dy)
        if distance < 150:
            path.lineTo(end)
            return path
            
        # Case 1: ì •ë°©í–¥ ì—°ê²° (ì™¼ìª½ì—ì„œ ì˜¤ë¥¸ìª½ìœ¼ë¡œ)
        if dx > offset:
            # ì¤‘ê°„ ì§€ì ì—ì„œ êº¾ê¸°
            mid_x = start.x() + dx / 2
            path.lineTo(mid_x, start.y())
            path.lineTo(mid_x, end.y())
            path.lineTo(end)
            
        # Case 2: ì—­ë°©í–¥ ì—°ê²° (ì˜¤ë¥¸ìª½ì—ì„œ ì™¼ìª½ìœ¼ë¡œ)
        else:
            # Sì ì—°ê²°
            mid_y = (start.y() + end.y()) / 2
            path.lineTo(start.x() + offset, start.y())
            path.lineTo(start.x() + offset, mid_y)
            path.lineTo(end.x() - offset, mid_y)
            path.lineTo(end.x() - offset, end.y())
            path.lineTo(end)
        
        return path
        
    def update_arrow(self, path):
        """í™”ì‚´í‘œ ì—…ë°ì´íŠ¸"""
        if path.length() == 0:
            return
            
        # ê²½ë¡œì˜ ë§ˆì§€ë§‰ ì„ ë¶„ì—ì„œ ë°©í–¥ ê³„ì‚°
        # ëì ê³¼ ê·¸ ì§ì „ ì ì„ ì°¾ê¸°
        point_count = path.elementCount()
        if point_count < 2:
            return
            
        # ë§ˆì§€ë§‰ ë‘ ì  ê°€ì ¸ì˜¤ê¸°
        last_element = path.elementAt(point_count - 1)
        second_last_element = path.elementAt(point_count - 2)
        
        point2 = QPointF(last_element.x, last_element.y)
        point1 = QPointF(second_last_element.x, second_last_element.y)
        
        angle = math.atan2(point2.y() - point1.y(), point2.x() - point1.x())
        
        # í™”ì‚´í‘œ í´ë¦¬ê³¤
        arrow_length = 12
        arrow_angle = math.radians(25)
        
        p1 = point2
        p2 = point2 - QPointF(
            arrow_length * math.cos(angle - arrow_angle),
            arrow_length * math.sin(angle - arrow_angle)
        )
        p3 = point2 - QPointF(
            arrow_length * math.cos(angle + arrow_angle),
            arrow_length * math.sin(angle + arrow_angle)
        )
        
        self.arrow.setPolygon(QPolygonF([p1, p2, p3]))
        
        if self.arrow.scene() != self.scene():
            if self.scene():
                self.scene().addItem(self.arrow)
                
    def shape(self):
        """í´ë¦­ ì˜ì—­ì„ ë„“ê²Œ ì„¤ì •"""
        stroker = QPainterPathStroker()
        stroker.setWidth(20)
        return stroker.createStroke(self.path())
        
    def remove(self):
        """ì—°ê²° ì œê±°"""
        # í¬íŠ¸ì—ì„œ ì—°ê²° ì œê±°
        if self.start_port and self in self.start_port.connections:
            self.start_port.connections.remove(self)
        if self.end_port and self in self.end_port.connections:
            self.end_port.connections.remove(self)
            
        # ì”¬ì—ì„œ ì œê±°
        if self.scene():
            self.scene().removeItem(self.arrow)
            self.scene().removeItem(self)


class MemoItem(QGraphicsRectItem):
    """ë©”ëª¨ ì•„ì´í…œ í´ë˜ìŠ¤"""
    def __init__(self, x=0, y=0, width=250, height=150):
        super().__init__(0, 0, width, height)
        
        self.memo_id = id(self)
        self.setPos(x, y)
        
        # ë©”ëª¨ ìŠ¤íƒ€ì¼
        self.colors = [
            "#fffacd",  # ì—°í•œ ë…¸ë€ìƒ‰
            "#ffe4e1",  # ì—°í•œ ë¶„í™ìƒ‰
            "#e0ffff",  # ì—°í•œ í•˜ëŠ˜ìƒ‰
            "#f0fff0",  # ì—°í•œ ì´ˆë¡ìƒ‰
            "#f5f5dc",  # ë² ì´ì§€ìƒ‰
            "#fff0f5",  # ì—°í•œ ë³´ë¼ìƒ‰
        ]
        self.current_color_index = 0
        self.setColor(self.colors[0])
        
        # í”Œë˜ê·¸ ì„¤ì •
        self.setFlag(QGraphicsItem.ItemIsMovable, True)
        self.setFlag(QGraphicsItem.ItemIsSelectable, True)
        self.setFlag(QGraphicsItem.ItemSendsGeometryChanges, True)
        self.setAcceptHoverEvents(True)
        self.setZValue(-2)  # ë…¸ë“œë³´ë‹¤ ë’¤ì— í‘œì‹œ
        
        # í…ìŠ¤íŠ¸ ì•„ì´í…œ
        self.text_item = QGraphicsTextItem(self)
        self.text_item.setPlainText("ë©”ëª¨ë¥¼ ì…ë ¥í•˜ì„¸ìš”...")
        self.text_item.setDefaultTextColor(QColor("#333333"))
        self.text_item.setPos(10, 10)
        self.text_item.setTextWidth(width - 20)
        
        # ì œëª© ë°”
        self.title_height = 25
        self.is_editing = False
        
        # ë¦¬ì‚¬ì´ì¦ˆ í•¸ë“¤
        self.resize_handle_size = 10
        self.is_resizing = False
        self.resize_start_pos = None
        self.resize_start_rect = None
        
        # ê·¸ë¦¼ì íš¨ê³¼
        shadow = QGraphicsDropShadowEffect()
        shadow.setOffset(2, 2)
        shadow.setBlurRadius(5)
        shadow.setColor(QColor(0, 0, 0, 50))
        self.setGraphicsEffect(shadow)
        
    def setColor(self, color):
        """ë©”ëª¨ ìƒ‰ìƒ ì„¤ì •"""
        self.setBrush(QBrush(QColor(color)))
        self.setPen(QPen(QColor(color).darker(120), 2))
        
    def paint(self, painter, option, widget):
        """ë©”ëª¨ ê·¸ë¦¬ê¸°"""
        super().paint(painter, option, widget)
        
        # ì œëª© ë°” ê·¸ë¦¬ê¸°
        title_rect = QRectF(0, 0, self.rect().width(), self.title_height)
        painter.fillRect(title_rect, QBrush(QColor(0, 0, 0, 30)))
        
        # ì œëª© í…ìŠ¤íŠ¸
        painter.setPen(QPen(QColor("#555555")))
        painter.setFont(QFont("Arial", 9))
        painter.drawText(title_rect.adjusted(10, 0, -40, 0),
                        Qt.AlignVCenter, "ë©”ëª¨")
        
        # ë‹«ê¸° ë²„íŠ¼ ì˜ì—­
        close_rect = QRectF(self.rect().width() - 25, 5, 15, 15)
        painter.drawText(close_rect, Qt.AlignCenter, "Ã—")
        
        # ìƒ‰ìƒ ë³€ê²½ ë²„íŠ¼ ì˜ì—­
        color_rect = QRectF(self.rect().width() - 45, 5, 15, 15)
        painter.fillRect(color_rect, QBrush(QColor(self.colors[(self.current_color_index + 1) % len(self.colors)])))
        painter.drawRect(color_rect)
        
        # ë¦¬ì‚¬ì´ì¦ˆ í•¸ë“¤
        if self.isSelected():
            handle_rect = QRectF(
                self.rect().width() - self.resize_handle_size,
                self.rect().height() - self.resize_handle_size,
                self.resize_handle_size,
                self.resize_handle_size
            )
            # ë” ëˆˆì— ë„ëŠ” ë¦¬ì‚¬ì´ì¦ˆ í•¸ë“¤
            painter.fillRect(handle_rect, QBrush(QColor("#3498db")))
            painter.setPen(QPen(QColor("#2980b9"), 1))
            painter.drawRect(handle_rect)
            
            # ë¦¬ì‚¬ì´ì¦ˆ ì•„ì´ì½˜ ê·¸ë¦¬ê¸° (ì„¸ ê°œì˜ ëŒ€ê°ì„ )
            painter.setPen(QPen(QColor("#ffffff"), 1))
            for i in range(3):
                offset = i * 3
                painter.drawLine(
                    handle_rect.right() - offset - 2,
                    handle_rect.bottom() - 1,
                    handle_rect.right() - 1,
                    handle_rect.bottom() - offset - 2
                )
            painter.fillRect(handle_rect, QBrush(QColor("#666666")))
            
    def mousePressEvent(self, event):
        """ë§ˆìš°ìŠ¤ í´ë¦­ ì´ë²¤íŠ¸"""
        pos = event.pos()
        
        # ë‹«ê¸° ë²„íŠ¼ í´ë¦­
        close_rect = QRectF(self.rect().width() - 25, 5, 15, 15)
        if close_rect.contains(pos):
            self.delete_self()
            return
            
        # ìƒ‰ìƒ ë³€ê²½ ë²„íŠ¼ í´ë¦­
        color_rect = QRectF(self.rect().width() - 45, 5, 15, 15)
        if color_rect.contains(pos):
            self.change_color()
            return
            
        # ë¦¬ì‚¬ì´ì¦ˆ í•¸ë“¤ í´ë¦­
        handle_rect = QRectF(
            self.rect().width() - self.resize_handle_size,
            self.rect().height() - self.resize_handle_size,
            self.resize_handle_size,
            self.resize_handle_size
        )
        if handle_rect.contains(pos) and self.isSelected():
            self.is_resizing = True
            self.resize_start_pos = event.scenePos()
            self.resize_start_rect = self.rect()
            event.accept()
            return
            
        super().mousePressEvent(event)
        
    def mouseMoveEvent(self, event):
        """ë§ˆìš°ìŠ¤ ì´ë™ ì´ë²¤íŠ¸"""
        if self.is_resizing:
            # ë¦¬ì‚¬ì´ì¦ˆ ì²˜ë¦¬
            diff = event.scenePos() - self.resize_start_pos
            new_width = max(150, self.resize_start_rect.width() + diff.x())
            new_height = max(100, self.resize_start_rect.height() + diff.y())
            
            self.setRect(0, 0, new_width, new_height)
            self.text_item.setTextWidth(new_width - 20)
            self.update()
        else:
            super().mouseMoveEvent(event)
            
    def mouseReleaseEvent(self, event):
        """ë§ˆìš°ìŠ¤ ë¦´ë¦¬ì¦ˆ ì´ë²¤íŠ¸"""
        self.is_resizing = False
        super().mouseReleaseEvent(event)
        
    def mouseDoubleClickEvent(self, event):
        """ë”ë¸”í´ë¦­ìœ¼ë¡œ í¸ì§‘ ëª¨ë“œ"""
        self.edit_text()
        
    def hoverEnterEvent(self, event):
        """ë§ˆìš°ìŠ¤ í˜¸ë²„ ì‹œ"""
        self.setCursor(Qt.PointingHandCursor)
        super().hoverEnterEvent(event)
        
    def hoverMoveEvent(self, event):
        """í˜¸ë²„ ì¤‘ ë§ˆìš°ìŠ¤ ì´ë™"""
        pos = event.pos()
        
        # ë¦¬ì‚¬ì´ì¦ˆ í•¸ë“¤ ìœ„ì—ì„œ ì»¤ì„œ ë³€ê²½
        handle_rect = QRectF(
            self.rect().width() - self.resize_handle_size,
            self.rect().height() - self.resize_handle_size,
            self.resize_handle_size,
            self.resize_handle_size
        )
        if handle_rect.contains(pos) and self.isSelected():
            self.setCursor(Qt.SizeFDiagCursor)
        else:
            self.setCursor(Qt.PointingHandCursor)
            
    def edit_text(self):
        """í…ìŠ¤íŠ¸ í¸ì§‘"""
        dialog = QDialog()
        dialog.setWindowTitle("ë©”ëª¨ í¸ì§‘")
        dialog.setModal(True)
        layout = QVBoxLayout()
        
        # í…ìŠ¤íŠ¸ í¸ì§‘ê¸°
        text_edit = QTextEdit()
        text_edit.setPlainText(self.text_item.toPlainText())
        text_edit.setMinimumSize(400, 300)
        layout.addWidget(text_edit)
        
        # ë²„íŠ¼
        buttons = QDialogButtonBox(QDialogButtonBox.Ok | QDialogButtonBox.Cancel)
        buttons.accepted.connect(dialog.accept)
        buttons.rejected.connect(dialog.reject)
        layout.addWidget(buttons)
        
        dialog.setLayout(layout)
        
        if dialog.exec_() == QDialog.Accepted:
            self.text_item.setPlainText(text_edit.toPlainText())
            
    def change_color(self):
        """ìƒ‰ìƒ ë³€ê²½"""
        self.current_color_index = (self.current_color_index + 1) % len(self.colors)
        self.setColor(self.colors[self.current_color_index])
        self.update()
        
    def delete_self(self):
        """ìì‹ ì„ ì‚­ì œ"""
        if hasattr(self.scene(), 'main_window') and self.scene().main_window:
            reply = QMessageBox.question(None, "í™•ì¸",
                                       "ì´ ë©”ëª¨ë¥¼ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?",
                                       QMessageBox.Yes | QMessageBox.No)
            if reply == QMessageBox.Yes:
                self.scene().removeItem(self)
                self.scene().main_window.log("ë©”ëª¨ê°€ ì‚­ì œë˜ì—ˆìŠµë‹ˆë‹¤")
                
    def get_data(self):
        """ë©”ëª¨ ë°ì´í„° ë°˜í™˜ (ì €ì¥ìš©)"""
        return {
            "id": self.memo_id,
            "x": self.x(),
            "y": self.y(),
            "width": self.rect().width(),
            "height": self.rect().height(),
            "text": self.text_item.toPlainText(),
            "color_index": self.current_color_index
        }
        
    def set_data(self, data):
        """ë©”ëª¨ ë°ì´í„° ì„¤ì • (ë¶ˆëŸ¬ì˜¤ê¸°ìš©)"""
        self.setPos(data["x"], data["y"])
        self.setRect(0, 0, data["width"], data["height"])
        self.text_item.setPlainText(data["text"])
        self.text_item.setTextWidth(data["width"] - 20)
        self.current_color_index = data.get("color_index", 0)
        self.setColor(self.colors[self.current_color_index])


class Node(QGraphicsRectItem):
    """ë…¸ë“œ í´ë˜ìŠ¤"""
    def __init__(self, node_type: NodeType, name: str, x=0, y=0):
        super().__init__(0, 0, 200, 100)
        
        self.node_id = id(self)
        self.node_type = node_type
        self.name = name
        self.config = NODE_CONFIGS[node_type]
        self.is_configured = False
        self.settings = {}
        
        # ë…¸ë“œ ìŠ¤íƒ€ì¼
        self.setPos(x, y)
        self.setBrush(QBrush(QColor(self.config.color)))
        self.setPen(QPen(QColor("#FFFFFF"), 2))
        self.setFlag(QGraphicsItem.ItemIsMovable, True)
        self.setFlag(QGraphicsItem.ItemIsSelectable, True)
        self.setFlag(QGraphicsItem.ItemSendsGeometryChanges, True)
        self.setCursor(Qt.PointingHandCursor)
        self.setAcceptHoverEvents(True)
        self.setZValue(1)
        
        # ê·¸ë¦¼ì íš¨ê³¼
        shadow = QGraphicsDropShadowEffect()
        shadow.setOffset(3, 3)
        shadow.setBlurRadius(10)
        shadow.setColor(QColor(0, 0, 0, 100))
        self.setGraphicsEffect(shadow)
        
        # í…ìŠ¤íŠ¸ ë ˆì´ë¸”
        self.title_text = QGraphicsTextItem(self.name, self)
        self.title_text.setDefaultTextColor(Qt.white)
        font = QFont("Arial", 11, QFont.Bold)
        self.title_text.setFont(font)
        self.title_text.setPos(10, 5)
        
        self.type_text = QGraphicsTextItem(f"[{node_type.value}]", self)
        self.type_text.setDefaultTextColor(QColor("#ecf0f1"))
        self.type_text.setFont(QFont("Arial", 9))
        self.type_text.setPos(10, 30)
        
        # ìƒíƒœ í‘œì‹œ
        self.status_indicator = QGraphicsEllipseItem(170, 10, 20, 20, self)
        self.update_status()
        
        # í¬íŠ¸ ìƒì„±
        self.input_ports = []
        self.output_ports = []
        self.create_ports()
        
    def create_ports(self):
        """ì…ì¶œë ¥ í¬íŠ¸ ìƒì„±"""
        # ì…ë ¥ í¬íŠ¸
        for i in range(self.config.inputs):
            y_pos = 50 + (i * 30) if self.config.inputs > 1 else 50
            port = Port(is_output=False, parent=self)
            port.setPos(0, y_pos)
            self.input_ports.append(port)
            
        # ì¶œë ¥ í¬íŠ¸
        for i in range(self.config.outputs):
            y_pos = 50 + (i * 30) if self.config.outputs > 1 else 50
            port = Port(is_output=True, parent=self)
            port.setPos(200, y_pos)
            self.output_ports.append(port)
            
    def update_status(self):
        """ìƒíƒœ í‘œì‹œ ì—…ë°ì´íŠ¸"""
        color = QColor("#27ae60") if self.is_configured else QColor("#e74c3c")
        self.status_indicator.setBrush(QBrush(color))
        self.status_indicator.setPen(QPen(Qt.white, 2))
        
    def hoverEnterEvent(self, event):
        """ë§ˆìš°ìŠ¤ í˜¸ë²„ ì‹œ í•˜ì´ë¼ì´íŠ¸"""
        self.setPen(QPen(QColor("#FFD700"), 3))
        super().hoverEnterEvent(event)
        
    def hoverLeaveEvent(self, event):
        """ë§ˆìš°ìŠ¤ í˜¸ë²„ í•´ì œ"""
        self.setPen(QPen(QColor("#FFFFFF"), 2))
        super().hoverLeaveEvent(event)
        
    def itemChange(self, change, value):
        """ì•„ì´í…œ ë³€ê²½ ì‹œ ì—°ê²°ì„  ì—…ë°ì´íŠ¸"""
        if change == QGraphicsItem.ItemPositionHasChanged:
            # ì—°ê²°ëœ ëª¨ë“  ì—°ê²°ì„  ì—…ë°ì´íŠ¸
            for port in self.input_ports + self.output_ports:
                for connection in port.connections:
                    connection.update_path()
                    
        return super().itemChange(change, value)
        
    def mouseDoubleClickEvent(self, event):
        """ë”ë¸”í´ë¦­ ì‹œ ì„¤ì • ì°½ ì—´ê¸°"""
        if hasattr(self.scene(), 'main_window') and self.scene().main_window:
            self.scene().main_window.configure_node(self)
        super().mouseDoubleClickEvent(event)
        
    def contextMenuEvent(self, event):
        """ë§ˆìš°ìŠ¤ ì˜¤ë¥¸ìª½ í´ë¦­ ì»¨í…ìŠ¤íŠ¸ ë©”ë‰´"""
        menu = QMenu()
        
        # ëª¨ë“  ë…¸ë“œì— ê³µí†µìœ¼ë¡œ ì ìš©ë˜ëŠ” ë©”ë‰´
        configure_action = QAction("âš™ï¸ ë…¸ë“œ ì„¤ì •", None)
        configure_action.triggered.connect(lambda: self.scene().main_window.configure_node(self) if hasattr(self.scene(), 'main_window') and self.scene().main_window else None)
        menu.addAction(configure_action)
        
        # ë°ì´í„° ë…¸ë“œ ì „ìš© ë©”ë‰´
        if self.node_type == NodeType.DATA:
            if self.is_configured and 'path' in self.settings:
                open_file_action = QAction("ğŸ“ íŒŒì¼ ìœ„ì¹˜ ì—´ê¸°", None)
                open_file_action.triggered.connect(lambda: self.open_file_location())
                menu.addAction(open_file_action)
        
        # ëª¨ë¸ ë…¸ë“œ ì „ìš© ë©”ë‰´
        elif self.node_type == NodeType.MODEL:
            if self.is_configured:
                show_params_action = QAction("ğŸ“Š ëª¨ë¸ íŒŒë¼ë¯¸í„° ë³´ê¸°", None)
                show_params_action.triggered.connect(lambda: self.show_model_params())
                menu.addAction(show_params_action)
        
        menu.addSeparator()
        
        # ë…¸ë“œ ë³µì œ
        duplicate_action = QAction("ğŸ“‘ ë…¸ë“œ ë³µì œ", None)
        duplicate_action.triggered.connect(lambda: self.duplicate_node())
        menu.addAction(duplicate_action)
        
        # ë…¸ë“œ ì‚­ì œ
        delete_action = QAction("ğŸ—‘ï¸ ë…¸ë“œ ì‚­ì œ", None)
        delete_action.triggered.connect(lambda: self.delete_self())
        menu.addAction(delete_action)
        
        # ë©”ë‰´ í‘œì‹œ
        menu.exec_(event.screenPos())
            
    def open_file_location(self):
        """íŒŒì¼ ìœ„ì¹˜ ì—´ê¸°"""
        if 'path' in self.settings:
            import os
            path = self.settings['path']
            if os.path.exists(path):
                if os.path.isfile(path):
                    os.startfile(os.path.dirname(path))
                else:
                    os.startfile(path)
                    
    def show_model_params(self):
        """ëª¨ë¸ íŒŒë¼ë¯¸í„° í‘œì‹œ"""
        params = []
        for key, value in self.settings.items():
            params.append(f"{key}: {value}")
            
        msg = QMessageBox()
        msg.setWindowTitle(f"{self.name} íŒŒë¼ë¯¸í„°")
        msg.setText("í˜„ì¬ ì„¤ì •ëœ ëª¨ë¸ íŒŒë¼ë¯¸í„°:")
        msg.setDetailedText('\n'.join(params))
        msg.setIcon(QMessageBox.Information)
        msg.exec_()
        
    def duplicate_node(self):
        """ë…¸ë“œ ë³µì œ"""
        if hasattr(self.scene(), 'main_window') and self.scene().main_window:
            # ìƒˆ ë…¸ë“œ ìƒì„±
            new_node = Node(self.node_type, self.name, self.x() + 50, self.y() + 50)
            new_node.settings = self.settings.copy()
            new_node.is_configured = self.is_configured
            new_node.update_status()
            
            self.scene().addItem(new_node)
            self.scene().main_window.log(f"{self.name} ë…¸ë“œê°€ ë³µì œë˜ì—ˆìŠµë‹ˆë‹¤")
            
    def delete_self(self):
        """ìì‹ ì„ ì‚­ì œ"""
        if hasattr(self.scene(), 'main_window') and self.scene().main_window:
            reply = QMessageBox.question(None, "í™•ì¸",
                                       f"{self.name} ë…¸ë“œë¥¼ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?",
                                       QMessageBox.Yes | QMessageBox.No)
            if reply == QMessageBox.Yes:
                self.scene().main_window.view.delete_node(self)


class NodeScene(QGraphicsScene):
    """ë…¸ë“œ ì—ë””í„° ì”¬"""
    def __init__(self, parent=None):
        super().__init__(parent)
        self.main_window = parent  # ë©”ì¸ ìœˆë„ìš° ì°¸ì¡° ì €ì¥
        self.setSceneRect(-2000, -2000, 4000, 4000)
        
        # ë°°ê²½ ìƒ‰ìƒ
        self.setBackgroundBrush(QBrush(QColor("#2c3e50")))
        
        # ê·¸ë¦¬ë“œ
        self.grid_size = 20
        self.grid_visible = True
        
        # ì—°ê²° ê´€ë ¨
        self.current_connection = None
        self.start_port = None
        self.highlighted_port = None
        
    def drawBackground(self, painter, rect):
        """ë°°ê²½ ê·¸ë¦¬ê¸° (ê·¸ë¦¬ë“œ í¬í•¨)"""
        super().drawBackground(painter, rect)
        
        if not self.grid_visible:
            return
            
        # ê·¸ë¦¬ë“œ ê·¸ë¦¬ê¸°
        painter.setPen(QPen(QColor("#34495e"), 1, Qt.SolidLine))
        
        # ê·¸ë¦¬ë“œ ë²”ìœ„ ê³„ì‚°
        left = int(rect.left()) - (int(rect.left()) % self.grid_size)
        top = int(rect.top()) - (int(rect.top()) % self.grid_size)
        
        # ìˆ˜ì§ì„ 
        for x in range(left, int(rect.right()), self.grid_size):
            painter.drawLine(x, rect.top(), x, rect.bottom())
            
        # ìˆ˜í‰ì„ 
        for y in range(top, int(rect.bottom()), self.grid_size):
            painter.drawLine(rect.left(), y, rect.right(), y)
            
    def find_port_at(self, pos):
        """ì£¼ì–´ì§„ ìœ„ì¹˜ì˜ í¬íŠ¸ ì°¾ê¸°"""
        items = self.items(pos)
        for item in items:
            if isinstance(item, Port):
                return item
        return None
        
    def find_nearest_port(self, pos, port_type=None, max_distance=50):
        """ì£¼ì–´ì§„ ìœ„ì¹˜ì—ì„œ ê°€ì¥ ê°€ê¹Œìš´ í¬íŠ¸ ì°¾ê¸°"""
        nearest_port = None
        min_distance = max_distance
        
        for item in self.items():
            if isinstance(item, Port):
                # í¬íŠ¸ íƒ€ì… í•„í„°ë§
                if port_type is not None and item.is_output != (port_type == "output"):
                    continue
                    
                # í˜„ì¬ ì—°ê²° ì¤‘ì¸ í¬íŠ¸ì™€ ì—°ê²° ê°€ëŠ¥í•œì§€ í™•ì¸
                if self.start_port and not self.start_port.can_connect_to(item):
                    continue
                    
                port_center = item.get_center()
                distance = ((pos - port_center).x() ** 2 + (pos - port_center).y() ** 2) ** 0.5
                
                if distance < min_distance:
                    min_distance = distance
                    nearest_port = item
                    
        return nearest_port
        
    def mousePressEvent(self, event):
        """ë§ˆìš°ìŠ¤ í´ë¦­ ì´ë²¤íŠ¸"""
        # í´ë¦­í•œ ìœ„ì¹˜ì˜ ì•„ì´í…œ í™•ì¸
        items = self.items(event.scenePos())
        port = None
        
        # í¬íŠ¸ê°€ ìˆëŠ”ì§€ í™•ì¸
        for item in items:
            if isinstance(item, Port):
                port = item
                break
        
        if port and port.is_output:
            # ì¶œë ¥ í¬íŠ¸ì—ì„œ ì—°ê²° ì‹œì‘
            self.start_connection(port)
            event.accept()  # ì´ë²¤íŠ¸ ì²˜ë¦¬ ì™„ë£Œ
        elif port and not port.is_output and self.current_connection:
            # ì…ë ¥ í¬íŠ¸ì— ì—°ê²° ì™„ë£Œ
            self.end_connection(port)
            event.accept()  # ì´ë²¤íŠ¸ ì²˜ë¦¬ ì™„ë£Œ
        else:
            # í¬íŠ¸ê°€ ì•„ë‹Œ ê²½ìš° (ë…¸ë“œë‚˜ ë¹ˆ ê³µê°„) ê¸°ë³¸ ì²˜ë¦¬
            super().mousePressEvent(event)
            
    def mouseMoveEvent(self, event):
        """ë§ˆìš°ìŠ¤ ì´ë™ ì´ë²¤íŠ¸"""
        if self.current_connection:
            self.current_connection.update_path(event.scenePos())
            
            # ê°€ê¹Œìš´ í¬íŠ¸ í•˜ì´ë¼ì´íŠ¸
            nearest_port = self.find_nearest_port(event.scenePos(), "input", 80)
            
            if nearest_port != self.highlighted_port:
                # ì´ì „ í•˜ì´ë¼ì´íŠ¸ í•´ì œ
                if self.highlighted_port:
                    self.highlighted_port.highlight(False)
                    
                # ìƒˆ í¬íŠ¸ í•˜ì´ë¼ì´íŠ¸
                if nearest_port:
                    nearest_port.highlight(True)
                    
                self.highlighted_port = nearest_port
                
        super().mouseMoveEvent(event)
        
    def mouseReleaseEvent(self, event):
        """ë§ˆìš°ìŠ¤ ë¦´ë¦¬ì¦ˆ ì´ë²¤íŠ¸"""
        if self.current_connection:
            # ê°€ê¹Œìš´ ì…ë ¥ í¬íŠ¸ ì°¾ê¸°
            nearest_port = self.find_nearest_port(event.scenePos(), "input", 80)
            
            if nearest_port:
                self.end_connection(nearest_port)
            else:
                # ì—°ê²° ì·¨ì†Œ
                self.removeItem(self.current_connection)
                self.current_connection = None
                self.start_port = None
                
            # í•˜ì´ë¼ì´íŠ¸ í•´ì œ
            if self.highlighted_port:
                self.highlighted_port.highlight(False)
                self.highlighted_port = None
                
        super().mouseReleaseEvent(event)
        
    def start_connection(self, port):
        """ì—°ê²° ì‹œì‘"""
        self.start_port = port
        self.current_connection = Connection(port)
        self.addItem(self.current_connection)
        
    def end_connection(self, end_port):
        """ì—°ê²° ì™„ë£Œ"""
        if self.start_port and self.current_connection and self.start_port.can_connect_to(end_port):
            # ì—°ê²° ì™„ë£Œ
            self.current_connection.end_port = end_port
            self.current_connection.update_path()
            
            self.start_port.connections.append(self.current_connection)
            end_port.connections.append(self.current_connection)
            
            self.current_connection = None
            self.start_port = None
        else:
            # ì—°ê²° ì‹¤íŒ¨
            if self.current_connection:
                self.removeItem(self.current_connection)
                self.current_connection = None
                self.start_port = None
                
    def contextMenuEvent(self, event):
        """ì”¬ ìš°í´ë¦­ ì»¨í…ìŠ¤íŠ¸ ë©”ë‰´"""
        # ì•„ì´í…œì´ ì—†ëŠ” ë¹ˆ ê³µê°„ì—ì„œë§Œ ë™ì‘
        items = self.items(event.scenePos())
        if not any(isinstance(item, (Node, Connection, MemoItem)) for item in items):
            menu = QMenu()
            
            # ë©”ëª¨ ì¶”ê°€ ë©”ë‰´
            add_memo_action = QAction("ğŸ“ ë©”ëª¨ ì¶”ê°€", None)
            add_memo_action.triggered.connect(lambda: self.add_memo_at(event.scenePos()))
            menu.addAction(add_memo_action)
            
            menu.exec_(event.screenPos())
        else:
            super().contextMenuEvent(event)
            
    def add_memo_at(self, pos):
        """ì§€ì •ëœ ìœ„ì¹˜ì— ë©”ëª¨ ì¶”ê°€"""
        memo = MemoItem(pos.x() - 125, pos.y() - 75)  # ì¤‘ì•™ì— ì˜¤ë„ë¡ ì¡°ì •
        self.addItem(memo)
        if self.main_window:
            self.main_window.log("ë©”ëª¨ê°€ ì¶”ê°€ë˜ì—ˆìŠµë‹ˆë‹¤")


class NodeView(QGraphicsView):
    """ë…¸ë“œ ì—ë””í„° ë·°"""
    def __init__(self, scene):
        super().__init__(scene)
        
        # ë·° ì„¤ì •
        self.setRenderHint(QPainter.Antialiasing)
        self.setViewportUpdateMode(QGraphicsView.FullViewportUpdate)
        self.setDragMode(QGraphicsView.RubberBandDrag)
        
        # ì¤Œ ê´€ë ¨
        self.zoom_factor = 1.15
        self.zoom_level = 0
        self.max_zoom = 10
        self.min_zoom = -10
        
        # íŒ¬(ì´ë™) ê´€ë ¨
        self.is_panning = False
        self.pan_start_pos = None
        self.space_pressed = False
        
    def wheelEvent(self, event):
        """ë§ˆìš°ìŠ¤ íœ ë¡œ ì¤Œ"""
        # ì¤Œ ì¸/ì•„ì›ƒ
        if event.angleDelta().y() > 0 and self.zoom_level < self.max_zoom:
            self.scale(self.zoom_factor, self.zoom_factor)
            self.zoom_level += 1
        elif event.angleDelta().y() < 0 and self.zoom_level > self.min_zoom:
            self.scale(1/self.zoom_factor, 1/self.zoom_factor)
            self.zoom_level -= 1
            
    def mousePressEvent(self, event):
        """ë§ˆìš°ìŠ¤ í´ë¦­ ì´ë²¤íŠ¸"""
        # ê°€ìš´ë° ë²„íŠ¼ ë˜ëŠ” ìŠ¤í˜ì´ìŠ¤ + ì™¼ìª½ ë²„íŠ¼ìœ¼ë¡œ íŒ¬ ì‹œì‘
        if event.button() == Qt.MiddleButton or (self.space_pressed and event.button() == Qt.LeftButton):
            self.is_panning = True
            self.pan_start_pos = event.pos()
            self.setCursor(Qt.ClosedHandCursor)
            self.setDragMode(QGraphicsView.NoDrag)
        else:
            super().mousePressEvent(event)
            
    def mouseMoveEvent(self, event):
        """ë§ˆìš°ìŠ¤ ì´ë™ ì´ë²¤íŠ¸"""
        if self.is_panning:
            # í™”ë©´ ì´ë™
            delta = event.pos() - self.pan_start_pos
            self.pan_start_pos = event.pos()
            
            # ìŠ¤í¬ë¡¤ë°” ì´ë™
            self.horizontalScrollBar().setValue(
                self.horizontalScrollBar().value() - delta.x()
            )
            self.verticalScrollBar().setValue(
                self.verticalScrollBar().value() - delta.y()
            )
        else:
            super().mouseMoveEvent(event)
            
    def mouseReleaseEvent(self, event):
        """ë§ˆìš°ìŠ¤ ë¦´ë¦¬ì¦ˆ ì´ë²¤íŠ¸"""
        if event.button() == Qt.MiddleButton or (self.is_panning and event.button() == Qt.LeftButton):
            self.is_panning = False
            self.setCursor(Qt.ArrowCursor)
            self.setDragMode(QGraphicsView.RubberBandDrag)
        else:
            super().mouseReleaseEvent(event)
            
    def keyPressEvent(self, event):
        """í‚¤ë³´ë“œ ì´ë²¤íŠ¸"""
        if event.key() == Qt.Key_Delete:
            # ì„ íƒëœ ì•„ì´í…œ ì‚­ì œ
            for item in self.scene().selectedItems():
                if isinstance(item, Node):
                    self.delete_node(item)
                elif isinstance(item, Connection):
                    item.remove()
                elif isinstance(item, MemoItem):
                    self.scene().removeItem(item)
        elif event.key() == Qt.Key_Space and not event.isAutoRepeat():
            # ìŠ¤í˜ì´ìŠ¤ë°” ëˆ„ë¥´ë©´ íŒ¬ ëª¨ë“œ í™œì„±í™”
            self.space_pressed = True
            self.setCursor(Qt.OpenHandCursor)
        elif event.key() == Qt.Key_F:
            # Fí‚¤ë¡œ ì „ì²´ ë³´ê¸°
            self.fitInView(self.scene().itemsBoundingRect(), Qt.KeepAspectRatio)
            self.zoom_level = 0
            
        super().keyPressEvent(event)
        
    def keyReleaseEvent(self, event):
        """í‚¤ë³´ë“œ ë¦´ë¦¬ì¦ˆ ì´ë²¤íŠ¸"""
        if event.key() == Qt.Key_Space and not event.isAutoRepeat():
            self.space_pressed = False
            if not self.is_panning:
                self.setCursor(Qt.ArrowCursor)
                
        super().keyReleaseEvent(event)
        
    def delete_node(self, node):
        """ë…¸ë“œ ì‚­ì œ"""
        # ì—°ê²°ëœ ëª¨ë“  ì—°ê²°ì„  ì œê±°
        for port in node.input_ports + node.output_ports:
            for connection in port.connections[:]:
                connection.remove()
                    
        # ë…¸ë“œ ì œê±°
        self.scene().removeItem(node)


class SemiconductorMCSSystem(QMainWindow):
    """ë°˜ë„ì²´ FAB MCS ì˜ˆì¸¡ ì‹œìŠ¤í…œ ë©”ì¸ ìœˆë„ìš°"""
    def __init__(self):
        super().__init__()
        self.setWindowTitle("ë°˜ë„ì²´ FAB MCS ì˜ˆì¸¡ ì‹œìŠ¤í…œ - ë”¥ëŸ¬ë‹ Node Editor")
        self.setGeometry(100, 100, 1400, 800)
        
        # ë‹¤í¬ í…Œë§ˆ ì ìš©
        self.setStyleSheet("""
            QMainWindow {
                background-color: #1e1e1e;
            }
            QDockWidget {
                background-color: #252525;
                color: #ffffff;
            }
            QDockWidget::title {
                background-color: #2d2d2d;
                padding: 5px;
            }
            QPushButton {
                background-color: #3c3c3c;
                color: #ffffff;
                border: 1px solid #555555;
                padding: 5px 10px;
                border-radius: 3px;
            }
            QPushButton:hover {
                background-color: #484848;
            }
            QPushButton:pressed {
                background-color: #2d2d2d;
            }
            QLabel {
                color: #ffffff;
            }
            QListWidget {
                background-color: #2d2d2d;
                color: #ffffff;
                border: 1px solid #444444;
            }
            QListWidget::item:hover {
                background-color: #3c3c3c;
            }
            QTextEdit {
                background-color: #2d2d2d;
                color: #ffffff;
                border: 1px solid #444444;
            }
        """)
        
        # ì”¬ê³¼ ë·° ìƒì„± - parentë¡œ self ì „ë‹¬
        self.scene = NodeScene(self)
        self.view = NodeView(self.scene)
        self.setCentralWidget(self.view)
        
        # UI ì´ˆê¸°í™”
        self.init_ui()
        
        # ì”¬ ì´ë²¤íŠ¸ ì—°ê²°
        self.scene.selectionChanged.connect(self.update_properties)
        
    def init_ui(self):
        """UI ì´ˆê¸°í™”"""
        # ë©”ë‰´ë°”
        self.create_menu_bar()
        
        # íˆ´ë°”
        self.create_toolbar()
        
        # ë… ìœ„ì ¯ë“¤
        self.create_dock_widgets()
        
        # ìƒíƒœë°”
        self.statusBar().showMessage("ì¤€ë¹„ë¨")
        
    def create_menu_bar(self):
        """ë©”ë‰´ë°” ìƒì„±"""
        menubar = self.menuBar()
        
        # íŒŒì¼ ë©”ë‰´
        file_menu = menubar.addMenu("íŒŒì¼")
        
        new_action = QAction("ìƒˆ íŒŒì¼", self)
        new_action.setShortcut("Ctrl+N")
        new_action.triggered.connect(self.new_pipeline)
        file_menu.addAction(new_action)
        
        open_action = QAction("ì—´ê¸°", self)
        open_action.setShortcut("Ctrl+O")
        open_action.triggered.connect(self.load_pipeline)
        file_menu.addAction(open_action)
        
        save_action = QAction("ì €ì¥", self)
        save_action.setShortcut("Ctrl+S")
        save_action.triggered.connect(self.save_pipeline)
        file_menu.addAction(save_action)
        
        file_menu.addSeparator()
        
        exit_action = QAction("ì¢…ë£Œ", self)
        exit_action.setShortcut("Ctrl+Q")
        exit_action.triggered.connect(self.close)
        file_menu.addAction(exit_action)
        
        # í¸ì§‘ ë©”ë‰´
        edit_menu = menubar.addMenu("í¸ì§‘")
        
        # ë©”ëª¨ ì¶”ê°€
        add_memo_action = QAction("ë©”ëª¨ ì¶”ê°€", self)
        add_memo_action.setShortcut("Ctrl+M")
        add_memo_action.triggered.connect(self.add_memo)
        edit_menu.addAction(add_memo_action)
        
        edit_menu.addSeparator()
        
        delete_action = QAction("ì‚­ì œ", self)
        delete_action.setShortcut("Delete")
        delete_action.triggered.connect(self.delete_selected)
        edit_menu.addAction(delete_action)
        
        # ë³´ê¸° ë©”ë‰´
        view_menu = menubar.addMenu("ë³´ê¸°")
        
        grid_action = QAction("ê·¸ë¦¬ë“œ í‘œì‹œ", self)
        grid_action.setCheckable(True)
        grid_action.setChecked(True)
        grid_action.triggered.connect(self.toggle_grid)
        view_menu.addAction(grid_action)
        
        fit_action = QAction("ì „ì²´ ë³´ê¸°", self)
        fit_action.setShortcut("F")
        fit_action.triggered.connect(self.fit_view)
        view_menu.addAction(fit_action)
        
    def create_toolbar(self):
        """íˆ´ë°” ìƒì„±"""
        toolbar = self.addToolBar("ë©”ì¸ íˆ´ë°”")
        toolbar.setMovable(False)
        
        # ë©”ëª¨ ì¶”ê°€ ë²„íŠ¼
        memo_action = QAction(QIcon(), "ğŸ“ ë©”ëª¨", self)
        memo_action.triggered.connect(self.add_memo)
        toolbar.addAction(memo_action)
        
        toolbar.addSeparator()
        
        # ì‹¤í–‰ ë²„íŠ¼
        run_action = QAction(QIcon(), "ì‹¤í–‰", self)
        run_action.triggered.connect(self.run_pipeline)
        toolbar.addAction(run_action)
        
        # ê²€ì¦ ë²„íŠ¼
        validate_action = QAction(QIcon(), "ê²€ì¦", self)
        validate_action.triggered.connect(self.validate_pipeline)
        toolbar.addAction(validate_action)
        
        toolbar.addSeparator()
        
        # ì¤Œ ì»¨íŠ¸ë¡¤
        zoom_in_action = QAction(QIcon(), "í™•ëŒ€", self)
        zoom_in_action.triggered.connect(lambda: self.view.scale(1.2, 1.2))
        toolbar.addAction(zoom_in_action)
        
        zoom_out_action = QAction(QIcon(), "ì¶•ì†Œ", self)
        zoom_out_action.triggered.connect(lambda: self.view.scale(0.8, 0.8))
        toolbar.addAction(zoom_out_action)
        
        zoom_reset_action = QAction(QIcon(), "100%", self)
        zoom_reset_action.triggered.connect(self.reset_zoom)
        toolbar.addAction(zoom_reset_action)
        
        toolbar.addSeparator()
        
        # ë„ì›€ë§
        help_action = QAction(QIcon(), "ë„ì›€ë§", self)
        help_action.triggered.connect(self.show_help)
        toolbar.addAction(help_action)
        
    def create_dock_widgets(self):
        """ë… ìœ„ì ¯ ìƒì„±"""
        # ë…¸ë“œ íŒ”ë ˆíŠ¸
        self.create_node_palette()
        
        # ì†ì„± íŒ¨ë„
        self.create_properties_panel()
        
        # ì½˜ì†” ì¶œë ¥
        self.create_console_panel()
        
    def create_node_palette(self):
        """ë…¸ë“œ íŒ”ë ˆíŠ¸ ìƒì„± - í†µí•© MCS ë°ì´í„°ìš©"""
        dock = QDockWidget("ë…¸ë“œ íŒ”ë ˆíŠ¸", self)
        dock.setAllowedAreas(Qt.LeftDockWidgetArea | Qt.RightDockWidgetArea)
        
        widget = QWidget()
        layout = QVBoxLayout()
        
        # í†µí•© MCS ì‹œìŠ¤í…œìš© ë…¸ë“œ ì¹´í…Œê³ ë¦¬
        categories = {
            "ë°ì´í„° ì…ë ¥": [
                ("í†µí•© MCS ë¡œê·¸", NodeType.DATA, "MCS ë¡œê·¸"),
            ],
            "ë°ì´í„° ì¶”ì¶œ/ì „ì²˜ë¦¬": [
                ("ì„¼ì„œ ë°ì´í„° ì¶”ì¶œ", NodeType.PREPROCESS, "ì„¼ì„œ ì¶”ì¶œ"),
                ("ì´ë²¤íŠ¸ íƒ€ì… í•„í„°", NodeType.PREPROCESS, "ì´ë²¤íŠ¸ í•„í„°"),
                ("ì´ìƒì¹˜ ì œê±°", NodeType.PREPROCESS, "ì´ìƒì¹˜ ì œê±°"),
                ("ì‹œê°„ë³„ ì§‘ê³„", NodeType.PREPROCESS, "ì‹œê°„ë³„ ì§‘ê³„"),
                ("ë² ì´ë³„ ë¶„ë¥˜", NodeType.PREPROCESS, "ë² ì´ë³„ ë¶„ë¥˜"),
                ("LOTë³„ ê·¸ë£¹í™”", NodeType.PREPROCESS, "LOT ê·¸ë£¹í™”"),
                ("ì¥ë¹„ë³„ ë¶„ë¥˜", NodeType.PREPROCESS, "ì¥ë¹„ë³„ ë¶„ë¥˜"),
            ],
            "ë²¡í„° ì €ì¥": [
                ("RAG ë²¡í„° ì €ì¥", NodeType.VECTOR, "RAG ë²¡í„°"),
                ("ì•ŒëŒ íŒ¨í„´ ë²¡í„°", NodeType.VECTOR, "ì•ŒëŒ ë²¡í„°"),
            ],
            "ì˜ˆì¸¡ ëª¨ë¸": [
                ("LSTM (ì´ì†¡ì‹œê°„)", NodeType.MODEL, "LSTM"),
                ("RNN (ë³‘ëª©ì˜ˆì¸¡)", NodeType.MODEL, "RNN"),
                ("ARIMA (ì²˜ë¦¬ëŸ‰)", NodeType.MODEL, "ARIMA"),
                ("ì„¼ì„œ ì´ìƒíƒì§€", NodeType.MODEL, "ì„¼ì„œì´ìƒíƒì§€"),
            ],
            "ë¶„ì„": [
                ("OHT íŒ¨í„´ ë¶„ì„", NodeType.ANALYSIS, "OHTíŒ¨í„´"),
                ("ì¥ë¹„ ê°€ë™ë¥  ë¶„ì„", NodeType.ANALYSIS, "ê°€ë™ë¥ "),
                ("ë³‘ëª© êµ¬ê°„ ë¶„ì„", NodeType.ANALYSIS, "ë³‘ëª©ë¶„ì„"),
                ("ì„¼ì„œ íŠ¸ë Œë“œ ë¶„ì„", NodeType.ANALYSIS, "ì„¼ì„œíŠ¸ë Œë“œ"),
            ],
        }
        
        for category, nodes in categories.items():
            group = QGroupBox(category)
            group_layout = QVBoxLayout()
            
            for label, node_type, name in nodes:
                btn = QPushButton(label)
                btn.clicked.connect(lambda checked, t=node_type, n=name: self.add_node(t, n))
                group_layout.addWidget(btn)
                
            group.setLayout(group_layout)
            layout.addWidget(group)
            
        layout.addStretch()
        widget.setLayout(layout)
        
        scroll = QScrollArea()
        scroll.setWidget(widget)
        scroll.setWidgetResizable(True)
        dock.setWidget(scroll)
        
        self.addDockWidget(Qt.LeftDockWidgetArea, dock)
        
    def create_properties_panel(self):
        """ì†ì„± íŒ¨ë„ ìƒì„±"""
        dock = QDockWidget("ë…¸ë“œ ì†ì„±", self)
        dock.setAllowedAreas(Qt.LeftDockWidgetArea | Qt.RightDockWidgetArea)
        
        self.properties_widget = QTextEdit()
        self.properties_widget.setReadOnly(True)
        self.properties_widget.setPlainText("ë…¸ë“œë¥¼ ì„ íƒí•˜ì„¸ìš”")
        
        dock.setWidget(self.properties_widget)
        self.addDockWidget(Qt.RightDockWidgetArea, dock)
        
    def create_console_panel(self):
        """ì½˜ì†” íŒ¨ë„ ìƒì„±"""
        dock = QDockWidget("ì½˜ì†”", self)
        dock.setAllowedAreas(Qt.BottomDockWidgetArea)
        
        self.console = QTextEdit()
        self.console.setReadOnly(True)
        self.console.setMaximumHeight(150)
        
        dock.setWidget(self.console)
        self.addDockWidget(Qt.BottomDockWidgetArea, dock)
        
    def add_node(self, node_type: NodeType, name: str):
        """ë…¸ë“œ ì¶”ê°€"""
        self.log(f"ë…¸ë“œ ì¶”ê°€ ìš”ì²­: {name} (íƒ€ì…: {node_type.value})")
        
        # ë·° ì¤‘ì•™ì— ë…¸ë“œ ìƒì„±
        view_center = self.view.mapToScene(self.view.rect().center())
        
        node = Node(node_type, name, view_center.x() - 100, view_center.y() - 50)
        self.scene.addItem(node)
        
        self.log(f"{name} ë…¸ë“œê°€ ì¶”ê°€ë˜ì—ˆìŠµë‹ˆë‹¤ (ID: {node.node_id})")
        
    def add_memo(self):
        """ë©”ëª¨ ì¶”ê°€"""
        view_center = self.view.mapToScene(self.view.rect().center())
        memo = MemoItem(view_center.x() - 125, view_center.y() - 75)
        self.scene.addItem(memo)
        self.log("ë©”ëª¨ê°€ ì¶”ê°€ë˜ì—ˆìŠµë‹ˆë‹¤ - ë”ë¸”í´ë¦­ìœ¼ë¡œ í¸ì§‘í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤")
        
    def configure_node(self, node):
        """ë…¸ë“œ ì„¤ì • ëŒ€í™”ìƒì"""
        self.log(f"ë…¸ë“œ ì„¤ì • ì‹œì‘: {node.name} ({node.node_type.value})")
        
        dialog = QDialog(self)
        dialog.setWindowTitle(f"{node.name} ì„¤ì •")
        dialog.setModal(True)
        dialog.setMinimumWidth(600)  # ìµœì†Œ ë„ˆë¹„ ì„¤ì •
        dialog.setMinimumHeight(500)  # ìµœì†Œ ë†’ì´ ì„¤ì •
        
        # ë‹¤ì´ì–¼ë¡œê·¸ ìŠ¤íƒ€ì¼ ì„¤ì •
        dialog.setStyleSheet("""
            QDialog {
                background-color: #2d2d2d;
                color: #ffffff;
            }
            QLabel {
                color: #ffffff;
            }
            QGroupBox {
                color: #ffffff;
                border: 1px solid #555555;
                border-radius: 5px;
                margin-top: 10px;
                padding-top: 10px;
            }
            QGroupBox::title {
                subcontrol-origin: margin;
                left: 10px;
                padding: 0 5px 0 5px;
            }
        """)
        
        # ìŠ¤í¬ë¡¤ ê°€ëŠ¥í•œ ì˜ì—­ ìƒì„±
        scroll = QScrollArea()
        scroll.setWidgetResizable(True)
        scroll_widget = QWidget()
        scroll_layout = QVBoxLayout()
        
        # ë…¸ë“œ íƒ€ì…ë³„ ì„¤ì • UI
        if node.node_type == NodeType.DATA:
            self.create_data_config(scroll_layout, node)
        elif node.node_type == NodeType.PREPROCESS:
            self.create_preprocess_config(scroll_layout, node)
        elif node.node_type == NodeType.MODEL:
            self.create_model_config(scroll_layout, node)
        elif node.node_type == NodeType.VECTOR:
            self.create_vector_config(scroll_layout, node)
        elif node.node_type == NodeType.ANALYSIS:
            self.create_analysis_config(scroll_layout, node)
            
        scroll_widget.setLayout(scroll_layout)
        scroll.setWidget(scroll_widget)
        
        # ë©”ì¸ ë ˆì´ì•„ì›ƒ
        main_layout = QVBoxLayout()
        main_layout.addWidget(scroll, 1)
        
        # ë²„íŠ¼
        buttons = QDialogButtonBox(QDialogButtonBox.Ok | QDialogButtonBox.Cancel)
        buttons.accepted.connect(lambda: self.save_node_config(dialog, node))
        buttons.rejected.connect(dialog.reject)
        main_layout.addWidget(buttons)
        
        dialog.setLayout(main_layout)
        
        self.log(f"ëŒ€í™”ìƒì í‘œì‹œ ì¤‘...")
        result = dialog.exec_()
        self.log(f"ëŒ€í™”ìƒì ê²°ê³¼: {'í™•ì¸' if result else 'ì·¨ì†Œ'}")
        
    def create_data_config(self, layout, node):
        """ë°ì´í„° ë…¸ë“œ ì„¤ì • UI - í†µí•© MCS ë°ì´í„°ìš©"""
        layout.addWidget(QLabel("ë°ì´í„° ì†ŒìŠ¤ ì„¤ì •"))
        
        # íŒŒì¼ ì„ íƒ
        file_layout = QHBoxLayout()
        layout.addWidget(QLabel("íŒŒì¼ ê²½ë¡œ:"))
        path_edit = QLineEdit()
        path_edit.setObjectName("path")
        if 'path' in node.settings:
            path_edit.setText(node.settings['path'])
        file_btn = QPushButton("ì°¾ì•„ë³´ê¸°...")
        file_btn.clicked.connect(lambda: self.browse_file(path_edit))
        file_layout.addWidget(path_edit)
        file_layout.addWidget(file_btn)
        layout.addLayout(file_layout)
        
        # ë°ì´í„° í˜•ì‹
        layout.addWidget(QLabel("ë°ì´í„° í˜•ì‹:"))
        format_combo = QComboBox()
        format_combo.addItems(["CSV", "JSON", "Excel", "Database"])
        format_combo.setObjectName("format")
        layout.addWidget(format_combo)
        
        # í†µí•© MCS ë°ì´í„° ì „ìš© ì„¤ì •
        if "MCS" in node.name:
            # FAB ë¼ì¸ í•„í„°
            layout.addWidget(QLabel("FAB ë¼ì¸:"))
            fab_combo = QComboBox()
            fab_combo.addItems(["ì „ì²´", "FAB1", "FAB2", "FAB3"])
            fab_combo.setObjectName("fab_line")
            layout.addWidget(fab_combo)
            
            # ì´ë²¤íŠ¸ íƒ€ì… í•„í„°
            layout.addWidget(QLabel("ì´ë²¤íŠ¸ íƒ€ì… í•„í„°:"))
            event_types = [
                "ì „ì²´", "TRANSFER", "PROCESS", "SENSOR_UPDATE", 
                "ALARM", "STOCKER", "LOAD/UNLOAD"
            ]
            for i, evt in enumerate(event_types):
                check = QCheckBox(evt)
                check.setChecked(i == 0)
                check.setObjectName(f"event_filter_{i}")
                layout.addWidget(check)
            
            # ë°ì´í„° í¬í•¨ ì˜µì…˜
            layout.addWidget(QLabel("í¬í•¨í•  ë°ì´í„°:"))
            data_options = [
                "ì´ë²¤íŠ¸ ë¡œê·¸", "ì„¼ì„œ ë°ì´í„°", "ì•ŒëŒ ì •ë³´", 
                "ì´ì†¡ ì‹œê°„", "ì¥ë¹„ ìƒíƒœ"
            ]
            for i, opt in enumerate(data_options):
                check = QCheckBox(opt)
                check.setChecked(True)
                check.setObjectName(f"data_include_{i}")
                layout.addWidget(check)
                
            # ì‹œê°„ ë²”ìœ„ í•„í„°
            layout.addWidget(QLabel("ì‹œê°„ ë²”ìœ„ (ì„ íƒì‚¬í•­):"))
            time_range_check = QCheckBox("ì‹œê°„ ë²”ìœ„ í•„í„° ì‚¬ìš©")
            time_range_check.setObjectName("use_time_filter")
            layout.addWidget(time_range_check)
        
    def create_preprocess_config(self, layout, node):
        """ì „ì²˜ë¦¬ ë…¸ë“œ ì„¤ì • UI - í†µí•© MCS ë°ì´í„°ìš©"""
        layout.addWidget(QLabel("ì „ì²˜ë¦¬ ì„¤ì •"))
        
        if "ì„¼ì„œ ì¶”ì¶œ" in node.name:
            layout.addWidget(QLabel("ì¶”ì¶œí•  ì„¼ì„œ ë°ì´í„°:"))
            sensor_types = [
                "ì§„ë™ (vibration)", "ì˜¨ë„ (temperature)", "ì••ë ¥ (pressure)",
                "íŒŒí‹°í´ (particle)", "ìŠµë„ (humidity)", "ìœ ëŸ‰ (flow_rate)"
            ]
            for i, sensor in enumerate(sensor_types):
                check = QCheckBox(sensor)
                check.setChecked(True)
                check.setObjectName(f"extract_sensor_{i}")
                layout.addWidget(check)
            
            layout.addWidget(QLabel("ì¶”ì¶œ ì˜µì…˜:"))
            extract_combo = QComboBox()
            extract_combo.addItems([
                "ëª¨ë“  ì„¼ì„œ ì´ë²¤íŠ¸", "SENSOR_UPDATEë§Œ", "PROCESS ì´ë²¤íŠ¸ë§Œ", 
                "ì•ŒëŒ ë°œìƒ ì‹œì ë§Œ", "ì´ìƒì¹˜ë§Œ ì¶”ì¶œ"
            ])
            extract_combo.setObjectName("extract_option")
            layout.addWidget(extract_combo)
            
        elif "ì´ë²¤íŠ¸ í•„í„°" in node.name:
            layout.addWidget(QLabel("í•„í„°ë§í•  ì´ë²¤íŠ¸ íƒ€ì…:"))
            event_types = [
                "LOAD_REQUEST", "UNLOAD_REQUEST", "TRANSFER_START", "TRANSFER_COMPLETE",
                "PROCESS_START", "PROCESS_END", "SENSOR_UPDATE", "ALARM_OCCURRED",
                "STOCKER_IN", "STOCKER_OUT"
            ]
            for i, evt in enumerate(event_types):
                check = QCheckBox(evt)
                check.setChecked(False)
                check.setObjectName(f"filter_event_{i}")
                layout.addWidget(check)
                
        elif "ì´ìƒì¹˜" in node.name:
            layout.addWidget(QLabel("ì´ìƒì¹˜ íƒì§€ ë°©ë²•:"))
            method_combo = QComboBox()
            method_combo.addItems(["IQR", "Z-Score", "Isolation Forest", "DBSCAN", "LOF"])
            method_combo.setObjectName("method")
            layout.addWidget(method_combo)
            
            layout.addWidget(QLabel("ì ìš© ëŒ€ìƒ:"))
            target_combo = QComboBox()
            target_combo.addItems([
                "ì „ì²´ ìˆ˜ì¹˜ ë°ì´í„°", "ì„¼ì„œ ë°ì´í„°ë§Œ", "ì´ì†¡ ì‹œê°„ë§Œ", 
                "íŠ¹ì • ì»¬ëŸ¼ ì„ íƒ"
            ])
            target_combo.setObjectName("anomaly_target")
            layout.addWidget(target_combo)
            
            layout.addWidget(QLabel("ì„ê³„ê°’:"))
            threshold_spin = QDoubleSpinBox()
            threshold_spin.setRange(0.1, 5.0)
            threshold_spin.setValue(1.5)
            threshold_spin.setSingleStep(0.1)
            threshold_spin.setObjectName("threshold")
            layout.addWidget(threshold_spin)
            
        elif "ì‹œê°„ë³„" in node.name:
            layout.addWidget(QLabel("ì§‘ê³„ ë‹¨ìœ„:"))
            time_combo = QComboBox()
            time_combo.addItems(["1ë¶„", "5ë¶„", "10ë¶„", "30ë¶„", "1ì‹œê°„", "4ì‹œê°„", "1ì¼"])
            time_combo.setCurrentText("1ì‹œê°„")
            time_combo.setObjectName("time_unit")
            layout.addWidget(time_combo)
            
            layout.addWidget(QLabel("ì§‘ê³„ ë°©ë²•:"))
            agg_combo = QComboBox()
            agg_combo.addItems(["í‰ê· ", "í•©ê³„", "ìµœëŒ€", "ìµœì†Œ", "ì¤‘ì•™ê°’", "ì¹´ìš´íŠ¸"])
            agg_combo.setObjectName("aggregation")
            layout.addWidget(agg_combo)
            
            layout.addWidget(QLabel("ì§‘ê³„ ëŒ€ìƒ:"))
            agg_target = QComboBox()
            agg_target.addItems([
                "ì´ë²¤íŠ¸ ìˆ˜", "ì„¼ì„œ ê°’", "ì´ì†¡ ì‹œê°„", "ì•ŒëŒ ìˆ˜", "ì „ì²´"
            ])
            agg_target.setObjectName("aggregation_target")
            layout.addWidget(agg_target)
            
        elif "ë² ì´ë³„" in node.name:
            layout.addWidget(QLabel("ë² ì´ ê·¸ë£¹í™”:"))
            bays = ["PHOTO", "ETCH", "DIFF", "CVD", "PVD", "CMP", "CLEAN", "TEST"]
            for i, bay in enumerate(bays):
                check = QCheckBox(bay)
                check.setChecked(True)
                check.setObjectName(f"bay_{i}")
                layout.addWidget(check)
                
        elif "LOT" in node.name:
            layout.addWidget(QLabel("LOT í•„í„°:"))
            lot_combo = QComboBox()
            lot_combo.addItems(["ì „ì²´", "HOT LOT", "SUPER HOT", "ì¼ë°˜ LOT"])
            lot_combo.setObjectName("lot_filter")
            layout.addWidget(lot_combo)
            
        elif "ì¥ë¹„ë³„" in node.name:
            layout.addWidget(QLabel("ì¥ë¹„ ê·¸ë£¹í™” ê¸°ì¤€:"))
            group_combo = QComboBox()
            group_combo.addItems([
                "ì¥ë¹„ IDë³„", "ì¥ë¹„ íƒ€ì…ë³„", "ë² ì´ë³„ ì¥ë¹„", "ì œì¡°ì‚¬ë³„"
            ])
            group_combo.setObjectName("equipment_grouping")
            layout.addWidget(group_combo)
            
            layout.addWidget(QLabel("í¬í•¨í•  ë°ì´í„°:"))
            include_checks = ["ì´ë²¤íŠ¸", "ì„¼ì„œ", "ì•ŒëŒ", "ê°€ë™ ì‹œê°„"]
            for i, item in enumerate(include_checks):
                check = QCheckBox(item)
                check.setChecked(True)
                check.setObjectName(f"equipment_include_{i}")
                layout.addWidget(check)
            
    def create_model_config(self, layout, node):
        """ëª¨ë¸ ë…¸ë“œ ì„¤ì • UI - ë°˜ë„ì²´ FAB ìš©"""
        layout.addWidget(QLabel("ëª¨ë¸ ì„¤ì •"))
        
        # ì˜ˆì¸¡ ëŒ€ìƒ
        layout.addWidget(QLabel("ì˜ˆì¸¡ ëŒ€ìƒ:"))
        target_combo = QComboBox()
        
        if "LSTM" in node.name:
            target_combo.addItems(["ì´ì†¡ ì‹œê°„", "ëŒ€ê¸° ì‹œê°„", "ì „ì²´ ì‚¬ì´í´ íƒ€ì„"])
        elif "RNN" in node.name:
            target_combo.addItems(["ë³‘ëª© ë°œìƒ í™•ë¥ ", "ì§€ì—° ì‹œê°„", "OHT ì •ì²´"])
        elif "ARIMA" in node.name:
            target_combo.addItems(["ì‹œê°„ë‹¹ ì²˜ë¦¬ëŸ‰", "ì¼ì¼ ìƒì‚°ëŸ‰", "ê°€ë™ë¥ "])
        elif "ì„¼ì„œì´ìƒíƒì§€" in node.name:
            target_combo.addItems(["ì§„ë™ ì´ìƒ", "ì˜¨ë„ ì´ìƒ", "ì••ë ¥ ì´ìƒ", "íŒŒí‹°í´ ì´ìƒ", "ë³µí•© ì´ìƒ"])
            layout.addWidget(QLabel("ì´ìƒíƒì§€ ì•Œê³ ë¦¬ì¦˜:"))
            algo_combo = QComboBox()
            algo_combo.addItems([
                "Isolation Forest", "One-Class SVM", "Autoencoder", 
                "LSTM Autoencoder", "Statistical Process Control"
            ])
            algo_combo.setObjectName("anomaly_algorithm")
            layout.addWidget(algo_combo)
            
            layout.addWidget(QLabel("ë¯¼ê°ë„:"))
            sensitivity_slider = QSlider(Qt.Horizontal)
            sensitivity_slider.setRange(1, 100)
            sensitivity_slider.setValue(80)
            sensitivity_slider.setObjectName("sensitivity")
            sensitivity_label = QLabel("80%")
            sensitivity_slider.valueChanged.connect(lambda v: sensitivity_label.setText(f"{v}%"))
            
            sens_layout = QHBoxLayout()
            sens_layout.addWidget(sensitivity_slider)
            sens_layout.addWidget(sensitivity_label)
            layout.addLayout(sens_layout)
            
        target_combo.setObjectName("prediction_target")
        layout.addWidget(target_combo)
        
        # ì˜ˆì¸¡ ê¸°ê°„
        layout.addWidget(QLabel("ì˜ˆì¸¡ ê¸°ê°„:"))
        period_combo = QComboBox()
        period_combo.addItems(["10ë¶„", "30ë¶„", "1ì‹œê°„", "4ì‹œê°„", "1ì¼", "1ì£¼ì¼"])
        period_combo.setCurrentText("1ì‹œê°„")
        period_combo.setObjectName("period")
        layout.addWidget(period_combo)
        
        if "LSTM" in node.name or "RNN" in node.name:
            layout.addWidget(QLabel("ì€ë‹‰ì¸µ ìˆ˜:"))
            layers_spin = QSpinBox()
            layers_spin.setRange(1, 10)
            layers_spin.setValue(3)
            layers_spin.setObjectName("layers")
            layout.addWidget(layers_spin)
            
            layout.addWidget(QLabel("ìœ ë‹› ìˆ˜:"))
            units_spin = QSpinBox()
            units_spin.setRange(32, 512)
            units_spin.setValue(128)
            units_spin.setSingleStep(32)
            units_spin.setObjectName("units")
            layout.addWidget(units_spin)
            
        elif "ARIMA" in node.name:
            layout.addWidget(QLabel("p (ìê¸°íšŒê·€):"))
            p_spin = QSpinBox()
            p_spin.setRange(0, 10)
            p_spin.setValue(2)
            p_spin.setObjectName("p")
            layout.addWidget(p_spin)
            
            layout.addWidget(QLabel("d (ì°¨ë¶„):"))
            d_spin = QSpinBox()
            d_spin.setRange(0, 5)
            d_spin.setValue(1)
            d_spin.setObjectName("d")
            layout.addWidget(d_spin)
            
            layout.addWidget(QLabel("q (ì´ë™í‰ê· ):"))
            q_spin = QSpinBox()
            q_spin.setRange(0, 10)
            q_spin.setValue(2)
            q_spin.setObjectName("q")
            layout.addWidget(q_spin)
            
    def create_vector_config(self, layout, node):
        """ë²¡í„° ì €ì¥ ë…¸ë“œ ì„¤ì • UI"""
        layout.addWidget(QLabel("ë²¡í„° ì €ì¥ ì„¤ì •"))
        
        layout.addWidget(QLabel("ì„ë² ë”© ëª¨ë¸:"))
        embed_combo = QComboBox()
        embed_combo.addItems(["OpenAI", "Sentence-BERT", "Custom FAB", "Multilingual"])
        embed_combo.setObjectName("embedding_model")
        layout.addWidget(embed_combo)
        
        layout.addWidget(QLabel("ë²¡í„° ì°¨ì›:"))
        dim_spin = QSpinBox()
        dim_spin.setRange(128, 2048)
        dim_spin.setValue(768)
        dim_spin.setSingleStep(128)
        dim_spin.setObjectName("vector_dim")
        layout.addWidget(dim_spin)
        
        layout.addWidget(QLabel("ë²¡í„° ì €ì¥ì†Œ:"))
        store_combo = QComboBox()
        store_combo.addItems(["ChromaDB", "Pinecone", "Weaviate", "FAISS"])
        store_combo.setObjectName("vector_store")
        layout.addWidget(store_combo)
        
        if "ì•ŒëŒ" in node.name:
            layout.addWidget(QLabel("ì•ŒëŒ ì½”ë“œ ê·¸ë£¹í™”:"))
            group_check = QCheckBox("ìœ ì‚¬ ì•ŒëŒ ê·¸ë£¹í™”")
            group_check.setChecked(True)
            group_check.setObjectName("group_alarms")
            layout.addWidget(group_check)
        
    def create_analysis_config(self, layout, node):
        """ë¶„ì„ ë…¸ë“œ ì„¤ì • UI - í†µí•© MCS ë°ì´í„°ìš©"""
        layout.addWidget(QLabel("ë¶„ì„ ì„¤ì •"))
        
        layout.addWidget(QLabel("ë¶„ì„ ê¸°ê°„:"))
        period_combo = QComboBox()
        period_combo.addItems(["1ì‹œê°„", "4ì‹œê°„", "1ì¼", "1ì£¼ì¼", "1ê°œì›”", "3ê°œì›”"])
        period_combo.setCurrentText("1ì¼")
        period_combo.setObjectName("analysis_period")
        layout.addWidget(period_combo)
        
        if "OHT" in node.name:
            layout.addWidget(QLabel("ë¶„ì„ í•­ëª©:"))
            patterns = ["ì´ë™ ê²½ë¡œ", "ì •ì²´ êµ¬ê°„", "í‰ê·  ì†ë„", "ê°€ë™ë¥ ", "ì¶©ëŒ ìœ„í—˜"]
            for i, pattern in enumerate(patterns):
                check = QCheckBox(pattern)
                check.setChecked(True)
                check.setObjectName(f"oht_pattern_{i}")
                layout.addWidget(check)
                
        elif "ê°€ë™ë¥ " in node.name:
            layout.addWidget(QLabel("ì¥ë¹„ íƒ€ì…:"))
            equip_combo = QComboBox()
            equip_combo.addItems(["ì „ì²´", "í¬í† ", "ì‹ê°", "ì¦ì°©", "CMP", "ê³„ì¸¡"])
            equip_combo.setObjectName("equipment_type")
            layout.addWidget(equip_combo)
            
            layout.addWidget(QLabel("ê°€ë™ë¥  ê¸°ì¤€ (%):"))
            rate_spin = QSpinBox()
            rate_spin.setRange(0, 100)
            rate_spin.setValue(85)
            rate_spin.setObjectName("target_rate")
            layout.addWidget(rate_spin)
            
        elif "ë³‘ëª©" in node.name:
            layout.addWidget(QLabel("ë³‘ëª© íŒë‹¨ ê¸°ì¤€:"))
            bottleneck_spin = QSpinBox()
            bottleneck_spin.setRange(1, 100)
            bottleneck_spin.setValue(10)
            bottleneck_spin.setSuffix(" ëŒ€ ì´ìƒ ëŒ€ê¸°")
            bottleneck_spin.setObjectName("bottleneck_threshold")
            layout.addWidget(bottleneck_spin)
            
        elif "ì„¼ì„œíŠ¸ë Œë“œ" in node.name:
            layout.addWidget(QLabel("ë¶„ì„í•  ì„¼ì„œ íƒ€ì…:"))
            sensor_types = ["ì§„ë™", "ì˜¨ë„", "ì••ë ¥", "íŒŒí‹°í´", "ìŠµë„", "ìœ ëŸ‰"]
            for i, sensor in enumerate(sensor_types):
                check = QCheckBox(sensor)
                check.setChecked(i < 3)  # ê¸°ë³¸ì ìœ¼ë¡œ ì§„ë™, ì˜¨ë„, ì••ë ¥ë§Œ ì„ íƒ
                check.setObjectName(f"trend_sensor_{i}")
                layout.addWidget(check)
            
            layout.addWidget(QLabel("íŠ¸ë Œë“œ ë¶„ì„ ë°©ë²•:"))
            trend_combo = QComboBox()
            trend_combo.addItems([
                "ì´ë™í‰ê· ", "ì„ í˜•íšŒê·€", "ê³„ì ˆì„± ë¶„í•´", "ì´ìƒì¹˜ ë¹ˆë„", 
                "í”¼í¬ ê²€ì¶œ", "ë³€í™”ìœ¨ ë¶„ì„"
            ])
            trend_combo.setObjectName("trend_method")
            layout.addWidget(trend_combo)
            
            layout.addWidget(QLabel("ì•Œë¦¼ ì„ê³„ê°’ ì„¤ì •:"))
            alert_check = QCheckBox("íŠ¸ë Œë“œ ì•Œë¦¼ ì‚¬ìš©")
            alert_check.setObjectName("use_trend_alert")
            layout.addWidget(alert_check)
            
    def browse_file(self, line_edit):
        """íŒŒì¼ ì°¾ì•„ë³´ê¸° ëŒ€í™”ìƒì"""
        filename, _ = QFileDialog.getOpenFileName(
            self, 
            "ë°ì´í„° íŒŒì¼ ì„ íƒ", 
            "", 
            "Data Files (*.csv *.json *.xlsx);;All Files (*.*)"
        )
        if filename:
            line_edit.setText(filename)
            
    def save_node_config(self, dialog, node):
        """ë…¸ë“œ ì„¤ì • ì €ì¥"""
        # ëŒ€í™”ìƒìì—ì„œ ì„¤ì • ê°’ ìˆ˜ì§‘
        settings = {}
        for child in dialog.findChildren(QWidget):
            if child.objectName():
                if isinstance(child, QLineEdit):
                    settings[child.objectName()] = child.text()
                elif isinstance(child, QComboBox):
                    settings[child.objectName()] = child.currentText()
                elif isinstance(child, QSpinBox) or isinstance(child, QDoubleSpinBox):
                    settings[child.objectName()] = child.value()
                elif isinstance(child, QCheckBox):
                    settings[child.objectName()] = child.isChecked()
                elif isinstance(child, QTextEdit):
                    settings[child.objectName()] = child.toPlainText()
                elif isinstance(child, QSlider):
                    settings[child.objectName()] = child.value() / 100
                    
        node.settings = settings
        node.is_configured = True
        node.update_status()
        
        self.log(f"{node.name} ì„¤ì •ì´ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤")
        self.update_properties()
        
        dialog.accept()
        
    def new_pipeline(self):
        """ìƒˆ íŒŒì´í”„ë¼ì¸"""
        reply = QMessageBox.question(self, "í™•ì¸", "í˜„ì¬ ì‘ì—…ì„ ì§€ìš°ê³  ìƒˆë¡œ ì‹œì‘í•˜ì‹œê² ìŠµë‹ˆê¹Œ?")
        if reply == QMessageBox.Yes:
            self.scene.clear()
            self.log("ìƒˆ íŒŒì´í”„ë¼ì¸ì´ ìƒì„±ë˜ì—ˆìŠµë‹ˆë‹¤")
            
    def save_pipeline(self):
        """íŒŒì´í”„ë¼ì¸ ì €ì¥"""
        filename, _ = QFileDialog.getSaveFileName(self, "íŒŒì´í”„ë¼ì¸ ì €ì¥", "", "JSON Files (*.json)")
        if filename:
            data = {
                "nodes": [],
                "connections": [],
                "memos": []
            }
            
            # ë…¸ë“œ ì •ë³´ ìˆ˜ì§‘
            node_map = {}
            for item in self.scene.items():
                if isinstance(item, Node):
                    node_data = {
                        "id": item.node_id,
                        "type": item.node_type.value,
                        "name": item.name,
                        "x": item.x(),
                        "y": item.y(),
                        "configured": item.is_configured,
                        "settings": item.settings
                    }
                    data["nodes"].append(node_data)
                    node_map[item] = item.node_id
                    
            # ì—°ê²° ì •ë³´ ìˆ˜ì§‘
            for item in self.scene.items():
                if isinstance(item, Connection) and item.start_port and item.end_port:
                    start_node = item.start_port.parentItem()
                    end_node = item.end_port.parentItem()
                    
                    if start_node in node_map and end_node in node_map:
                        conn_data = {
                            "start": node_map[start_node],
                            "start_port": start_node.output_ports.index(item.start_port),
                            "end": node_map[end_node],
                            "end_port": end_node.input_ports.index(item.end_port)
                        }
                        data["connections"].append(conn_data)
                        
            # ë©”ëª¨ ì •ë³´ ìˆ˜ì§‘
            for item in self.scene.items():
                if isinstance(item, MemoItem):
                    data["memos"].append(item.get_data())
                        
            # JSON íŒŒì¼ë¡œ ì €ì¥
            with open(filename, 'w', encoding='utf-8') as f:
                json.dump(data, f, indent=2, ensure_ascii=False)
                
            self.log(f"íŒŒì´í”„ë¼ì¸ì´ ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤: {filename}")
            
    def load_pipeline(self):
        """íŒŒì´í”„ë¼ì¸ ë¶ˆëŸ¬ì˜¤ê¸°"""
        filename, _ = QFileDialog.getOpenFileName(self, "íŒŒì´í”„ë¼ì¸ ì—´ê¸°", "", "JSON Files (*.json)")
        if filename:
            with open(filename, 'r', encoding='utf-8') as f:
                data = json.load(f)
                
            # ì”¬ ì´ˆê¸°í™”
            self.scene.clear()
            
            # ë…¸ë“œ ìƒì„±
            node_map = {}
            for node_data in data["nodes"]:
                node_type = NodeType(node_data["type"])
                node = Node(node_type, node_data["name"], node_data["x"], node_data["y"])
                node.is_configured = node_data.get("configured", False)
                node.settings = node_data.get("settings", {})
                node.update_status()
                
                self.scene.addItem(node)
                node_map[node_data["id"]] = node
                
            # ì—°ê²° ìƒì„±
            for conn_data in data["connections"]:
                start_node = node_map[conn_data["start"]]
                end_node = node_map[conn_data["end"]]
                
                start_port = start_node.output_ports[conn_data.get("start_port", 0)]
                end_port = end_node.input_ports[conn_data.get("end_port", 0)]
                
                connection = Connection(start_port, end_port)
                self.scene.addItem(connection)
                
            # ë©”ëª¨ ìƒì„±
            if "memos" in data:
                for memo_data in data["memos"]:
                    memo = MemoItem()
                    memo.set_data(memo_data)
                    self.scene.addItem(memo)
                
            self.log(f"íŒŒì´í”„ë¼ì¸ì„ ë¶ˆëŸ¬ì™”ìŠµë‹ˆë‹¤: {filename}")
            
    def delete_selected(self):
        """ì„ íƒëœ ì•„ì´í…œ ì‚­ì œ"""
        for item in self.scene.selectedItems():
            if isinstance(item, Node):
                self.view.delete_node(item)
            elif isinstance(item, Connection):
                item.remove()
            elif isinstance(item, MemoItem):
                self.scene.removeItem(item)
                
    def toggle_grid(self, checked):
        """ê·¸ë¦¬ë“œ í‘œì‹œ í† ê¸€"""
        self.scene.grid_visible = checked
        self.scene.update()
        
    def fit_view(self):
        """ì „ì²´ ë³´ê¸°"""
        self.view.fitInView(self.scene.itemsBoundingRect(), Qt.KeepAspectRatio)
        self.view.zoom_level = 0
        
    def reset_zoom(self):
        """ì¤Œ ì´ˆê¸°í™”"""
        self.view.resetTransform()
        self.view.zoom_level = 0
        
    def validate_pipeline(self):
        """íŒŒì´í”„ë¼ì¸ ê²€ì¦"""
        errors = []
        warnings = []
        
        # ë…¸ë“œ ìˆ˜ì§‘
        nodes = [item for item in self.scene.items() if isinstance(item, Node)]
        
        if not nodes:
            errors.append("ë…¸ë“œê°€ ì—†ìŠµë‹ˆë‹¤")
        else:
            # ë°ì´í„° ì…ë ¥ ë…¸ë“œ í™•ì¸
            data_nodes = [n for n in nodes if n.node_type == NodeType.DATA]
            if not data_nodes:
                errors.append("ë°ì´í„° ì…ë ¥ ë…¸ë“œê°€ í•„ìš”í•©ë‹ˆë‹¤")
                
            # ì˜ˆì¸¡ ëª¨ë¸ ë…¸ë“œ í™•ì¸ (LSTM, RNN, ARIMA ì¤‘ í•˜ë‚˜)
            model_nodes = [n for n in nodes if n.node_type == NodeType.MODEL]
            if not model_nodes:
                errors.append("ì˜ˆì¸¡ ëª¨ë¸ ë…¸ë“œê°€ ìµœì†Œ í•˜ë‚˜ í•„ìš”í•©ë‹ˆë‹¤")
                
            # ë¯¸ì„¤ì • ë…¸ë“œ í™•ì¸
            unconfigured = [n.name for n in nodes if not n.is_configured]
            if unconfigured:
                warnings.append(f"ë¯¸ì„¤ì • ë…¸ë“œ: {', '.join(unconfigured)}")
                
            # ì—°ê²° í™•ì¸
            for node in nodes:
                if node.node_type != NodeType.DATA:
                    has_input = any(port.connections for port in node.input_ports)
                    if not has_input:
                        warnings.append(f"{node.name}ì— ì…ë ¥ì´ ì—†ìŠµë‹ˆë‹¤")
                        
        # ê²°ê³¼ í‘œì‹œ
        if errors or warnings:
            msg = ""
            if errors:
                msg += "ì˜¤ë¥˜:\n" + "\n".join(f"- {e}" for e in errors) + "\n\n"
            if warnings:
                msg += "ê²½ê³ :\n" + "\n".join(f"- {w}" for w in warnings)
                
            QMessageBox.warning(self, "ê²€ì¦ ê²°ê³¼", msg)
            self.log("íŒŒì´í”„ë¼ì¸ ê²€ì¦ ì‹¤íŒ¨")
        else:
            QMessageBox.information(self, "ê²€ì¦ ê²°ê³¼", "íŒŒì´í”„ë¼ì¸ì´ ìœ íš¨í•©ë‹ˆë‹¤!")
            self.log("íŒŒì´í”„ë¼ì¸ ê²€ì¦ ì„±ê³µ")
            
    def run_pipeline(self):
        """íŒŒì´í”„ë¼ì¸ ì‹¤í–‰"""
        # ê²€ì¦
        self.validate_pipeline()

        self.log("íŒŒì´í”„ë¼ì¸ ì‹¤í–‰ ì‹œì‘...")
        
        # ë…¸ë“œ ì‹¤í–‰ ìˆœì„œ ê²°ì •
        execution_order = self.determine_execution_order()
        
        # ì‹¤í–‰ ê²°ê³¼ ì €ì¥
        node_outputs = {}
        
        # ìˆœì°¨ì ìœ¼ë¡œ ë…¸ë“œ ì‹¤í–‰
        for node in execution_order:
            self.log(f"ì‹¤í–‰ ì¤‘: {node.name}")
            
            # ì…ë ¥ ë°ì´í„° ìˆ˜ì§‘
            input_data = {}
            for port in node.input_ports:
                for connection in port.connections:
                    source_node = connection.start_port.parentItem()
                    if source_node in node_outputs:
                        input_data[source_node.node_type.value] = node_outputs[source_node]
            
            # ë…¸ë“œ ì‹¤í–‰
            output = self.execute_node(node, input_data)
            node_outputs[node] = output
        
        # ìµœì¢… ê²°ê³¼ í‘œì‹œ
        self.show_execution_results(node_outputs)
        
    def determine_execution_order(self):
        """ë…¸ë“œ ì‹¤í–‰ ìˆœì„œ ê²°ì • (ìœ„ìƒ ì •ë ¬)"""
        nodes = [item for item in self.scene.items() if isinstance(item, Node)]
        
        # ì§„ì… ì°¨ìˆ˜ ê³„ì‚°
        in_degree = {node: 0 for node in nodes}
        for node in nodes:
            for port in node.input_ports:
                in_degree[node] += len(port.connections)
        
        # ì§„ì… ì°¨ìˆ˜ê°€ 0ì¸ ë…¸ë“œë¶€í„° ì‹œì‘
        queue = [node for node in nodes if in_degree[node] == 0]
        execution_order = []
        
        while queue:
            current = queue.pop(0)
            execution_order.append(current)
            
            # ì—°ê²°ëœ ë‹¤ìŒ ë…¸ë“œë“¤ì˜ ì§„ì… ì°¨ìˆ˜ ê°ì†Œ
            for port in current.output_ports:
                for connection in port.connections:
                    next_node = connection.end_port.parentItem()
                    in_degree[next_node] -= 1
                    if in_degree[next_node] == 0:
                        queue.append(next_node)
        
        return execution_order
        
    def execute_node(self, node, input_data):
        """ê°œë³„ ë…¸ë“œ ì‹¤í–‰ - í†µí•© MCS ì‹œë®¬ë ˆì´ì…˜"""
        import random
        import numpy as np
        from datetime import datetime, timedelta
        
        output = {}
        
        if node.node_type == NodeType.DATA:
            # ë°ì´í„° ë¡œë“œ ì‹œë®¬ë ˆì´ì…˜
            if "MCS" in node.name:
                output = {
                    "data": "í†µí•© MCS ë°ì´í„° ë¡œë“œë¨",
                    "records": 10000,
                    "time_range": "2025-07-01 00:00 ~ 2025-07-30 23:59",
                    "fab_lines": ["FAB1", "FAB2", "FAB3"],
                    "event_types": ["TRANSFER", "PROCESS", "SENSOR_UPDATE", "ALARM"],
                    "sensor_records": 3234,
                    "alarm_records": 156,
                    "columns": ["timestamp", "event_type", "equipment_id", "sensor_vibration_mm_s", 
                               "sensor_temperature_c", "sensor_pressure_torr", "sensor_particle_count"]
                }
                
        elif node.node_type == NodeType.PREPROCESS:
            # ì „ì²˜ë¦¬ ì‹¤í–‰
            if "ì„¼ì„œ ì¶”ì¶œ" in node.name:
                output = {
                    "extracted_data": "ì„¼ì„œ ë°ì´í„° ì¶”ì¶œ ì™„ë£Œ",
                    "sensor_records": 3234,
                    "sensors": {
                        "vibration": 3234,
                        "temperature": 3100,
                        "pressure": 2890,
                        "particle": 2450
                    },
                    "anomaly_count": 89,
                    "equipment_count": 45
                }
            elif "ì´ë²¤íŠ¸ í•„í„°" in node.name:
                output = {
                    "filtered_data": "ì´ë²¤íŠ¸ í•„í„°ë§ ì™„ë£Œ",
                    "original_records": 10000,
                    "filtered_records": 6543,
                    "filtered_events": node.settings.get("filtered_events", ["SENSOR_UPDATE", "PROCESS"])
                }
            elif "ì´ìƒì¹˜" in node.name:
                output = {
                    "cleaned_data": "ì´ìƒì¹˜ ì œê±° ì™„ë£Œ",
                    "removed": 156,
                    "method": node.settings.get("method", "IQR"),
                    "anomaly_details": {
                        "vibration": 45,
                        "temperature": 67,
                        "particle": 44
                    }
                }
            elif "ì‹œê°„ë³„" in node.name:
                output = {
                    "aggregated_data": "ì‹œê°„ë³„ ì§‘ê³„ ì™„ë£Œ",
                    "time_unit": node.settings.get("time_unit", "1ì‹œê°„"),
                    "records": 720,  # 30ì¼ * 24ì‹œê°„
                    "aggregation": node.settings.get("aggregation", "í‰ê· ")
                }
            elif "ë² ì´ë³„" in node.name:
                output = {
                    "grouped_data": "ë² ì´ë³„ ë¶„ë¥˜ ì™„ë£Œ",
                    "bays": ["PHOTO", "ETCH", "CVD", "CMP"],
                    "distribution": {"PHOTO": 35, "ETCH": 30, "CVD": 20, "CMP": 15}
                }
            elif "ì¥ë¹„ë³„" in node.name:
                output = {
                    "equipment_grouped": "ì¥ë¹„ë³„ ë¶„ë¥˜ ì™„ë£Œ",
                    "equipment_count": 45,
                    "top_equipment": [
                        {"id": "ASML_NXT_1980", "events": 1234},
                        {"id": "LAM_KIYO_01", "events": 987},
                        {"id": "AMAT_CENTURA_01", "events": 876}
                    ]
                }
                
        elif node.node_type == NodeType.VECTOR:
            # RAG ë²¡í„° ì €ì¥
            output = {
                "vector_store": node.settings.get("vector_store", "ChromaDB"),
                "embeddings": "ë²¡í„° ì €ì¥ ì™„ë£Œ",
                "dimension": node.settings.get("vector_dim", 768),
                "total_vectors": 1234,
                "vector_types": {
                    "event_patterns": 456,
                    "sensor_patterns": 678,
                    "alarm_patterns": 100
                }
            }
            
        elif node.node_type == NodeType.MODEL:
            # ë”¥ëŸ¬ë‹ ëª¨ë¸ ì‹¤í–‰
            if "LSTM" in node.name:
                # LSTM ëª¨ë¸ë¡œ ì´ì†¡ ì‹œê°„ ì˜ˆì¸¡
                prediction_target = node.settings.get("prediction_target", "ì´ì†¡ ì‹œê°„")
                period = node.settings.get("period", "1ì‹œê°„")
                
                # ì‹œê³„ì—´ ì˜ˆì¸¡ ìƒì„±
                base_time = 185  # ê¸°ë³¸ ì´ì†¡ ì‹œê°„(ì´ˆ)
                predictions = []
                confidence_scores = []
                
                # ì‹œê°„ëŒ€ë³„ ì˜ˆì¸¡ ìƒì„±
                time_periods = ["10ë¶„", "30ë¶„", "1ì‹œê°„", "4ì‹œê°„", "1ì¼"]
                for tp in time_periods:
                    # ì‹œê°„ì´ ê¸¸ìˆ˜ë¡ ë¶ˆí™•ì‹¤ì„± ì¦ê°€
                    uncertainty = time_periods.index(tp) * 0.05
                    pred_time = base_time + random.gauss(0, 10 + uncertainty * 20)
                    conf = max(0.70, 0.95 - uncertainty)
                    
                    predictions.append({
                        "period": tp,
                        "predicted_time": round(pred_time, 1),
                        "confidence": round(conf, 3),
                        "range": f"{round(pred_time * 0.9, 1)} ~ {round(pred_time * 1.1, 1)}ì´ˆ"
                    })
                
                output = {
                    "model": "LSTM (Long Short-Term Memory)",
                    "prediction_target": prediction_target,
                    "model_accuracy": 94.2,
                    "training_epochs": 100,
                    "predictions": predictions,
                    "key_factors": [
                        "í˜„ì¬ OHT ê°€ë™ë¥ : 87.3%",
                        "PHOTO ë² ì´ ëŒ€ê¸°: 15ëŒ€",
                        "ìµœê·¼ ì•ŒëŒ ë¹ˆë„: ì¦ê°€ ì¶”ì„¸"
                    ],
                    "recommendation": "PHOTO ë² ì´ ìš°íšŒ ê²½ë¡œ í™œì„±í™” ê¶Œì¥",
                    "model_params": {
                        "layers": node.settings.get("layers", 3),
                        "units": node.settings.get("units", 128),
                        "dropout": 0.2,
                        "optimizer": "adam"
                    }
                }
                
            elif "RNN" in node.name:
                # RNN ëª¨ë¸ë¡œ ë³‘ëª© ì˜ˆì¸¡
                prediction_target = node.settings.get("prediction_target", "ë³‘ëª© ë°œìƒ í™•ë¥ ")
                
                # ë² ì´ë³„ ë³‘ëª© ì˜ˆì¸¡
                bays = ["PHOTO", "ETCH", "CVD", "PVD", "CMP", "CLEAN", "DIFF", "IMPLANT"]
                bottleneck_predictions = []
                
                for bay in bays:
                    # ê° ë² ì´ë³„ ë³‘ëª© í™•ë¥  ê³„ì‚°
                    base_prob = random.uniform(0.1, 0.8)
                    if bay in ["PHOTO", "ETCH"]:  # ì£¼ìš” ë³‘ëª© êµ¬ê°„
                        base_prob += 0.3
                    
                    prob = min(0.95, base_prob)
                    severity = "HIGH" if prob > 0.7 else "MEDIUM" if prob > 0.4 else "LOW"
                    
                    bottleneck_predictions.append({
                        "bay": bay,
                        "probability": round(prob, 3),
                        "severity": severity,
                        "queue_prediction": round(prob * 20),  # ì˜ˆìƒ ëŒ€ê¸° ëŒ€ìˆ˜
                        "impact_time": f"{round(prob * 30)}ë¶„"  # ì˜ˆìƒ ì§€ì—° ì‹œê°„
                    })
                
                # ì‹œê°„ëŒ€ë³„ ë³‘ëª© íŒ¨í„´
                hourly_pattern = []
                for hour in range(24):
                    peak_hours = [10, 11, 14, 15, 16]  # ì˜¤ì „/ì˜¤í›„ í”¼í¬ ì‹œê°„
                    if hour in peak_hours:
                        intensity = random.uniform(0.7, 0.9)
                    else:
                        intensity = random.uniform(0.3, 0.6)
                    
                    hourly_pattern.append({
                        "hour": f"{hour:02d}:00",
                        "bottleneck_intensity": round(intensity, 2)
                    })
                
                output = {
                    "model": "RNN (Recurrent Neural Network)",
                    "prediction_target": prediction_target,
                    "model_accuracy": 89.7,
                    "bottleneck_predictions": sorted(bottleneck_predictions, 
                                                   key=lambda x: x["probability"], 
                                                   reverse=True),
                    "hourly_pattern": hourly_pattern,
                    "peak_times": ["10:00-12:00", "14:00-17:00"],
                    "critical_bays": [bp["bay"] for bp in bottleneck_predictions if bp["severity"] == "HIGH"],
                    "recommendations": [
                        "PHOTO ë² ì´ ì²˜ë¦¬ ì†ë„ í–¥ìƒ í•„ìš”",
                        "14:00-17:00 ì‹œê°„ëŒ€ ì¶”ê°€ OHT íˆ¬ì… ê¶Œì¥",
                        "ETCH ë² ì´ ì˜ˆë°©ì •ë¹„ ì¼ì • ì¡°ì • ê²€í† "
                    ],
                    "model_params": {
                        "layers": node.settings.get("layers", 3),
                        "units": node.settings.get("units", 128),
                        "sequence_length": 24,
                        "batch_size": 32
                    }
                }
                
            elif "ARIMA" in node.name:
                # ARIMA ëª¨ë¸ë¡œ ì²˜ë¦¬ëŸ‰ ì˜ˆì¸¡
                prediction_target = node.settings.get("prediction_target", "ì‹œê°„ë‹¹ ì²˜ë¦¬ëŸ‰")
                
                # ARIMA íŒŒë¼ë¯¸í„°
                p = node.settings.get("p", 2)  # ìê¸°íšŒê·€
                d = node.settings.get("d", 1)  # ì°¨ë¶„
                q = node.settings.get("q", 2)  # ì´ë™í‰ê· 
                
                # ê³¼ê±° ì²˜ë¦¬ëŸ‰ ë°ì´í„° (ì‹œë®¬ë ˆì´ì…˜)
                historical_data = []
                base_throughput = 150  # ì‹œê°„ë‹¹ ê¸°ë³¸ ì²˜ë¦¬ëŸ‰
                
                for i in range(168):  # ì§€ë‚œ 1ì£¼ì¼ (168ì‹œê°„)
                    # ì£¼ê¸°ì  íŒ¨í„´ + ë…¸ì´ì¦ˆ
                    hour_of_day = i % 24
                    day_of_week = (i // 24) % 7
                    
                    # ì‹œê°„ëŒ€ë³„ ë³€ë™
                    if 6 <= hour_of_day <= 22:  # ì£¼ê°„
                        throughput = base_throughput + random.gauss(0, 10)
                    else:  # ì•¼ê°„
                        throughput = base_throughput * 0.7 + random.gauss(0, 5)
                    
                    # ì£¼ë§ íš¨ê³¼
                    if day_of_week in [5, 6]:  # í† , ì¼
                        throughput *= 0.8
                    
                    historical_data.append({
                        "hour": i,
                        "throughput": round(throughput, 1)
                    })
                
                # ë¯¸ë˜ ì˜ˆì¸¡
                forecast_periods = 48  # í–¥í›„ 48ì‹œê°„
                forecasts = []
                
                for i in range(forecast_periods):
                    # ARIMA ëª¨ë¸ ì‹œë®¬ë ˆì´ì…˜
                    trend = base_throughput
                    seasonal = 10 * np.sin(2 * np.pi * i / 24)  # ì¼ì¼ ì£¼ê¸°
                    ar_component = 0.7 * (historical_data[-1]["throughput"] - base_throughput) if historical_data else 0
                    ma_component = random.gauss(0, 5)
                    
                    forecast_value = trend + seasonal + ar_component + ma_component
                    
                    # ì‹ ë¢° êµ¬ê°„
                    std_error = 5 + i * 0.2  # ì‹œê°„ì´ ì§€ë‚ ìˆ˜ë¡ ë¶ˆí™•ì‹¤ì„± ì¦ê°€
                    lower_bound = forecast_value - 1.96 * std_error
                    upper_bound = forecast_value + 1.96 * std_error
                    
                    forecasts.append({
                        "hour": i + 1,
                        "forecast": round(forecast_value, 1),
                        "lower_95": round(lower_bound, 1),
                        "upper_95": round(upper_bound, 1),
                        "confidence": round(max(0.7, 0.95 - i * 0.01), 2)
                    })
                
                # í†µê³„ ìš”ì•½
                avg_forecast = np.mean([f["forecast"] for f in forecasts])
                
                output = {
                    "model": "ARIMA (AutoRegressive Integrated Moving Average)",
                    "model_notation": f"ARIMA({p},{d},{q})",
                    "prediction_target": prediction_target,
                    "model_metrics": {
                        "aic": 1234.56,
                        "bic": 1256.78,
                        "mape": 5.2,  # Mean Absolute Percentage Error
                        "rmse": 7.8   # Root Mean Square Error
                    },
                    "historical_summary": {
                        "mean": round(np.mean([h["throughput"] for h in historical_data]), 1),
                        "std": round(np.std([h["throughput"] for h in historical_data]), 1),
                        "min": round(min([h["throughput"] for h in historical_data]), 1),
                        "max": round(max([h["throughput"] for h in historical_data]), 1)
                    },
                    "forecast_summary": {
                        "next_24h_avg": round(np.mean([f["forecast"] for f in forecasts[:24]]), 1),
                        "next_48h_avg": round(avg_forecast, 1),
                        "peak_forecast": round(max([f["forecast"] for f in forecasts]), 1),
                        "valley_forecast": round(min([f["forecast"] for f in forecasts]), 1)
                    },
                    "forecasts": forecasts[:24],  # ì²˜ìŒ 24ì‹œê°„ë§Œ í‘œì‹œ
                    "insights": [
                        f"í–¥í›„ 24ì‹œê°„ í‰ê·  ì²˜ë¦¬ëŸ‰: {round(np.mean([f['forecast'] for f in forecasts[:24]]), 1)} ì›¨ì´í¼/ì‹œê°„",
                        f"ì˜ˆìƒ ì¼ì¼ ìƒì‚°ëŸ‰: {round(np.sum([f['forecast'] for f in forecasts[:24]]), 0)} ì›¨ì´í¼",
                        "ì£¼ê°„ ì‹œê°„ëŒ€(06:00-22:00) ì²˜ë¦¬ëŸ‰ì´ ì•¼ê°„ ëŒ€ë¹„ 40% ë†’ìŒ",
                        "ì£¼ë§ ì²˜ë¦¬ëŸ‰ì€ í‰ì¼ ëŒ€ë¹„ 20% ê°ì†Œ ì˜ˆìƒ"
                    ],
                    "recommendations": [
                        "ì•¼ê°„ ì‹œê°„ëŒ€ ìƒì‚°ì„± í–¥ìƒ ë°©ì•ˆ ê²€í†  í•„ìš”",
                        "ì£¼ë§ ê°€ë™ë¥  ê°œì„ ì„ ìœ„í•œ ì¸ë ¥ ë°°ì¹˜ ìµœì í™”",
                        "í”¼í¬ ì‹œê°„ëŒ€ ë³‘ëª© í˜„ìƒ ëŒ€ë¹„ ë²„í¼ í™•ë³´"
                    ]
                }
                
            elif "ì„¼ì„œì´ìƒíƒì§€" in node.name:
                # ì„¼ì„œ ì´ìƒ íƒì§€ ëª¨ë¸
                target = node.settings.get("prediction_target", "ë³µí•© ì´ìƒ")
                algorithm = node.settings.get("anomaly_algorithm", "Isolation Forest")
                sensitivity = node.settings.get("sensitivity", 0.8)
                
                # ì´ìƒ íƒì§€ ê²°ê³¼ ìƒì„±
                anomalies = []
                equipment_list = [
                    "ASML_NXT_1980", "ASML_NXT_2050", "LAM_KIYO_01", 
                    "AMAT_CENTURA_01", "TEL_ETCH_01", "AMAT_ENDURA_01"
                ]
                
                for eq in equipment_list:
                    # ê° ì¥ë¹„ë³„ ì„¼ì„œ ì´ìƒ í™•ë¥ 
                    if random.random() < 0.3:  # 30% í™•ë¥ ë¡œ ì´ìƒ ë°œìƒ
                        sensor_type = random.choice(["vibration", "temperature", "pressure", "particle"])
                        
                        # ì„¼ì„œë³„ ì •ìƒ ë²”ìœ„
                        normal_ranges = {
                            "vibration": (0.5, 2.0),
                            "temperature": (20, 30),
                            "pressure": (750, 760),
                            "particle": (10, 100)
                        }
                        
                        # ì´ìƒê°’ ìƒì„±
                        normal_min, normal_max = normal_ranges[sensor_type]
                        if random.random() < 0.5:  # í•˜í•œ ì´íƒˆ
                            value = normal_min * random.uniform(0.3, 0.8)
                        else:  # ìƒí•œ ì´íƒˆ
                            value = normal_max * random.uniform(1.2, 2.0)
                        
                        # ì´ìƒ ì ìˆ˜ ê³„ì‚°
                        anomaly_score = min(0.99, abs(value - (normal_min + normal_max) / 2) / 
                                          ((normal_max - normal_min) / 2) * sensitivity)
                        
                        anomalies.append({
                            "equipment_id": eq,
                            "sensor_type": sensor_type,
                            "current_value": round(value, 2),
                            "normal_range": f"{normal_min} ~ {normal_max}",
                            "anomaly_score": round(anomaly_score, 3),
                            "severity": "CRITICAL" if anomaly_score > 0.8 else "HIGH" if anomaly_score > 0.6 else "MEDIUM",
                            "detected_at": datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
                            "pattern": random.choice(["ê¸‰ê²©í•œ ìƒìŠ¹", "ì§€ì†ì  ì¦ê°€", "ì£¼ê¸°ì  ì´ìƒ", "ê°„í—ì  ìŠ¤íŒŒì´í¬"])
                        })
                
                # ì´ìƒ íŒ¨í„´ ë¶„ì„
                pattern_analysis = {
                    "total_anomalies": len(anomalies),
                    "critical_count": len([a for a in anomalies if a["severity"] == "CRITICAL"]),
                    "sensor_distribution": {},
                    "equipment_health_score": {}
                }
                
                # ì„¼ì„œë³„ ë¶„í¬
                for sensor in ["vibration", "temperature", "pressure", "particle"]:
                    count = len([a for a in anomalies if a["sensor_type"] == sensor])
                    pattern_analysis["sensor_distribution"][sensor] = count
                
                # ì¥ë¹„ë³„ ê±´ê°•ë„ ì ìˆ˜
                for eq in equipment_list:
                    eq_anomalies = [a for a in anomalies if a["equipment_id"] == eq]
                    if eq_anomalies:
                        health_score = max(0, 100 - len(eq_anomalies) * 20 - 
                                         sum([a["anomaly_score"] * 10 for a in eq_anomalies]))
                    else:
                        health_score = 100
                    pattern_analysis["equipment_health_score"][eq] = round(health_score, 1)
                
                output = {
                    "model": "ì„¼ì„œ ì´ìƒíƒì§€ (Anomaly Detection)",
                    "algorithm": algorithm,
                    "target": target,
                    "sensitivity": f"{int(sensitivity * 100)}%",
                    "detection_results": {
                        "anomalies_detected": anomalies,
                        "pattern_analysis": pattern_analysis,
                        "risk_assessment": {
                            "immediate_action_required": [a["equipment_id"] for a in anomalies if a["severity"] == "CRITICAL"],
                            "monitoring_required": [a["equipment_id"] for a in anomalies if a["severity"] == "HIGH"],
                            "maintenance_schedule": [a["equipment_id"] for a in anomalies if a["severity"] == "MEDIUM"]
                        }
                    },
                    "predictive_maintenance": {
                        "failure_probability_24h": {eq: round(min(0.95, len([a for a in anomalies if a["equipment_id"] == eq]) * 0.25), 2) 
                                                   for eq in equipment_list if any(a["equipment_id"] == eq for a in anomalies)},
                        "recommended_actions": [
                            f"{a['equipment_id']}: {a['sensor_type']} ì„¼ì„œ ì ê²€ í•„ìš” (ì´ìƒ ì ìˆ˜: {a['anomaly_score']})"
                            for a in sorted(anomalies, key=lambda x: x['anomaly_score'], reverse=True)[:3]
                        ]
                    },
                    "model_performance": {
                        "precision": 0.92,
                        "recall": 0.88,
                        "f1_score": 0.90,
                        "false_positive_rate": 0.08
                    }
                }
                
        elif node.node_type == NodeType.ANALYSIS:
            # íŒ¨í„´ ë¶„ì„
            if "OHT" in node.name:
                output = {
                    "patterns": [
                        "ê²½ë¡œ A-B êµ¬ê°„ ì£¼ê¸°ì  ì •ì²´",
                        "ì˜¤í›„ 2-4ì‹œ ì´ì†¡ ì§€ì—° ì¦ê°€",
                        "FAB2 ë¼ì¸ OHT ê°€ë™ë¥  ì €í•˜"
                    ],
                    "avg_transfer_time": 185,  # ì´ˆ
                    "congestion_points": ["NODE_A23", "NODE_B45"],
                    "utilization": 87.3
                }
            elif "ê°€ë™ë¥ " in node.name:
                output = {
                    "equipment_utilization": {
                        "PHOTO": 92.3,
                        "ETCH": 87.5,
                        "CVD": 78.2,
                        "PVD": 85.1,
                        "CMP": 89.7
                    },
                    "below_target": ["CVD"],
                    "maintenance_required": ["CVD_03", "ETCH_07"]
                }
            elif "ë³‘ëª©" in node.name:
                output = {
                    "bottlenecks": [
                        {"location": "PHOTO_BAY", "queue_size": 15, "wait_time": 23},
                        {"location": "CVD_LOADPORT_02", "queue_size": 8, "wait_time": 12}
                    ],
                    "recommendations": ["PHOTO ë² ì´ ì²˜ë¦¬ ì†ë„ í–¥ìƒ í•„ìš”", "CVD ë¡œë“œí¬íŠ¸ ì¶”ê°€ ê²€í† "]
                }
            elif "ì„¼ì„œíŠ¸ë Œë“œ" in node.name:
                output = {
                    "trends": {
                        "vibration": {"trend": "increasing", "rate": 0.05, "alert": True},
                        "temperature": {"trend": "stable", "rate": 0.01, "alert": False},
                        "particle": {"trend": "cyclic", "period": "24h", "alert": False}
                    },
                    "predictions": {
                        "vibration_24h": 2.8,
                        "maintenance_window": "72ì‹œê°„ ì´ë‚´"
                    },
                    "method": node.settings.get("trend_method", "ì´ë™í‰ê· ")
                }
                
        return output
        
    def show_execution_results(self, node_outputs):
        """ì‹¤í–‰ ê²°ê³¼ í‘œì‹œ - ë”¥ëŸ¬ë‹ ëª¨ë¸ ì¤‘ì‹¬"""
        result_dialog = QDialog(self)
        result_dialog.setWindowTitle("ë”¥ëŸ¬ë‹ ì˜ˆì¸¡ ê²°ê³¼")
        result_dialog.setModal(True)
        layout = QVBoxLayout()
        
        # íƒ­ ìœ„ì ¯ìœ¼ë¡œ ê²°ê³¼ í‘œì‹œ
        tabs = QTabWidget()
        
        # ë”¥ëŸ¬ë‹ ëª¨ë¸ ê²°ê³¼ ìˆ˜ì§‘
        lstm_result = None
        rnn_result = None
        arima_result = None
        anomaly_result = None
        
        for node, output in node_outputs.items():
            if node.node_type == NodeType.MODEL:
                if "LSTM" in node.name:
                    lstm_result = output
                elif "RNN" in node.name:
                    rnn_result = output
                elif "ARIMA" in node.name:
                    arima_result = output
                elif "ì„¼ì„œì´ìƒíƒì§€" in node.name:
                    anomaly_result = output
        
        # ì¢…í•© ì˜ˆì¸¡ íƒ­
        summary_text = QTextEdit()
        summary_text.setReadOnly(True)
        
        summary_content = "=" * 60 + "\n"
        summary_content += "ë°˜ë„ì²´ FAB MCS ë”¥ëŸ¬ë‹ ì˜ˆì¸¡ ì¢…í•© ê²°ê³¼\n"
        summary_content += "=" * 60 + "\n\n"
        summary_content += f"ë¶„ì„ ì‹œì : {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n\n"
        
        # LSTM ê²°ê³¼
        if lstm_result:
            summary_content += "ã€ LSTM ì´ì†¡ì‹œê°„ ì˜ˆì¸¡ ã€‘\n"
            summary_content += f"ëª¨ë¸ ì •í™•ë„: {lstm_result['model_accuracy']}%\n\n"
            for pred in lstm_result['predictions'][:3]:  # ì£¼ìš” 3ê°œë§Œ
                summary_content += f"  â€¢ {pred['period']} í›„: {pred['predicted_time']}ì´ˆ "
                summary_content += f"(ì‹ ë¢°ë„: {pred['confidence']*100:.1f}%)\n"
            summary_content += f"\nê¶Œì¥ì‚¬í•­: {lstm_result['recommendation']}\n"
            summary_content += "-" * 40 + "\n\n"
        
        # RNN ê²°ê³¼
        if rnn_result:
            summary_content += "ã€ RNN ë³‘ëª© ì˜ˆì¸¡ ã€‘\n"
            summary_content += f"ëª¨ë¸ ì •í™•ë„: {rnn_result['model_accuracy']}%\n\n"
            summary_content += "ì£¼ìš” ë³‘ëª© êµ¬ê°„:\n"
            for bp in rnn_result['bottleneck_predictions'][:3]:  # ìƒìœ„ 3ê°œ
                summary_content += f"  â€¢ {bp['bay']}: {bp['probability']*100:.1f}% "
                summary_content += f"({bp['severity']}) - ì˜ˆìƒ ëŒ€ê¸°: {bp['queue_prediction']}ëŒ€\n"
            summary_content += f"\ní”¼í¬ ì‹œê°„ëŒ€: {', '.join(rnn_result['peak_times'])}\n"
            summary_content += "-" * 40 + "\n\n"
        
        # ARIMA ê²°ê³¼
        if arima_result:
            summary_content += "ã€ ARIMA ì²˜ë¦¬ëŸ‰ ì˜ˆì¸¡ ã€‘\n"
            summary_content += f"ëª¨ë¸: {arima_result['model_notation']}\n"
            summary_content += f"MAPE: {arima_result['model_metrics']['mape']}%\n\n"
            summary_content += f"í–¥í›„ 24ì‹œê°„ í‰ê·  ì²˜ë¦¬ëŸ‰: {arima_result['forecast_summary']['next_24h_avg']} ì›¨ì´í¼/ì‹œê°„\n"
            summary_content += f"ì˜ˆìƒ ì¼ì¼ ìƒì‚°ëŸ‰: {round(arima_result['forecast_summary']['next_24h_avg'] * 24)} ì›¨ì´í¼\n"
            summary_content += "\nì£¼ìš” ì¸ì‚¬ì´íŠ¸:\n"
            for insight in arima_result['insights'][:2]:
                summary_content += f"  â€¢ {insight}\n"
            summary_content += "-" * 40 + "\n\n"
        
        # ì„¼ì„œ ì´ìƒíƒì§€ ê²°ê³¼
        if anomaly_result:
            summary_content += "ã€ ì„¼ì„œ ì´ìƒíƒì§€ ã€‘\n"
            summary_content += f"ì•Œê³ ë¦¬ì¦˜: {anomaly_result['algorithm']}\n"
            summary_content += f"íƒì§€ ë¯¼ê°ë„: {anomaly_result['sensitivity']}\n\n"
            
            results = anomaly_result['detection_results']
            summary_content += f"ì´ ì´ìƒ ê°ì§€: {results['pattern_analysis']['total_anomalies']}ê±´\n"
            summary_content += f"ìœ„í—˜ ìˆ˜ì¤€: {results['pattern_analysis']['critical_count']}ê±´\n\n"
            
            if results['risk_assessment']['immediate_action_required']:
                summary_content += "ì¦‰ì‹œ ì¡°ì¹˜ í•„ìš” ì¥ë¹„:\n"
                for eq in results['risk_assessment']['immediate_action_required']:
                    summary_content += f"  â€¢ {eq}\n"
            summary_content += "\n"
        
        summary_content += "=" * 60 + "\n"
        summary_content += "ã€ ì¢…í•© ê¶Œì¥ì‚¬í•­ ã€‘\n"
        summary_content += "=" * 60 + "\n"
        
        recommendations = []
        
        # ê° ëª¨ë¸ì˜ ê¶Œì¥ì‚¬í•­ í†µí•©
        if lstm_result:
            recommendations.append(lstm_result.get('recommendation', ''))
        if rnn_result and 'recommendations' in rnn_result:
            recommendations.extend(rnn_result['recommendations'][:2])
        if arima_result and 'recommendations' in arima_result:
            recommendations.extend(arima_result['recommendations'][:2])
        if anomaly_result:
            pm = anomaly_result.get('predictive_maintenance', {})
            if 'recommended_actions' in pm:
                recommendations.extend(pm['recommended_actions'][:2])
        
        for i, rec in enumerate(recommendations, 1):
            if rec:
                summary_content += f"{i}. {rec}\n"
        
        summary_text.setPlainText(summary_content)
        tabs.addTab(summary_text, "ì¢…í•© ì˜ˆì¸¡ ê²°ê³¼")
        
        # LSTM ìƒì„¸ íƒ­
        if lstm_result:
            lstm_text = QTextEdit()
            lstm_text.setReadOnly(True)
            lstm_content = "LSTM ì´ì†¡ì‹œê°„ ì˜ˆì¸¡ ìƒì„¸ ê²°ê³¼\n" + "=" * 50 + "\n\n"
            lstm_content += json.dumps(lstm_result, indent=2, ensure_ascii=False)
            lstm_text.setPlainText(lstm_content)
            tabs.addTab(lstm_text, "LSTM ì˜ˆì¸¡")
        
        # RNN ìƒì„¸ íƒ­
        if rnn_result:
            rnn_text = QTextEdit()
            rnn_text.setReadOnly(True)
            rnn_content = "RNN ë³‘ëª© ì˜ˆì¸¡ ìƒì„¸ ê²°ê³¼\n" + "=" * 50 + "\n\n"
            rnn_content += json.dumps(rnn_result, indent=2, ensure_ascii=False)
            rnn_text.setPlainText(rnn_content)
            tabs.addTab(rnn_text, "RNN ì˜ˆì¸¡")
        
        # ARIMA ìƒì„¸ íƒ­
        if arima_result:
            arima_text = QTextEdit()
            arima_text.setReadOnly(True)
            arima_content = "ARIMA ì²˜ë¦¬ëŸ‰ ì˜ˆì¸¡ ìƒì„¸ ê²°ê³¼\n" + "=" * 50 + "\n\n"
            arima_content += json.dumps(arima_result, indent=2, ensure_ascii=False)
            arima_text.setPlainText(arima_content)
            tabs.addTab(arima_text, "ARIMA ì˜ˆì¸¡")
        
        # ì„¼ì„œ ì´ìƒíƒì§€ ìƒì„¸ íƒ­
        if anomaly_result:
            anomaly_text = QTextEdit()
            anomaly_text.setReadOnly(True)
            anomaly_content = "ì„¼ì„œ ì´ìƒíƒì§€ ìƒì„¸ ê²°ê³¼\n" + "=" * 50 + "\n\n"
            anomaly_content += json.dumps(anomaly_result, indent=2, ensure_ascii=False)
            anomaly_text.setPlainText(anomaly_content)
            tabs.addTab(anomaly_text, "ì´ìƒíƒì§€")
        
        # ì „ì²´ ë…¸ë“œ ì‹¤í–‰ ê²°ê³¼ íƒ­
        all_results_text = QTextEdit()
        all_results_text.setReadOnly(True)
        all_content = "ì „ì²´ íŒŒì´í”„ë¼ì¸ ì‹¤í–‰ ê²°ê³¼\n" + "=" * 50 + "\n\n"
        
        for node, output in node_outputs.items():
            all_content += f"ã€{node.name}ã€‘\n"
            all_content += json.dumps(output, indent=2, ensure_ascii=False)
            all_content += "\n\n" + "-" * 40 + "\n\n"
        
        all_results_text.setPlainText(all_content)
        tabs.addTab(all_results_text, "ì „ì²´ ê²°ê³¼")
        
        layout.addWidget(tabs)
        
        # ë²„íŠ¼ ë ˆì´ì•„ì›ƒ
        button_layout = QHBoxLayout()
        
        # ê²°ê³¼ ì €ì¥ ë²„íŠ¼
        save_btn = QPushButton("ê²°ê³¼ ì €ì¥")
        save_btn.clicked.connect(lambda: self.save_results(node_outputs))
        button_layout.addWidget(save_btn)
        
        # ë¦¬í¬íŠ¸ ìƒì„± ë²„íŠ¼
        report_btn = QPushButton("ë¦¬í¬íŠ¸ ìƒì„±")
        report_btn.clicked.connect(lambda: self.generate_report(node_outputs))
        button_layout.addWidget(report_btn)
        
        # ë‹«ê¸° ë²„íŠ¼
        close_btn = QPushButton("ë‹«ê¸°")
        close_btn.clicked.connect(result_dialog.accept)
        button_layout.addWidget(close_btn)
        
        layout.addLayout(button_layout)
        
        result_dialog.setLayout(layout)
        result_dialog.resize(900, 700)
        result_dialog.exec_()
        
        self.log("íŒŒì´í”„ë¼ì¸ ì‹¤í–‰ ì™„ë£Œ")
        
    def save_results(self, results):
        """ì˜ˆì¸¡ ê²°ê³¼ ì €ì¥"""
        filename, _ = QFileDialog.getSaveFileName(
            self, 
            "ì˜ˆì¸¡ ê²°ê³¼ ì €ì¥", 
            f"mcs_prediction_{datetime.now().strftime('%Y%m%d_%H%M%S')}.json",
            "JSON Files (*.json)"
        )
        if filename:
            # ê²°ê³¼ë¥¼ ì§ë ¬í™” ê°€ëŠ¥í•œ í˜•íƒœë¡œ ë³€í™˜
            serializable_results = {}
            for node, output in results.items():
                serializable_results[node.name] = output
                
            with open(filename, 'w', encoding='utf-8') as f:
                json.dump(serializable_results, f, indent=2, ensure_ascii=False)
            
            self.log(f"ì˜ˆì¸¡ ê²°ê³¼ê°€ ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤: {filename}")
            QMessageBox.information(self, "ì €ì¥ ì™„ë£Œ", "ì˜ˆì¸¡ ê²°ê³¼ê°€ ì„±ê³µì ìœ¼ë¡œ ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤.")
            
    def generate_report(self, results):
        """ì˜ˆì¸¡ ë¦¬í¬íŠ¸ ìƒì„±"""
        filename, _ = QFileDialog.getSaveFileName(
            self, 
            "ë¦¬í¬íŠ¸ ì €ì¥", 
            f"mcs_report_{datetime.now().strftime('%Y%m%d_%H%M%S')}.txt",
            "Text Files (*.txt)"
        )
        if filename:
            with open(filename, 'w', encoding='utf-8') as f:
                f.write("=" * 80 + "\n")
                f.write("ë°˜ë„ì²´ FAB MCS ë”¥ëŸ¬ë‹ ì˜ˆì¸¡ ë¦¬í¬íŠ¸\n")
                f.write("=" * 80 + "\n\n")
                f.write(f"ìƒì„± ì¼ì‹œ: {datetime.now().strftime('%Yë…„ %mì›” %dì¼ %H:%M:%S')}\n\n")
                
                # ê° ëª¨ë¸ë³„ ìš”ì•½
                for node, output in results.items():
                    if node.node_type == NodeType.MODEL:
                        f.write(f"\nã€{node.name}ã€‘\n")
                        f.write("-" * 60 + "\n")
                        
                        if "LSTM" in node.name:
                            f.write(f"ëª¨ë¸ ì •í™•ë„: {output.get('model_accuracy', 'N/A')}%\n")
                            if 'predictions' in output:
                                f.write("\nì˜ˆì¸¡ ê²°ê³¼:\n")
                                for pred in output['predictions'][:5]:
                                    f.write(f"  - {pred['period']}: {pred['predicted_time']}ì´ˆ "
                                           f"(ì‹ ë¢°ë„: {pred['confidence']*100:.1f}%)\n")
                                           
                        elif "RNN" in node.name:
                            f.write(f"ëª¨ë¸ ì •í™•ë„: {output.get('model_accuracy', 'N/A')}%\n")
                            if 'bottleneck_predictions' in output:
                                f.write("\në³‘ëª© ì˜ˆì¸¡:\n")
                                for bp in output['bottleneck_predictions'][:5]:
                                    f.write(f"  - {bp['bay']}: {bp['probability']*100:.1f}% "
                                           f"({bp['severity']})\n")
                                           
                        elif "ARIMA" in node.name:
                            if 'forecast_summary' in output:
                                f.write(f"í–¥í›„ 24ì‹œê°„ í‰ê· : {output['forecast_summary']['next_24h_avg']} ì›¨ì´í¼/ì‹œê°„\n")
                                f.write(f"ì˜ˆìƒ ì¼ì¼ ìƒì‚°ëŸ‰: {output['forecast_summary']['next_24h_avg'] * 24:.0f} ì›¨ì´í¼\n")
                                
                        elif "ì„¼ì„œì´ìƒíƒì§€" in node.name:
                            if 'detection_results' in output:
                                results = output['detection_results']
                                f.write(f"ì´ ì´ìƒ ê°ì§€: {results['pattern_analysis']['total_anomalies']}ê±´\n")
                                f.write(f"ìœ„í—˜ ìˆ˜ì¤€: {results['pattern_analysis']['critical_count']}ê±´\n")
                
                f.write("\n" + "=" * 80 + "\n")
                f.write("ì¢…í•© ë¶„ì„ ê²°ê³¼ ë° ê¶Œì¥ì‚¬í•­\n")
                f.write("=" * 80 + "\n")
                f.write("\nì´ ë¦¬í¬íŠ¸ëŠ” ë”¥ëŸ¬ë‹ ëª¨ë¸ì„ í†µí•œ ì˜ˆì¸¡ ê²°ê³¼ë¥¼ ë‹´ê³  ìˆìŠµë‹ˆë‹¤.\n")
                f.write("ì‹¤ì œ ìš´ì˜ ì‹œì—ëŠ” í˜„ì¥ ìƒí™©ì„ ê³ ë ¤í•˜ì—¬ ì ìš©í•˜ì‹œê¸° ë°”ëë‹ˆë‹¤.\n")
            
            self.log(f"ë¦¬í¬íŠ¸ê°€ ìƒì„±ë˜ì—ˆìŠµë‹ˆë‹¤: {filename}")
            QMessageBox.information(self, "ë¦¬í¬íŠ¸ ìƒì„± ì™„ë£Œ", "ì˜ˆì¸¡ ë¦¬í¬íŠ¸ê°€ ì„±ê³µì ìœ¼ë¡œ ìƒì„±ë˜ì—ˆìŠµë‹ˆë‹¤.")
        
    def show_help(self):
        """ë„ì›€ë§ í‘œì‹œ"""
        help_text = """ë°˜ë„ì²´ FAB MCS ë”¥ëŸ¬ë‹ ì˜ˆì¸¡ ì‹œìŠ¤í…œ ë„ì›€ë§
        
ì‹œìŠ¤í…œ ê°œìš”:
- LSTM, RNN, ARIMA ë”¥ëŸ¬ë‹ ëª¨ë¸ì„ ì‚¬ìš©í•œ ì˜ˆì¸¡ ì‹œìŠ¤í…œ
- í†µí•© MCS ë°ì´í„° ê¸°ë°˜ ì‹¤ì‹œê°„ ì˜ˆì¸¡ ë° ë¶„ì„

ì£¼ìš” ê¸°ëŠ¥:
1. LSTM: ì´ì†¡ ì‹œê°„ ì˜ˆì¸¡
2. RNN: ë³‘ëª© êµ¬ê°„ ì˜ˆì¸¡
3. ARIMA: ì²˜ë¦¬ëŸ‰ ì˜ˆì¸¡
4. ì„¼ì„œ ì´ìƒíƒì§€: ì¥ë¹„ ê³ ì¥ ì˜ˆì¸¡

ë§ˆìš°ìŠ¤ ì¡°ì‘:
- ì™¼ìª½ í´ë¦­: ë…¸ë“œ/ì—°ê²°ì„  ì„ íƒ
- ì™¼ìª½ ë“œë˜ê·¸: ì„ íƒ ì˜ì—­ ìƒì„±
- ê°€ìš´ë° ë²„íŠ¼ ë“œë˜ê·¸: í™”ë©´ ì´ë™
- ìŠ¤í˜ì´ìŠ¤ + ì™¼ìª½ ë“œë˜ê·¸: í™”ë©´ ì´ë™
- ë§ˆìš°ìŠ¤ íœ : í™•ëŒ€/ì¶•ì†Œ
- ë”ë¸”í´ë¦­: ë…¸ë“œ ì„¤ì •
- ìš°í´ë¦­: ì»¨í…ìŠ¤íŠ¸ ë©”ë‰´

í‚¤ë³´ë“œ ë‹¨ì¶•í‚¤:
- Delete: ì„ íƒ í•­ëª© ì‚­ì œ
- F: ì „ì²´ í™”ë©´ ë³´ê¸°
- Ctrl+N: ìƒˆ íŒŒì¼
- Ctrl+O: ì—´ê¸°
- Ctrl+S: ì €ì¥
- Ctrl+M: ë©”ëª¨ ì¶”ê°€
- Ctrl+Q: ì¢…ë£Œ

ë…¸ë“œ ì—°ê²°:
- ì¶œë ¥ í¬íŠ¸(ì˜¤ë¥¸ìª½)ì—ì„œ ì…ë ¥ í¬íŠ¸(ì™¼ìª½)ë¡œ ë“œë˜ê·¸
- ì—°ê²°ì„  í´ë¦­ í›„ Deleteë¡œ ì‚­ì œ

íŒŒì´í”„ë¼ì¸ êµ¬ì„±:
1. ë°ì´í„° ì…ë ¥ â†’ 2. ì „ì²˜ë¦¬ â†’ 3. ëª¨ë¸ â†’ 4. ë¶„ì„
ê° ë‹¨ê³„ë¥¼ ì—°ê²°í•˜ì—¬ ì˜ˆì¸¡ íŒŒì´í”„ë¼ì¸ êµ¬ì„±"""
        
        QMessageBox.information(self, "ë„ì›€ë§", help_text)
        
    def update_properties(self):
        """ì†ì„± íŒ¨ë„ ì—…ë°ì´íŠ¸"""
        selected = self.scene.selectedItems()
        if selected and isinstance(selected[0], Node):
            node = selected[0]
            info = f"""ë…¸ë“œ ì •ë³´
---------
ì´ë¦„: {node.name}
íƒ€ì…: {node.node_type.value}
ID: {node.node_id}
ì„¤ì • ìƒíƒœ: {'ì™„ë£Œ' if node.is_configured else 'ë¯¸ì™„ë£Œ'}
ìœ„ì¹˜: ({int(node.x())}, {int(node.y())})

ì„¤ì • ë‚´ìš©:
{json.dumps(node.settings, indent=2, ensure_ascii=False) if node.settings else 'ì—†ìŒ'}"""
            
            self.properties_widget.setPlainText(info)
        elif selected and isinstance(selected[0], MemoItem):
            memo = selected[0]
            info = f"""ë©”ëª¨ ì •ë³´
---------
ID: {memo.memo_id}
ìœ„ì¹˜: ({int(memo.x())}, {int(memo.y())})
í¬ê¸°: {int(memo.rect().width())} x {int(memo.rect().height())}

ë‚´ìš©:
{memo.text_item.toPlainText()}"""
            
            self.properties_widget.setPlainText(info)
        else:
            self.properties_widget.setPlainText("ë…¸ë“œë‚˜ ë©”ëª¨ë¥¼ ì„ íƒí•˜ì„¸ìš”")
            
    def log(self, message):
        """ì½˜ì†”ì— ë¡œê·¸ ì¶œë ¥"""
        from datetime import datetime
        timestamp = datetime.now().strftime("%H:%M:%S")
        self.console.append(f"[{timestamp}] {message}")
        self.statusBar().showMessage(message, 3000)


def main():
    app = QApplication(sys.argv)
    
    # ì• í”Œë¦¬ì¼€ì´ì…˜ ìŠ¤íƒ€ì¼ ì„¤ì •
    app.setStyle("Fusion")
    
    # ë‹¤í¬ íŒ”ë ˆíŠ¸
    palette = QPalette()
    palette.setColor(QPalette.Window, QColor(30, 30, 30))
    palette.setColor(QPalette.WindowText, Qt.white)
    palette.setColor(QPalette.Base, QColor(45, 45, 45))
    palette.setColor(QPalette.AlternateBase, QColor(60, 60, 60))
    palette.setColor(QPalette.ToolTipBase, Qt.black)
    palette.setColor(QPalette.ToolTipText, Qt.white)
    palette.setColor(QPalette.Text, Qt.white)
    palette.setColor(QPalette.Button, QColor(45, 45, 45))
    palette.setColor(QPalette.ButtonText, Qt.white)
    palette.setColor(QPalette.BrightText, Qt.red)
    palette.setColor(QPalette.Link, QColor(42, 130, 218))
    palette.setColor(QPalette.Highlight, QColor(42, 130, 218))
    palette.setColor(QPalette.HighlightedText, Qt.black)
    app.setPalette(palette)
    
    window = SemiconductorMCSSystem()
    window.show()
    
    sys.exit(app.exec_())


if __name__ == "__main__":
    main()