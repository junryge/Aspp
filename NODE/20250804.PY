import sys
import json
import math
from typing import Dict, List, Optional, Tuple
from dataclasses import dataclass
from enum import Enum

from PyQt5.QtWidgets import *
from PyQt5.QtCore import *
from PyQt5.QtGui import *


class NodeType(Enum):
    DATA = "data"
    PREPROCESS = "preprocess"
    VECTOR = "vector"
    MODEL = "model"
    ANALYSIS = "analysis"
    PROMPT = "prompt"
    LLM = "llm"


@dataclass
class NodeConfig:
    """ë…¸ë“œ ì„¤ì • ë°ì´í„° í´ë˜ìŠ¤"""
    node_type: NodeType
    name: str
    color: str
    inputs: int = 1
    outputs: int = 1


# ë…¸ë“œ íƒ€ì…ë³„ ì„¤ì •
NODE_CONFIGS = {
    NodeType.DATA: NodeConfig(NodeType.DATA, "ë°ì´í„° ì…ë ¥", "#3498db", 0, 1),
    NodeType.PREPROCESS: NodeConfig(NodeType.PREPROCESS, "ì „ì²˜ë¦¬", "#e74c3c", 1, 1),
    NodeType.VECTOR: NodeConfig(NodeType.VECTOR, "ë²¡í„° ì €ì¥", "#f39c12", 1, 1),
    NodeType.MODEL: NodeConfig(NodeType.MODEL, "ëª¨ë¸", "#27ae60", 1, 1),
    NodeType.ANALYSIS: NodeConfig(NodeType.ANALYSIS, "ë¶„ì„", "#9b59b6", 1, 1),
    NodeType.PROMPT: NodeConfig(NodeType.PROMPT, "í”„ë¡¬í”„íŠ¸", "#34495e", 2, 1),
    NodeType.LLM: NodeConfig(NodeType.LLM, "LLM", "#16a085", 1, 1),
}


class Port(QGraphicsEllipseItem):
    """ë…¸ë“œì˜ ì…ì¶œë ¥ í¬íŠ¸"""
    def __init__(self, is_output=True, parent=None):
        super().__init__(-6, -6, 12, 12, parent)
        self.is_output = is_output
        self.connections = []
        self.node = parent
        
        # í¬íŠ¸ ìŠ¤íƒ€ì¼
        self.default_color = QColor("#00CED1") if is_output else QColor("#FFD700")
        self.hover_color = QColor("#00BFFF") if is_output else QColor("#FFA500")
        self.highlight_color = QColor("#FF6347")  # ìŠ¤ëƒ… í•˜ì´ë¼ì´íŠ¸ìš©
        
        self.setBrush(QBrush(self.default_color))
        self.setPen(QPen(QColor("#FFFFFF"), 2))
        self.setAcceptHoverEvents(True)
        self.setZValue(10)
        
    def hoverEnterEvent(self, event):
        self.setBrush(QBrush(self.hover_color))
        super().hoverEnterEvent(event)
        
    def hoverLeaveEvent(self, event):
        self.setBrush(QBrush(self.default_color))
        super().hoverLeaveEvent(event)
        
    def highlight(self, on=True):
        """ìŠ¤ëƒ… í•˜ì´ë¼ì´íŠ¸"""
        if on:
            self.setBrush(QBrush(self.highlight_color))
            self.setPen(QPen(QColor("#FFFFFF"), 3))
        else:
            self.setBrush(QBrush(self.default_color))
            self.setPen(QPen(QColor("#FFFFFF"), 2))
        
    def get_center(self):
        """í¬íŠ¸ ì¤‘ì‹¬ ì¢Œí‘œ ë°˜í™˜ (ì”¬ ì¢Œí‘œ)"""
        return self.scenePos() + self.rect().center()
        
    def can_connect_to(self, other_port):
        """ë‹¤ë¥¸ í¬íŠ¸ì™€ ì—°ê²° ê°€ëŠ¥í•œì§€ í™•ì¸"""
        if not other_port or other_port == self:
            return False
        if self.is_output == other_port.is_output:
            return False
        if self.node == other_port.node:
            return False
        # ì´ë¯¸ ì—°ê²°ë˜ì–´ ìˆëŠ”ì§€ í™•ì¸
        for conn in self.connections:
            if (conn.start_port == other_port or conn.end_port == other_port):
                return False
        return True


class Connection(QGraphicsPathItem):
    """ë…¸ë“œ ê°„ ì—°ê²°ì„ """
    def __init__(self, start_port=None, end_port=None):
        super().__init__()
        self.start_port = start_port
        self.end_port = end_port
        self.temp_end_pos = None
        
        # ì—°ê²°ì„  ìŠ¤íƒ€ì¼
        self.default_pen = QPen(QColor("#3498db"), 3)
        self.hover_pen = QPen(QColor("#5dade2"), 4)
        self.selected_pen = QPen(QColor("#e74c3c"), 4)
        
        # êº¾ì€ì„ ì„ ë¶€ë“œëŸ½ê²Œ ë³´ì´ë„ë¡ ì¡°ì¸ ìŠ¤íƒ€ì¼ ì„¤ì •
        self.default_pen.setCapStyle(Qt.RoundCap)
        self.default_pen.setJoinStyle(Qt.RoundJoin)
        self.hover_pen.setCapStyle(Qt.RoundCap)
        self.hover_pen.setJoinStyle(Qt.RoundJoin)
        self.selected_pen.setCapStyle(Qt.RoundCap)
        self.selected_pen.setJoinStyle(Qt.RoundJoin)
        
        self.setPen(self.default_pen)
        self.setZValue(-1)
        
        # ì„ íƒ ë° í˜¸ë²„ ê°€ëŠ¥
        self.setFlag(QGraphicsItem.ItemIsSelectable, True)
        self.setAcceptHoverEvents(True)
        
        # í™”ì‚´í‘œ
        self.arrow = QGraphicsPolygonItem()
        self.arrow.setBrush(QBrush(QColor("#3498db")))
        self.arrow.setPen(QPen(Qt.NoPen))
        self.arrow.setZValue(-1)
        
        if start_port and end_port:
            start_port.connections.append(self)
            end_port.connections.append(self)
            self.update_path()
            
    def hoverEnterEvent(self, event):
        """ë§ˆìš°ìŠ¤ í˜¸ë²„ ì‹œ"""
        if not self.isSelected():
            self.setPen(self.hover_pen)
            self.arrow.setBrush(QBrush(QColor("#5dade2")))
        super().hoverEnterEvent(event)
        
    def hoverLeaveEvent(self, event):
        """ë§ˆìš°ìŠ¤ í˜¸ë²„ í•´ì œ"""
        if not self.isSelected():
            self.setPen(self.default_pen)
            self.arrow.setBrush(QBrush(QColor("#3498db")))
        super().hoverLeaveEvent(event)
        
    def itemChange(self, change, value):
        """ì„ íƒ ìƒíƒœ ë³€ê²½"""
        if change == QGraphicsItem.ItemSelectedChange:
            if value:
                self.setPen(self.selected_pen)
                self.arrow.setBrush(QBrush(QColor("#e74c3c")))
            else:
                self.setPen(self.default_pen)
                self.arrow.setBrush(QBrush(QColor("#3498db")))
        return super().itemChange(change, value)
        
    def update_path(self, end_pos=None):
        """ì—°ê²°ì„  ê²½ë¡œ ì—…ë°ì´íŠ¸ (ë…¸ë“œ íšŒí”¼ ë¡œì§ í¬í•¨)"""
        if not self.start_port:
            return
            
        start = self.start_port.get_center()
        
        if end_pos:
            end = end_pos
        elif self.end_port:
            end = self.end_port.get_center()
        else:
            return
            
        # ìŠ¤ë§ˆíŠ¸ ê²½ë¡œ ê³„ì‚°
        path = self.calculate_smart_path(start, end)
        self.setPath(path)
        
        # í™”ì‚´í‘œ ì—…ë°ì´íŠ¸
        if self.end_port or end_pos:
            self.update_arrow(path)
            
    def calculate_smart_path(self, start, end):
        """ë…¸ë“œë¥¼ í”¼í•´ê°€ëŠ” ì§ê° ê²½ë¡œ ê³„ì‚°"""
        path = QPainterPath()
        path.moveTo(start)
        
        dx = end.x() - start.x()
        dy = end.y() - start.y()
        
        # ì˜¤í”„ì…‹ ê±°ë¦¬
        offset = 50
        
        # ê±°ë¦¬ê°€ ê°€ê¹Œìš°ë©´ ê·¸ëƒ¥ ì§ì„  ì—°ê²°
        distance = math.sqrt(dx * dx + dy * dy)
        if distance < 150:
            path.lineTo(end)
            return path
            
        # Case 1: ì •ë°©í–¥ ì—°ê²° (ì™¼ìª½ì—ì„œ ì˜¤ë¥¸ìª½ìœ¼ë¡œ)
        if dx > offset:
            # ì¤‘ê°„ ì§€ì ì—ì„œ êº¾ê¸°
            mid_x = start.x() + dx / 2
            path.lineTo(mid_x, start.y())
            path.lineTo(mid_x, end.y())
            path.lineTo(end)
            
        # Case 2: ì—­ë°©í–¥ ì—°ê²° (ì˜¤ë¥¸ìª½ì—ì„œ ì™¼ìª½ìœ¼ë¡œ)
        else:
            # Sì ì—°ê²°
            mid_y = (start.y() + end.y()) / 2
            path.lineTo(start.x() + offset, start.y())
            path.lineTo(start.x() + offset, mid_y)
            path.lineTo(end.x() - offset, mid_y)
            path.lineTo(end.x() - offset, end.y())
            path.lineTo(end)
     
        
        return path
        
    def update_arrow(self, path):
        """í™”ì‚´í‘œ ì—…ë°ì´íŠ¸"""
        if path.length() == 0:
            return
            
        # ê²½ë¡œì˜ ë§ˆì§€ë§‰ ì„ ë¶„ì—ì„œ ë°©í–¥ ê³„ì‚°
        # ëì ê³¼ ê·¸ ì§ì „ ì ì„ ì°¾ê¸°
        point_count = path.elementCount()
        if point_count < 2:
            return
            
        # ë§ˆì§€ë§‰ ë‘ ì  ê°€ì ¸ì˜¤ê¸°
        last_element = path.elementAt(point_count - 1)
        second_last_element = path.elementAt(point_count - 2)
        
        point2 = QPointF(last_element.x, last_element.y)
        point1 = QPointF(second_last_element.x, second_last_element.y)
        
        angle = math.atan2(point2.y() - point1.y(), point2.x() - point1.x())
        
        # í™”ì‚´í‘œ í´ë¦¬ê³¤
        arrow_length = 12
        arrow_angle = math.radians(25)
        
        p1 = point2
        p2 = point2 - QPointF(
            arrow_length * math.cos(angle - arrow_angle),
            arrow_length * math.sin(angle - arrow_angle)
        )
        p3 = point2 - QPointF(
            arrow_length * math.cos(angle + arrow_angle),
            arrow_length * math.sin(angle + arrow_angle)
        )
        
        self.arrow.setPolygon(QPolygonF([p1, p2, p3]))
        
        if self.arrow.scene() != self.scene():
            if self.scene():
                self.scene().addItem(self.arrow)
                
    def shape(self):
        """í´ë¦­ ì˜ì—­ì„ ë„“ê²Œ ì„¤ì •"""
        stroker = QPainterPathStroker()
        stroker.setWidth(20)
        return stroker.createStroke(self.path())
        
    def remove(self):
        """ì—°ê²° ì œê±°"""
        # í¬íŠ¸ì—ì„œ ì—°ê²° ì œê±°
        if self.start_port and self in self.start_port.connections:
            self.start_port.connections.remove(self)
        if self.end_port and self in self.end_port.connections:
            self.end_port.connections.remove(self)
            
        # ì”¬ì—ì„œ ì œê±°
        if self.scene():
            self.scene().removeItem(self.arrow)
            self.scene().removeItem(self)


class MemoItem(QGraphicsRectItem):
    """ë©”ëª¨ ì•„ì´í…œ í´ë˜ìŠ¤"""
    def __init__(self, x=0, y=0, width=250, height=150):
        super().__init__(0, 0, width, height)
        
        self.memo_id = id(self)
        self.setPos(x, y)
        
        # ë©”ëª¨ ìŠ¤íƒ€ì¼
        self.colors = [
            "#fffacd",  # ì—°í•œ ë…¸ë€ìƒ‰
            "#ffe4e1",  # ì—°í•œ ë¶„í™ìƒ‰
            "#e0ffff",  # ì—°í•œ í•˜ëŠ˜ìƒ‰
            "#f0fff0",  # ì—°í•œ ì´ˆë¡ìƒ‰
            "#f5f5dc",  # ë² ì´ì§€ìƒ‰
            "#fff0f5",  # ì—°í•œ ë³´ë¼ìƒ‰
        ]
        self.current_color_index = 0
        self.setColor(self.colors[0])
        
        # í”Œë˜ê·¸ ì„¤ì •
        self.setFlag(QGraphicsItem.ItemIsMovable, True)
        self.setFlag(QGraphicsItem.ItemIsSelectable, True)
        self.setFlag(QGraphicsItem.ItemSendsGeometryChanges, True)
        self.setAcceptHoverEvents(True)
        self.setZValue(-2)  # ë…¸ë“œë³´ë‹¤ ë’¤ì— í‘œì‹œ
        
        # í…ìŠ¤íŠ¸ ì•„ì´í…œ
        self.text_item = QGraphicsTextItem(self)
        self.text_item.setPlainText("ë©”ëª¨ë¥¼ ì…ë ¥í•˜ì„¸ìš”...")
        self.text_item.setDefaultTextColor(QColor("#333333"))
        self.text_item.setPos(10, 10)
        self.text_item.setTextWidth(width - 20)
        
        # ì œëª© ë°”
        self.title_height = 25
        self.is_editing = False
        
        # ë¦¬ì‚¬ì´ì¦ˆ í•¸ë“¤
        self.resize_handle_size = 10
        self.is_resizing = False
        self.resize_start_pos = None
        self.resize_start_rect = None
        
        # ê·¸ë¦¼ì íš¨ê³¼
        shadow = QGraphicsDropShadowEffect()
        shadow.setOffset(2, 2)
        shadow.setBlurRadius(5)
        shadow.setColor(QColor(0, 0, 0, 50))
        self.setGraphicsEffect(shadow)
        
    def setColor(self, color):
        """ë©”ëª¨ ìƒ‰ìƒ ì„¤ì •"""
        self.setBrush(QBrush(QColor(color)))
        self.setPen(QPen(QColor(color).darker(120), 2))
        
    def paint(self, painter, option, widget):
        """ë©”ëª¨ ê·¸ë¦¬ê¸°"""
        super().paint(painter, option, widget)
        
        # ì œëª© ë°” ê·¸ë¦¬ê¸°
        title_rect = QRectF(0, 0, self.rect().width(), self.title_height)
        painter.fillRect(title_rect, QBrush(QColor(0, 0, 0, 30)))
        
        # ì œëª© í…ìŠ¤íŠ¸
        painter.setPen(QPen(QColor("#555555")))
        painter.setFont(QFont("Arial", 9))
        painter.drawText(title_rect.adjusted(10, 0, -40, 0),
                        Qt.AlignVCenter, "ë©”ëª¨")
        
        # ë‹«ê¸° ë²„íŠ¼ ì˜ì—­
        close_rect = QRectF(self.rect().width() - 25, 5, 15, 15)
        painter.drawText(close_rect, Qt.AlignCenter, "Ã—")
        
        # ìƒ‰ìƒ ë³€ê²½ ë²„íŠ¼ ì˜ì—­
        color_rect = QRectF(self.rect().width() - 45, 5, 15, 15)
        painter.fillRect(color_rect, QBrush(QColor(self.colors[(self.current_color_index + 1) % len(self.colors)])))
        painter.drawRect(color_rect)
        
        # ë¦¬ì‚¬ì´ì¦ˆ í•¸ë“¤
        if self.isSelected():
            handle_rect = QRectF(
                self.rect().width() - self.resize_handle_size,
                self.rect().height() - self.resize_handle_size,
                self.resize_handle_size,
                self.resize_handle_size
            )
            # ë” ëˆˆì— ë„ëŠ” ë¦¬ì‚¬ì´ì¦ˆ í•¸ë“¤
            painter.fillRect(handle_rect, QBrush(QColor("#3498db")))
            painter.setPen(QPen(QColor("#2980b9"), 1))
            painter.drawRect(handle_rect)
            
            # ë¦¬ì‚¬ì´ì¦ˆ ì•„ì´ì½˜ ê·¸ë¦¬ê¸° (ì„¸ ê°œì˜ ëŒ€ê°ì„ )
            painter.setPen(QPen(QColor("#ffffff"), 1))
            for i in range(3):
                offset = i * 3
                painter.drawLine(
                    handle_rect.right() - offset - 2,
                    handle_rect.bottom() - 1,
                    handle_rect.right() - 1,
                    handle_rect.bottom() - offset - 2
                )
            painter.fillRect(handle_rect, QBrush(QColor("#666666")))
            
    def mousePressEvent(self, event):
        """ë§ˆìš°ìŠ¤ í´ë¦­ ì´ë²¤íŠ¸"""
        pos = event.pos()
        
        # ë‹«ê¸° ë²„íŠ¼ í´ë¦­
        close_rect = QRectF(self.rect().width() - 25, 5, 15, 15)
        if close_rect.contains(pos):
            self.delete_self()
            return
            
        # ìƒ‰ìƒ ë³€ê²½ ë²„íŠ¼ í´ë¦­
        color_rect = QRectF(self.rect().width() - 45, 5, 15, 15)
        if color_rect.contains(pos):
            self.change_color()
            return
            
        # ë¦¬ì‚¬ì´ì¦ˆ í•¸ë“¤ í´ë¦­
        handle_rect = QRectF(
            self.rect().width() - self.resize_handle_size,
            self.rect().height() - self.resize_handle_size,
            self.resize_handle_size,
            self.resize_handle_size
        )
        if handle_rect.contains(pos) and self.isSelected():
            self.is_resizing = True
            self.resize_start_pos = event.scenePos()
            self.resize_start_rect = self.rect()
            event.accept()
            return
            
        super().mousePressEvent(event)
        
    def mouseMoveEvent(self, event):
        """ë§ˆìš°ìŠ¤ ì´ë™ ì´ë²¤íŠ¸"""
        if self.is_resizing:
            # ë¦¬ì‚¬ì´ì¦ˆ ì²˜ë¦¬
            diff = event.scenePos() - self.resize_start_pos
            new_width = max(150, self.resize_start_rect.width() + diff.x())
            new_height = max(100, self.resize_start_rect.height() + diff.y())
            
            self.setRect(0, 0, new_width, new_height)
            self.text_item.setTextWidth(new_width - 20)
            self.update()
        else:
            super().mouseMoveEvent(event)
            
    def mouseReleaseEvent(self, event):
        """ë§ˆìš°ìŠ¤ ë¦´ë¦¬ì¦ˆ ì´ë²¤íŠ¸"""
        self.is_resizing = False
        super().mouseReleaseEvent(event)
        
    def mouseDoubleClickEvent(self, event):
        """ë”ë¸”í´ë¦­ìœ¼ë¡œ í¸ì§‘ ëª¨ë“œ"""
        self.edit_text()
        
    def hoverEnterEvent(self, event):
        """ë§ˆìš°ìŠ¤ í˜¸ë²„ ì‹œ"""
        self.setCursor(Qt.PointingHandCursor)
        super().hoverEnterEvent(event)
        
    def hoverMoveEvent(self, event):
        """í˜¸ë²„ ì¤‘ ë§ˆìš°ìŠ¤ ì´ë™"""
        pos = event.pos()
        
        # ë¦¬ì‚¬ì´ì¦ˆ í•¸ë“¤ ìœ„ì—ì„œ ì»¤ì„œ ë³€ê²½
        handle_rect = QRectF(
            self.rect().width() - self.resize_handle_size,
            self.rect().height() - self.resize_handle_size,
            self.resize_handle_size,
            self.resize_handle_size
        )
        if handle_rect.contains(pos) and self.isSelected():
            self.setCursor(Qt.SizeFDiagCursor)
        else:
            self.setCursor(Qt.PointingHandCursor)
            
    def edit_text(self):
        """í…ìŠ¤íŠ¸ í¸ì§‘"""
        dialog = QDialog()
        dialog.setWindowTitle("ë©”ëª¨ í¸ì§‘")
        dialog.setModal(True)
        layout = QVBoxLayout()
        
        # í…ìŠ¤íŠ¸ í¸ì§‘ê¸°
        text_edit = QTextEdit()
        text_edit.setPlainText(self.text_item.toPlainText())
        text_edit.setMinimumSize(400, 300)
        layout.addWidget(text_edit)
        
        # ë²„íŠ¼
        buttons = QDialogButtonBox(QDialogButtonBox.Ok | QDialogButtonBox.Cancel)
        buttons.accepted.connect(dialog.accept)
        buttons.rejected.connect(dialog.reject)
        layout.addWidget(buttons)
        
        dialog.setLayout(layout)
        
        if dialog.exec_() == QDialog.Accepted:
            self.text_item.setPlainText(text_edit.toPlainText())
            
    def change_color(self):
        """ìƒ‰ìƒ ë³€ê²½"""
        self.current_color_index = (self.current_color_index + 1) % len(self.colors)
        self.setColor(self.colors[self.current_color_index])
        self.update()
        
    def delete_self(self):
        """ìì‹ ì„ ì‚­ì œ"""
        if hasattr(self.scene(), 'main_window') and self.scene().main_window:
            reply = QMessageBox.question(None, "í™•ì¸",
                                       "ì´ ë©”ëª¨ë¥¼ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?",
                                       QMessageBox.Yes | QMessageBox.No)
            if reply == QMessageBox.Yes:
                self.scene().removeItem(self)
                self.scene().main_window.log("ë©”ëª¨ê°€ ì‚­ì œë˜ì—ˆìŠµë‹ˆë‹¤")
                
    def get_data(self):
        """ë©”ëª¨ ë°ì´í„° ë°˜í™˜ (ì €ì¥ìš©)"""
        return {
            "id": self.memo_id,
            "x": self.x(),
            "y": self.y(),
            "width": self.rect().width(),
            "height": self.rect().height(),
            "text": self.text_item.toPlainText(),
            "color_index": self.current_color_index
        }
        
    def set_data(self, data):
        """ë©”ëª¨ ë°ì´í„° ì„¤ì • (ë¶ˆëŸ¬ì˜¤ê¸°ìš©)"""
        self.setPos(data["x"], data["y"])
        self.setRect(0, 0, data["width"], data["height"])
        self.text_item.setPlainText(data["text"])
        self.text_item.setTextWidth(data["width"] - 20)
        self.current_color_index = data.get("color_index", 0)
        self.setColor(self.colors[self.current_color_index])


class Node(QGraphicsRectItem):
    """ë…¸ë“œ í´ë˜ìŠ¤"""
    def __init__(self, node_type: NodeType, name: str, x=0, y=0):
        super().__init__(0, 0, 200, 100)
        
        self.node_id = id(self)
        self.node_type = node_type
        self.name = name
        self.config = NODE_CONFIGS[node_type]
        self.is_configured = False
        self.settings = {}
        
        # ë…¸ë“œ ìŠ¤íƒ€ì¼
        self.setPos(x, y)
        self.setBrush(QBrush(QColor(self.config.color)))
        self.setPen(QPen(QColor("#FFFFFF"), 2))
        self.setFlag(QGraphicsItem.ItemIsMovable, True)
        self.setFlag(QGraphicsItem.ItemIsSelectable, True)
        self.setFlag(QGraphicsItem.ItemSendsGeometryChanges, True)
        self.setCursor(Qt.PointingHandCursor)
        self.setAcceptHoverEvents(True)
        self.setZValue(1)
        
        # ê·¸ë¦¼ì íš¨ê³¼
        shadow = QGraphicsDropShadowEffect()
        shadow.setOffset(3, 3)
        shadow.setBlurRadius(10)
        shadow.setColor(QColor(0, 0, 0, 100))
        self.setGraphicsEffect(shadow)
        
        # í…ìŠ¤íŠ¸ ë ˆì´ë¸”
        self.title_text = QGraphicsTextItem(self.name, self)
        self.title_text.setDefaultTextColor(Qt.white)
        font = QFont("Arial", 11, QFont.Bold)
        self.title_text.setFont(font)
        self.title_text.setPos(10, 5)
        
        self.type_text = QGraphicsTextItem(f"[{node_type.value}]", self)
        self.type_text.setDefaultTextColor(QColor("#ecf0f1"))
        self.type_text.setFont(QFont("Arial", 9))
        self.type_text.setPos(10, 30)
        
        # ìƒíƒœ í‘œì‹œ
        self.status_indicator = QGraphicsEllipseItem(170, 10, 20, 20, self)
        self.update_status()
        
        # í¬íŠ¸ ìƒì„±
        self.input_ports = []
        self.output_ports = []
        self.create_ports()
        
    def create_ports(self):
        """ì…ì¶œë ¥ í¬íŠ¸ ìƒì„±"""
        # ì…ë ¥ í¬íŠ¸
        for i in range(self.config.inputs):
            y_pos = 50 + (i * 30) if self.config.inputs > 1 else 50
            port = Port(is_output=False, parent=self)
            port.setPos(0, y_pos)
            self.input_ports.append(port)
            
        # ì¶œë ¥ í¬íŠ¸
        for i in range(self.config.outputs):
            y_pos = 50 + (i * 30) if self.config.outputs > 1 else 50
            port = Port(is_output=True, parent=self)
            port.setPos(200, y_pos)
            self.output_ports.append(port)
            
    def update_status(self):
        """ìƒíƒœ í‘œì‹œ ì—…ë°ì´íŠ¸"""
        color = QColor("#27ae60") if self.is_configured else QColor("#e74c3c")
        self.status_indicator.setBrush(QBrush(color))
        self.status_indicator.setPen(QPen(Qt.white, 2))
        
    def hoverEnterEvent(self, event):
        """ë§ˆìš°ìŠ¤ í˜¸ë²„ ì‹œ í•˜ì´ë¼ì´íŠ¸"""
        self.setPen(QPen(QColor("#FFD700"), 3))
        super().hoverEnterEvent(event)
        
    def hoverLeaveEvent(self, event):
        """ë§ˆìš°ìŠ¤ í˜¸ë²„ í•´ì œ"""
        self.setPen(QPen(QColor("#FFFFFF"), 2))
        super().hoverLeaveEvent(event)
        
    def itemChange(self, change, value):
        """ì•„ì´í…œ ë³€ê²½ ì‹œ ì—°ê²°ì„  ì—…ë°ì´íŠ¸"""
        if change == QGraphicsItem.ItemPositionHasChanged:
            # ì—°ê²°ëœ ëª¨ë“  ì—°ê²°ì„  ì—…ë°ì´íŠ¸
            for port in self.input_ports + self.output_ports:
                for connection in port.connections:
                    connection.update_path()
                    
        return super().itemChange(change, value)
        
    def mouseDoubleClickEvent(self, event):
        """ë”ë¸”í´ë¦­ ì‹œ ì„¤ì • ì°½ ì—´ê¸°"""
        if hasattr(self.scene(), 'main_window') and self.scene().main_window:
            self.scene().main_window.configure_node(self)
        super().mouseDoubleClickEvent(event)
        
    def contextMenuEvent(self, event):
        """ë§ˆìš°ìŠ¤ ì˜¤ë¥¸ìª½ í´ë¦­ ì»¨í…ìŠ¤íŠ¸ ë©”ë‰´"""
        menu = QMenu()
        
        # ëª¨ë“  ë…¸ë“œì— ê³µí†µìœ¼ë¡œ ì ìš©ë˜ëŠ” ë©”ë‰´
        configure_action = QAction("âš™ï¸ ë…¸ë“œ ì„¤ì •", None)
        configure_action.triggered.connect(lambda: self.scene().main_window.configure_node(self) if hasattr(self.scene(), 'main_window') and self.scene().main_window else None)
        menu.addAction(configure_action)
        
        # í”„ë¡¬í”„íŠ¸ ë…¸ë“œ ì „ìš© ë©”ë‰´
        if self.node_type == NodeType.PROMPT:
            if self.is_configured and 'template' in self.settings:
                preview_action = QAction("ğŸ‘ï¸ í”„ë¡¬í”„íŠ¸ ë¯¸ë¦¬ë³´ê¸°", None)
                preview_action.triggered.connect(lambda: self.show_prompt_preview())
                menu.addAction(preview_action)
                
                menu.addSeparator()
                
                # í”„ë¡¬í”„íŠ¸ ë³µì‚¬
                copy_prompt_action = QAction("ğŸ“‹ í”„ë¡¬í”„íŠ¸ ë³µì‚¬", None)
                copy_prompt_action.triggered.connect(lambda: self.copy_prompt_to_clipboard())
                menu.addAction(copy_prompt_action)
        
        # ë°ì´í„° ë…¸ë“œ ì „ìš© ë©”ë‰´
        elif self.node_type == NodeType.DATA:
            if self.is_configured and 'path' in self.settings:
                open_file_action = QAction("ğŸ“ íŒŒì¼ ìœ„ì¹˜ ì—´ê¸°", None)
                open_file_action.triggered.connect(lambda: self.open_file_location())
                menu.addAction(open_file_action)
        
        # ëª¨ë¸ ë…¸ë“œ ì „ìš© ë©”ë‰´
        elif self.node_type == NodeType.MODEL:
            if self.is_configured:
                show_params_action = QAction("ğŸ“Š ëª¨ë¸ íŒŒë¼ë¯¸í„° ë³´ê¸°", None)
                show_params_action.triggered.connect(lambda: self.show_model_params())
                menu.addAction(show_params_action)
        
        menu.addSeparator()
        
        # ë…¸ë“œ ë³µì œ
        duplicate_action = QAction("ğŸ“‘ ë…¸ë“œ ë³µì œ", None)
        duplicate_action.triggered.connect(lambda: self.duplicate_node())
        menu.addAction(duplicate_action)
        
        # ë…¸ë“œ ì‚­ì œ
        delete_action = QAction("ğŸ—‘ï¸ ë…¸ë“œ ì‚­ì œ", None)
        delete_action.triggered.connect(lambda: self.delete_self())
        menu.addAction(delete_action)
        
        # ë©”ë‰´ í‘œì‹œ
        menu.exec_(event.screenPos())
            
    def show_prompt_preview(self):
        """í”„ë¡¬í”„íŠ¸ ë¯¸ë¦¬ë³´ê¸°"""
        if 'template' in self.settings:
            dialog = QDialog()
            dialog.setWindowTitle("í”„ë¡¬í”„íŠ¸ í…œí”Œë¦¿ ë¯¸ë¦¬ë³´ê¸°")
            dialog.setModal(True)
            layout = QVBoxLayout()
            
            # í”„ë¡¬í”„íŠ¸ ë‚´ìš©
            text_edit = QTextEdit()
            text_edit.setPlainText(self.settings['template'])
            text_edit.setReadOnly(True)
            text_edit.setMinimumSize(500, 300)
            layout.addWidget(text_edit)
            
            # í¬í•¨ëœ ì»¨í…ìŠ¤íŠ¸ í‘œì‹œ
            contexts = []
            for i in range(4):  # ìµœëŒ€ 4ê°œì˜ ì»¨í…ìŠ¤íŠ¸
                key = f'context_{i}'
                if key in self.settings and self.settings[key]:
                    contexts.append(['ë‚ ì”¨ ì •ë³´', 'êµí†µ ìƒí™©', 'ê³¼ê±° ì§€ì—° ì´ë ¥', 'íŠ¹ë³„ ì´ë²¤íŠ¸'][i])
            
            if contexts:
                context_label = QLabel(f"í¬í•¨ëœ ì»¨í…ìŠ¤íŠ¸: {', '.join(contexts)}")
                layout.addWidget(context_label)
            
            # ë‹«ê¸° ë²„íŠ¼
            close_btn = QPushButton("ë‹«ê¸°")
            close_btn.clicked.connect(dialog.accept)
            layout.addWidget(close_btn)
            
            dialog.setLayout(layout)
            dialog.exec_()
            
    def copy_prompt_to_clipboard(self):
        """í”„ë¡¬í”„íŠ¸ë¥¼ í´ë¦½ë³´ë“œì— ë³µì‚¬"""
        if 'template' in self.settings:
            clipboard = QApplication.clipboard()
            clipboard.setText(self.settings['template'])
            
            # ë³µì‚¬ ì™„ë£Œ ë©”ì‹œì§€
            if hasattr(self.scene(), 'main_window') and self.scene().main_window:
                self.scene().main_window.log("í”„ë¡¬í”„íŠ¸ê°€ í´ë¦½ë³´ë“œì— ë³µì‚¬ë˜ì—ˆìŠµë‹ˆë‹¤")
                
    def open_file_location(self):
        """íŒŒì¼ ìœ„ì¹˜ ì—´ê¸°"""
        if 'path' in self.settings:
            import os
            path = self.settings['path']
            if os.path.exists(path):
                if os.path.isfile(path):
                    os.startfile(os.path.dirname(path))
                else:
                    os.startfile(path)
                    
    def show_model_params(self):
        """ëª¨ë¸ íŒŒë¼ë¯¸í„° í‘œì‹œ"""
        params = []
        for key, value in self.settings.items():
            params.append(f"{key}: {value}")
            
        msg = QMessageBox()
        msg.setWindowTitle(f"{self.name} íŒŒë¼ë¯¸í„°")
        msg.setText("í˜„ì¬ ì„¤ì •ëœ ëª¨ë¸ íŒŒë¼ë¯¸í„°:")
        msg.setDetailedText('\n'.join(params))
        msg.setIcon(QMessageBox.Information)
        msg.exec_()
        
    def duplicate_node(self):
        """ë…¸ë“œ ë³µì œ"""
        if hasattr(self.scene(), 'main_window') and self.scene().main_window:
            # ìƒˆ ë…¸ë“œ ìƒì„±
            new_node = Node(self.node_type, self.name, self.x() + 50, self.y() + 50)
            new_node.settings = self.settings.copy()
            new_node.is_configured = self.is_configured
            new_node.update_status()
            
            self.scene().addItem(new_node)
            self.scene().main_window.log(f"{self.name} ë…¸ë“œê°€ ë³µì œë˜ì—ˆìŠµë‹ˆë‹¤")
            
    def delete_self(self):
        """ìì‹ ì„ ì‚­ì œ"""
        if hasattr(self.scene(), 'main_window') and self.scene().main_window:
            reply = QMessageBox.question(None, "í™•ì¸",
                                       f"{self.name} ë…¸ë“œë¥¼ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?",
                                       QMessageBox.Yes | QMessageBox.No)
            if reply == QMessageBox.Yes:
                self.scene().main_window.view.delete_node(self)


class NodeScene(QGraphicsScene):
    """ë…¸ë“œ ì—ë””í„° ì”¬"""
    def __init__(self, parent=None):
        super().__init__(parent)
        self.main_window = parent  # ë©”ì¸ ìœˆë„ìš° ì°¸ì¡° ì €ì¥
        self.setSceneRect(-2000, -2000, 4000, 4000)
        
        # ë°°ê²½ ìƒ‰ìƒ
        self.setBackgroundBrush(QBrush(QColor("#2c3e50")))
        
        # ê·¸ë¦¬ë“œ
        self.grid_size = 20
        self.grid_visible = True
        
        # ì—°ê²° ê´€ë ¨
        self.current_connection = None
        self.start_port = None
        self.highlighted_port = None
        
    def drawBackground(self, painter, rect):
        """ë°°ê²½ ê·¸ë¦¬ê¸° (ê·¸ë¦¬ë“œ í¬í•¨)"""
        super().drawBackground(painter, rect)
        
        if not self.grid_visible:
            return
            
        # ê·¸ë¦¬ë“œ ê·¸ë¦¬ê¸°
        painter.setPen(QPen(QColor("#34495e"), 1, Qt.SolidLine))
        
        # ê·¸ë¦¬ë“œ ë²”ìœ„ ê³„ì‚°
        left = int(rect.left()) - (int(rect.left()) % self.grid_size)
        top = int(rect.top()) - (int(rect.top()) % self.grid_size)
        
        # ìˆ˜ì§ì„ 
        for x in range(left, int(rect.right()), self.grid_size):
            painter.drawLine(x, rect.top(), x, rect.bottom())
            
        # ìˆ˜í‰ì„ 
        for y in range(top, int(rect.bottom()), self.grid_size):
            painter.drawLine(rect.left(), y, rect.right(), y)
            
    def find_port_at(self, pos):
        """ì£¼ì–´ì§„ ìœ„ì¹˜ì˜ í¬íŠ¸ ì°¾ê¸°"""
        items = self.items(pos)
        for item in items:
            if isinstance(item, Port):
                return item
        return None
        
    def find_nearest_port(self, pos, port_type=None, max_distance=50):
        """ì£¼ì–´ì§„ ìœ„ì¹˜ì—ì„œ ê°€ì¥ ê°€ê¹Œìš´ í¬íŠ¸ ì°¾ê¸°"""
        nearest_port = None
        min_distance = max_distance
        
        for item in self.items():
            if isinstance(item, Port):
                # í¬íŠ¸ íƒ€ì… í•„í„°ë§
                if port_type is not None and item.is_output != (port_type == "output"):
                    continue
                    
                # í˜„ì¬ ì—°ê²° ì¤‘ì¸ í¬íŠ¸ì™€ ì—°ê²° ê°€ëŠ¥í•œì§€ í™•ì¸
                if self.start_port and not self.start_port.can_connect_to(item):
                    continue
                    
                port_center = item.get_center()
                distance = ((pos - port_center).x() ** 2 + (pos - port_center).y() ** 2) ** 0.5
                
                if distance < min_distance:
                    min_distance = distance
                    nearest_port = item
                    
        return nearest_port
        
    def mousePressEvent(self, event):
        """ë§ˆìš°ìŠ¤ í´ë¦­ ì´ë²¤íŠ¸"""
        port = self.find_port_at(event.scenePos())
        
        if port and port.is_output:
            # ì¶œë ¥ í¬íŠ¸ì—ì„œ ì—°ê²° ì‹œì‘
            self.start_connection(port)
        elif port and not port.is_output and self.current_connection:
            # ì…ë ¥ í¬íŠ¸ì— ì—°ê²° ì™„ë£Œ
            self.end_connection(port)
        else:
            super().mousePressEvent(event)
            
    def mouseMoveEvent(self, event):
        """ë§ˆìš°ìŠ¤ ì´ë™ ì´ë²¤íŠ¸"""
        if self.current_connection:
            self.current_connection.update_path(event.scenePos())
            
            # ê°€ê¹Œìš´ í¬íŠ¸ í•˜ì´ë¼ì´íŠ¸
            nearest_port = self.find_nearest_port(event.scenePos(), "input", 80)
            
            if nearest_port != self.highlighted_port:
                # ì´ì „ í•˜ì´ë¼ì´íŠ¸ í•´ì œ
                if self.highlighted_port:
                    self.highlighted_port.highlight(False)
                    
                # ìƒˆ í¬íŠ¸ í•˜ì´ë¼ì´íŠ¸
                if nearest_port:
                    nearest_port.highlight(True)
                    
                self.highlighted_port = nearest_port
                
        super().mouseMoveEvent(event)
        
    def mouseReleaseEvent(self, event):
        """ë§ˆìš°ìŠ¤ ë¦´ë¦¬ì¦ˆ ì´ë²¤íŠ¸"""
        if self.current_connection:
            # ê°€ê¹Œìš´ ì…ë ¥ í¬íŠ¸ ì°¾ê¸°
            nearest_port = self.find_nearest_port(event.scenePos(), "input", 80)
            
            if nearest_port:
                self.end_connection(nearest_port)
            else:
                # ì—°ê²° ì·¨ì†Œ
                self.removeItem(self.current_connection)
                self.current_connection = None
                self.start_port = None
                
            # í•˜ì´ë¼ì´íŠ¸ í•´ì œ
            if self.highlighted_port:
                self.highlighted_port.highlight(False)
                self.highlighted_port = None
                
        super().mouseReleaseEvent(event)
        
    def start_connection(self, port):
        """ì—°ê²° ì‹œì‘"""
        self.start_port = port
        self.current_connection = Connection(port)
        self.addItem(self.current_connection)
        
    def end_connection(self, end_port):
        """ì—°ê²° ì™„ë£Œ"""
        if self.start_port and self.current_connection and self.start_port.can_connect_to(end_port):
            # ì—°ê²° ì™„ë£Œ
            self.current_connection.end_port = end_port
            self.current_connection.update_path()
            
            self.start_port.connections.append(self.current_connection)
            end_port.connections.append(self.current_connection)
            
            self.current_connection = None
            self.start_port = None
        else:
            # ì—°ê²° ì‹¤íŒ¨
            if self.current_connection:
                self.removeItem(self.current_connection)
                self.current_connection = None
                self.start_port = None
                
    def contextMenuEvent(self, event):
        """ì”¬ ìš°í´ë¦­ ì»¨í…ìŠ¤íŠ¸ ë©”ë‰´"""
        # ì•„ì´í…œì´ ì—†ëŠ” ë¹ˆ ê³µê°„ì—ì„œë§Œ ë™ì‘
        items = self.items(event.scenePos())
        if not any(isinstance(item, (Node, Connection, MemoItem)) for item in items):
            menu = QMenu()
            
            # ë©”ëª¨ ì¶”ê°€ ë©”ë‰´
            add_memo_action = QAction("ğŸ“ ë©”ëª¨ ì¶”ê°€", None)
            add_memo_action.triggered.connect(lambda: self.add_memo_at(event.scenePos()))
            menu.addAction(add_memo_action)
            
            menu.exec_(event.screenPos())
        else:
            super().contextMenuEvent(event)
            
    def add_memo_at(self, pos):
        """ì§€ì •ëœ ìœ„ì¹˜ì— ë©”ëª¨ ì¶”ê°€"""
        memo = MemoItem(pos.x() - 125, pos.y() - 75)  # ì¤‘ì•™ì— ì˜¤ë„ë¡ ì¡°ì •
        self.addItem(memo)
        if self.main_window:
            self.main_window.log("ë©”ëª¨ê°€ ì¶”ê°€ë˜ì—ˆìŠµë‹ˆë‹¤")


class NodeView(QGraphicsView):
    """ë…¸ë“œ ì—ë””í„° ë·°"""
    def __init__(self, scene):
        super().__init__(scene)
        
        # ë·° ì„¤ì •
        self.setRenderHint(QPainter.Antialiasing)
        self.setViewportUpdateMode(QGraphicsView.FullViewportUpdate)
        self.setDragMode(QGraphicsView.RubberBandDrag)
        
        # ì¤Œ ê´€ë ¨
        self.zoom_factor = 1.15
        self.zoom_level = 0
        self.max_zoom = 10
        self.min_zoom = -10
        
    def wheelEvent(self, event):
        """ë§ˆìš°ìŠ¤ íœ ë¡œ ì¤Œ"""
        # ì¤Œ ì¸/ì•„ì›ƒ
        if event.angleDelta().y() > 0 and self.zoom_level < self.max_zoom:
            self.scale(self.zoom_factor, self.zoom_factor)
            self.zoom_level += 1
        elif event.angleDelta().y() < 0 and self.zoom_level > self.min_zoom:
            self.scale(1/self.zoom_factor, 1/self.zoom_factor)
            self.zoom_level -= 1
            
    def keyPressEvent(self, event):
        """í‚¤ë³´ë“œ ì´ë²¤íŠ¸"""
        if event.key() == Qt.Key_Delete:
            # ì„ íƒëœ ì•„ì´í…œ ì‚­ì œ
            for item in self.scene().selectedItems():
                if isinstance(item, Node):
                    self.delete_node(item)
                elif isinstance(item, Connection):
                    item.remove()
                elif isinstance(item, MemoItem):
                    self.scene().removeItem(item)
        elif event.key() == Qt.Key_Space:
            # ì „ì²´ ë³´ê¸°
            self.fitInView(self.scene().itemsBoundingRect(), Qt.KeepAspectRatio)
            self.zoom_level = 0
            
        super().keyPressEvent(event)
        
    def delete_node(self, node):
        """ë…¸ë“œ ì‚­ì œ"""
        # ì—°ê²°ëœ ëª¨ë“  ì—°ê²°ì„  ì œê±°
        for port in node.input_ports + node.output_ports:
            for connection in port.connections[:]:
                connection.remove()
                    
        # ë…¸ë“œ ì œê±°
        self.scene().removeItem(node)


class LogisticsPredictionSystem(QMainWindow):
    """ë¬¼ë¥˜ì´ë™ ì˜ˆì¸¡ ì‹œìŠ¤í…œ ë©”ì¸ ìœˆë„ìš°"""
    def __init__(self):
        super().__init__()
        self.setWindowTitle("ë¬¼ë¥˜ì´ë™ ì˜ˆì¸¡ ì‹œìŠ¤í…œ - Qt Node Editor")
        self.setGeometry(100, 100, 1400, 800)
        
        # ë‹¤í¬ í…Œë§ˆ ì ìš©
        self.setStyleSheet("""
            QMainWindow {
                background-color: #1e1e1e;
            }
            QDockWidget {
                background-color: #252525;
                color: #ffffff;
            }
            QDockWidget::title {
                background-color: #2d2d2d;
                padding: 5px;
            }
            QPushButton {
                background-color: #3c3c3c;
                color: #ffffff;
                border: 1px solid #555555;
                padding: 5px 10px;
                border-radius: 3px;
            }
            QPushButton:hover {
                background-color: #484848;
            }
            QPushButton:pressed {
                background-color: #2d2d2d;
            }
            QLabel {
                color: #ffffff;
            }
            QListWidget {
                background-color: #2d2d2d;
                color: #ffffff;
                border: 1px solid #444444;
            }
            QListWidget::item:hover {
                background-color: #3c3c3c;
            }
            QTextEdit {
                background-color: #2d2d2d;
                color: #ffffff;
                border: 1px solid #444444;
            }
        """)
        
        # ì”¬ê³¼ ë·° ìƒì„± - parentë¡œ self ì „ë‹¬
        self.scene = NodeScene(self)
        self.view = NodeView(self.scene)
        self.setCentralWidget(self.view)
        
        # UI ì´ˆê¸°í™”
        self.init_ui()
        
        # ì”¬ ì´ë²¤íŠ¸ ì—°ê²°
        self.scene.selectionChanged.connect(self.update_properties)
        
    def init_ui(self):
        """UI ì´ˆê¸°í™”"""
        # ë©”ë‰´ë°”
        self.create_menu_bar()
        
        # íˆ´ë°”
        self.create_toolbar()
        
        # ë… ìœ„ì ¯ë“¤
        self.create_dock_widgets()
        
        # ìƒíƒœë°”
        self.statusBar().showMessage("ì¤€ë¹„ë¨")
        
    def create_menu_bar(self):
        """ë©”ë‰´ë°” ìƒì„±"""
        menubar = self.menuBar()
        
        # íŒŒì¼ ë©”ë‰´
        file_menu = menubar.addMenu("íŒŒì¼")
        
        new_action = QAction("ìƒˆ íŒŒì¼", self)
        new_action.setShortcut("Ctrl+N")
        new_action.triggered.connect(self.new_pipeline)
        file_menu.addAction(new_action)
        
        open_action = QAction("ì—´ê¸°", self)
        open_action.setShortcut("Ctrl+O")
        open_action.triggered.connect(self.load_pipeline)
        file_menu.addAction(open_action)
        
        save_action = QAction("ì €ì¥", self)
        save_action.setShortcut("Ctrl+S")
        save_action.triggered.connect(self.save_pipeline)
        file_menu.addAction(save_action)
        
        file_menu.addSeparator()
        
        exit_action = QAction("ì¢…ë£Œ", self)
        exit_action.setShortcut("Ctrl+Q")
        exit_action.triggered.connect(self.close)
        file_menu.addAction(exit_action)
        
        # í¸ì§‘ ë©”ë‰´
        edit_menu = menubar.addMenu("í¸ì§‘")
        
        # ë©”ëª¨ ì¶”ê°€
        add_memo_action = QAction("ë©”ëª¨ ì¶”ê°€", self)
        add_memo_action.setShortcut("Ctrl+M")
        add_memo_action.triggered.connect(self.add_memo)
        edit_menu.addAction(add_memo_action)
        
        edit_menu.addSeparator()
        
        delete_action = QAction("ì‚­ì œ", self)
        delete_action.setShortcut("Delete")
        delete_action.triggered.connect(self.delete_selected)
        edit_menu.addAction(delete_action)
        
        # ë³´ê¸° ë©”ë‰´
        view_menu = menubar.addMenu("ë³´ê¸°")
        
        grid_action = QAction("ê·¸ë¦¬ë“œ í‘œì‹œ", self)
        grid_action.setCheckable(True)
        grid_action.setChecked(True)
        grid_action.triggered.connect(self.toggle_grid)
        view_menu.addAction(grid_action)
        
        fit_action = QAction("ì „ì²´ ë³´ê¸°", self)
        fit_action.setShortcut("Space")
        fit_action.triggered.connect(self.fit_view)
        view_menu.addAction(fit_action)
        
    def create_toolbar(self):
        """íˆ´ë°” ìƒì„±"""
        toolbar = self.addToolBar("ë©”ì¸ íˆ´ë°”")
        toolbar.setMovable(False)
        
        # ë©”ëª¨ ì¶”ê°€ ë²„íŠ¼
        memo_action = QAction(QIcon(), "ğŸ“ ë©”ëª¨", self)
        memo_action.triggered.connect(self.add_memo)
        toolbar.addAction(memo_action)
        
        toolbar.addSeparator()
        
        # ì‹¤í–‰ ë²„íŠ¼
        run_action = QAction(QIcon(), "ì‹¤í–‰", self)
        run_action.triggered.connect(self.run_pipeline)
        toolbar.addAction(run_action)
        
        # ê²€ì¦ ë²„íŠ¼
        validate_action = QAction(QIcon(), "ê²€ì¦", self)
        validate_action.triggered.connect(self.validate_pipeline)
        toolbar.addAction(validate_action)
        
        toolbar.addSeparator()
        
        # ì¤Œ ì»¨íŠ¸ë¡¤
        zoom_in_action = QAction(QIcon(), "í™•ëŒ€", self)
        zoom_in_action.triggered.connect(lambda: self.view.scale(1.2, 1.2))
        toolbar.addAction(zoom_in_action)
        
        zoom_out_action = QAction(QIcon(), "ì¶•ì†Œ", self)
        zoom_out_action.triggered.connect(lambda: self.view.scale(0.8, 0.8))
        toolbar.addAction(zoom_out_action)
        
        zoom_reset_action = QAction(QIcon(), "100%", self)
        zoom_reset_action.triggered.connect(self.reset_zoom)
        toolbar.addAction(zoom_reset_action)
        
    def create_dock_widgets(self):
        """ë… ìœ„ì ¯ ìƒì„±"""
        # ë…¸ë“œ íŒ”ë ˆíŠ¸
        self.create_node_palette()
        
        # ì†ì„± íŒ¨ë„
        self.create_properties_panel()
        
        # ì½˜ì†” ì¶œë ¥
        self.create_console_panel()
        
    def create_node_palette(self):
        """ë…¸ë“œ íŒ”ë ˆíŠ¸ ìƒì„±"""
        dock = QDockWidget("ë…¸ë“œ íŒ”ë ˆíŠ¸", self)
        dock.setAllowedAreas(Qt.LeftDockWidgetArea | Qt.RightDockWidgetArea)
        
        widget = QWidget()
        layout = QVBoxLayout()
        
        # ë…¸ë“œ ì¹´í…Œê³ ë¦¬ë³„ ë²„íŠ¼ ìƒì„±
        categories = {
            "ë°ì´í„° ì…ë ¥": [
                ("MCS ë¡œê·¸ ë°ì´í„°", NodeType.DATA, "MCS ë¡œê·¸"),
                ("ì§„ë™ì„¼ì„œ ë°ì´í„°", NodeType.DATA, "ì§„ë™ì„¼ì„œ"),
            ],
            "ë°ì´í„° ì „ì²˜ë¦¬": [
                ("ì´ìƒì¹˜ ì œê±°", NodeType.PREPROCESS, "ì´ìƒì¹˜ ì œê±°"),
                ("ì‹œê°„ë³„ ë¶„ë¥˜", NodeType.PREPROCESS, "ì‹œê°„ë³„ ë¶„ë¥˜"),
                ("ê²½ë¡œë³„ ë¶„ë¥˜", NodeType.PREPROCESS, "ê²½ë¡œë³„ ë¶„ë¥˜"),
            ],
            "ë²¡í„° ì €ì¥": [
                ("RAG ë²¡í„° ì €ì¥", NodeType.VECTOR, "RAG ë²¡í„°"),
            ],
            "ì‹œê³„ì—´ ëª¨ë¸": [
                ("LSTM ëª¨ë¸", NodeType.MODEL, "LSTM"),
                ("RNN ëª¨ë¸", NodeType.MODEL, "RNN"),
                ("ARIMA ëª¨ë¸", NodeType.MODEL, "ARIMA"),
            ],
            "ë¶„ì„": [
                ("ê³¼ê±°íŒ¨í„´ ë¶„ì„", NodeType.ANALYSIS, "íŒ¨í„´ë¶„ì„"),
            ],
            "í”„ë¡¬í”„íŠ¸": [
                ("í”„ë¡¬í”„íŠ¸ ìƒì„±", NodeType.PROMPT, "í”„ë¡¬í”„íŠ¸"),
            ],
            "LLM": [
                ("PHI-4 íŒë‹¨/ì¶”ë¡ ", NodeType.LLM, "PHI-4"),
            ],
        }
        
        for category, nodes in categories.items():
            group = QGroupBox(category)
            group_layout = QVBoxLayout()
            
            for label, node_type, name in nodes:
                btn = QPushButton(label)
                btn.clicked.connect(lambda checked, t=node_type, n=name: self.add_node(t, n))
                group_layout.addWidget(btn)
                
            group.setLayout(group_layout)
            layout.addWidget(group)
            
        layout.addStretch()
        widget.setLayout(layout)
        
        scroll = QScrollArea()
        scroll.setWidget(widget)
        scroll.setWidgetResizable(True)
        dock.setWidget(scroll)
        
        self.addDockWidget(Qt.LeftDockWidgetArea, dock)
        
    def create_properties_panel(self):
        """ì†ì„± íŒ¨ë„ ìƒì„±"""
        dock = QDockWidget("ë…¸ë“œ ì†ì„±", self)
        dock.setAllowedAreas(Qt.LeftDockWidgetArea | Qt.RightDockWidgetArea)
        
        self.properties_widget = QTextEdit()
        self.properties_widget.setReadOnly(True)
        self.properties_widget.setPlainText("ë…¸ë“œë¥¼ ì„ íƒí•˜ì„¸ìš”")
        
        dock.setWidget(self.properties_widget)
        self.addDockWidget(Qt.RightDockWidgetArea, dock)
        
    def create_console_panel(self):
        """ì½˜ì†” íŒ¨ë„ ìƒì„±"""
        dock = QDockWidget("ì½˜ì†”", self)
        dock.setAllowedAreas(Qt.BottomDockWidgetArea)
        
        self.console = QTextEdit()
        self.console.setReadOnly(True)
        self.console.setMaximumHeight(150)
        
        dock.setWidget(self.console)
        self.addDockWidget(Qt.BottomDockWidgetArea, dock)
        
    def add_node(self, node_type: NodeType, name: str):
        """ë…¸ë“œ ì¶”ê°€"""
        self.log(f"ë…¸ë“œ ì¶”ê°€ ìš”ì²­: {name} (íƒ€ì…: {node_type.value})")
        
        # ë·° ì¤‘ì•™ì— ë…¸ë“œ ìƒì„±
        view_center = self.view.mapToScene(self.view.rect().center())
        
        node = Node(node_type, name, view_center.x() - 100, view_center.y() - 50)
        self.scene.addItem(node)
        
        self.log(f"{name} ë…¸ë“œê°€ ì¶”ê°€ë˜ì—ˆìŠµë‹ˆë‹¤ (ID: {node.node_id})")
        
        # í”„ë¡¬í”„íŠ¸ ë…¸ë“œì¸ ê²½ìš° ë°”ë¡œ ì„¤ì • ì°½ ì—´ê¸°
        if node_type == NodeType.PROMPT:
            self.log("í”„ë¡¬í”„íŠ¸ ë…¸ë“œ ì¶”ê°€ë¨ - ì„¤ì • ì°½ì„ ì—¬ì‹œë ¤ë©´ ë…¸ë“œë¥¼ ë”ë¸”í´ë¦­í•˜ê±°ë‚˜ ì˜¤ë¥¸ìª½ í´ë¦­í•˜ì„¸ìš”")
            QMessageBox.information(self, "í”„ë¡¬í”„íŠ¸ ë…¸ë“œ",
                "í”„ë¡¬í”„íŠ¸ ë…¸ë“œê°€ ì¶”ê°€ë˜ì—ˆìŠµë‹ˆë‹¤.\n\n"
                "ì„¤ì • ë°©ë²•:\n"
                "1. ë…¸ë“œë¥¼ ë”ë¸”í´ë¦­í•˜ê±°ë‚˜\n"
                "2. ë§ˆìš°ìŠ¤ ì˜¤ë¥¸ìª½ í´ë¦­ â†’ 'âš™ï¸ ë…¸ë“œ ì„¤ì •' ì„ íƒ\n\n"
                "í”„ë¡¬í”„íŠ¸ í…œí”Œë¦¿ì„ ì‘ì„±í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.")
        
    def add_memo(self):
        """ë©”ëª¨ ì¶”ê°€"""
        view_center = self.view.mapToScene(self.view.rect().center())
        memo = MemoItem(view_center.x() - 125, view_center.y() - 75)
        self.scene.addItem(memo)
        self.log("ë©”ëª¨ê°€ ì¶”ê°€ë˜ì—ˆìŠµë‹ˆë‹¤ - ë”ë¸”í´ë¦­ìœ¼ë¡œ í¸ì§‘í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤")
        
    def configure_node(self, node):
        """ë…¸ë“œ ì„¤ì • ëŒ€í™”ìƒì"""
        self.log(f"ë…¸ë“œ ì„¤ì • ì‹œì‘: {node.name} ({node.node_type.value})")
        
        dialog = QDialog(self)
        dialog.setWindowTitle(f"{node.name} ì„¤ì •")
        dialog.setModal(True)
        dialog.setMinimumWidth(600)  # ìµœì†Œ ë„ˆë¹„ ì„¤ì •
        dialog.setMinimumHeight(500)  # ìµœì†Œ ë†’ì´ ì„¤ì •
        
        # ë‹¤ì´ì–¼ë¡œê·¸ ìŠ¤íƒ€ì¼ ì„¤ì •
        dialog.setStyleSheet("""
            QDialog {
                background-color: #2d2d2d;
                color: #ffffff;
            }
            QLabel {
                color: #ffffff;
            }
            QGroupBox {
                color: #ffffff;
                border: 1px solid #555555;
                border-radius: 5px;
                margin-top: 10px;
                padding-top: 10px;
            }
            QGroupBox::title {
                subcontrol-origin: margin;
                left: 10px;
                padding: 0 5px 0 5px;
            }
        """)
        
        # ìŠ¤í¬ë¡¤ ê°€ëŠ¥í•œ ì˜ì—­ ìƒì„±
        scroll = QScrollArea()
        scroll.setWidgetResizable(True)
        scroll_widget = QWidget()
        scroll_layout = QVBoxLayout()
        
        # ë…¸ë“œ íƒ€ì…ë³„ ì„¤ì • UI
        if node.node_type == NodeType.DATA:
            self.create_data_config(scroll_layout, node)
        elif node.node_type == NodeType.PREPROCESS:
            self.create_preprocess_config(scroll_layout, node)
        elif node.node_type == NodeType.MODEL:
            self.create_model_config(scroll_layout, node)
        elif node.node_type == NodeType.VECTOR:
            self.create_vector_config(scroll_layout, node)
        elif node.node_type == NodeType.ANALYSIS:
            self.create_analysis_config(scroll_layout, node)
        elif node.node_type == NodeType.PROMPT:
            self.log("í”„ë¡¬í”„íŠ¸ ì„¤ì • UI ìƒì„± ì¤‘...")
            self.create_prompt_config(scroll_layout, node)
        elif node.node_type == NodeType.LLM:
            self.create_llm_config(scroll_layout, node)
            
        scroll_widget.setLayout(scroll_layout)
        scroll.setWidget(scroll_widget)
        
        # ë©”ì¸ ë ˆì´ì•„ì›ƒ
        main_layout = QVBoxLayout()
        main_layout.addWidget(scroll, 1)
        
        # ë²„íŠ¼
        buttons = QDialogButtonBox(QDialogButtonBox.Ok | QDialogButtonBox.Cancel)
        buttons.accepted.connect(lambda: self.save_node_config(dialog, node))
        buttons.rejected.connect(dialog.reject)
        main_layout.addWidget(buttons)
        
        dialog.setLayout(main_layout)
        
        self.log(f"ëŒ€í™”ìƒì í‘œì‹œ ì¤‘...")
        result = dialog.exec_()
        self.log(f"ëŒ€í™”ìƒì ê²°ê³¼: {'í™•ì¸' if result else 'ì·¨ì†Œ'}")
        
    def create_data_config(self, layout, node):
        """ë°ì´í„° ë…¸ë“œ ì„¤ì • UI"""
        layout.addWidget(QLabel("ë°ì´í„° ì†ŒìŠ¤ ì„¤ì •"))
        
        # íŒŒì¼ ê²½ë¡œ
        layout.addWidget(QLabel("íŒŒì¼ ê²½ë¡œ:"))
        path_edit = QLineEdit()
        path_edit.setObjectName("path")
        layout.addWidget(path_edit)
        
        # ë°ì´í„° í˜•ì‹
        layout.addWidget(QLabel("ë°ì´í„° í˜•ì‹:"))
        format_combo = QComboBox()
        format_combo.addItems(["CSV", "JSON", "Excel", "Database"])
        format_combo.setObjectName("format")
        layout.addWidget(format_combo)
        
        # ìƒ˜í”Œë§ ê°„ê²©
        layout.addWidget(QLabel("ìƒ˜í”Œë§ ê°„ê²© (ì´ˆ):"))
        sampling_spin = QSpinBox()
        sampling_spin.setRange(1, 3600)
        sampling_spin.setValue(60)
        sampling_spin.setObjectName("sampling")
        layout.addWidget(sampling_spin)
        
    def create_preprocess_config(self, layout, node):
        """ì „ì²˜ë¦¬ ë…¸ë“œ ì„¤ì • UI"""
        layout.addWidget(QLabel("ì „ì²˜ë¦¬ ì„¤ì •"))
        
        if "ì´ìƒì¹˜" in node.name:
            layout.addWidget(QLabel("ì´ìƒì¹˜ íƒì§€ ë°©ë²•:"))
            method_combo = QComboBox()
            method_combo.addItems(["IQR", "Z-Score", "Isolation Forest", "DBSCAN"])
            method_combo.setObjectName("method")
            layout.addWidget(method_combo)
            
            layout.addWidget(QLabel("ì„ê³„ê°’:"))
            threshold_spin = QDoubleSpinBox()
            threshold_spin.setRange(0.1, 5.0)
            threshold_spin.setValue(1.5)
            threshold_spin.setSingleStep(0.1)
            threshold_spin.setObjectName("threshold")
            layout.addWidget(threshold_spin)
            
        elif "ì‹œê°„ë³„" in node.name:
            layout.addWidget(QLabel("ì‹œê°„ ë‹¨ìœ„:"))
            time_combo = QComboBox()
            time_combo.addItems(["30ë¶„", "1ì‹œê°„", "2ì‹œê°„", "4ì‹œê°„", "6ì‹œê°„", "12ì‹œê°„", "24ì‹œê°„"])
            time_combo.setCurrentText("1ì‹œê°„")
            time_combo.setObjectName("time_unit")
            layout.addWidget(time_combo)
            
        elif "ê²½ë¡œë³„" in node.name:
            layout.addWidget(QLabel("ê²½ë¡œ ê·¸ë£¹í™” ê¸°ì¤€:"))
            route_combo = QComboBox()
            route_combo.addItems(["ì¶œë°œì§€-ë„ì°©ì§€", "ì£¼ìš” ê²½ìœ ì§€", "ìš´ì†¡ ìˆ˜ë‹¨", "ê±°ë¦¬ë³„"])
            route_combo.setObjectName("route_grouping")
            layout.addWidget(route_combo)
            
    def create_model_config(self, layout, node):
        """ëª¨ë¸ ë…¸ë“œ ì„¤ì • UI"""
        layout.addWidget(QLabel("ëª¨ë¸ ì„¤ì •"))
        
        # ì˜ˆì¸¡ ê¸°ê°„
        layout.addWidget(QLabel("ì˜ˆì¸¡ ê¸°ê°„:"))
        period_combo = QComboBox()
        period_combo.addItems(["6ì‹œê°„", "12ì‹œê°„", "24ì‹œê°„", "48ì‹œê°„", "72ì‹œê°„", "1ì£¼ì¼"])
        period_combo.setCurrentText("24ì‹œê°„")
        period_combo.setObjectName("period")
        layout.addWidget(period_combo)
        
        if "LSTM" in node.name or "RNN" in node.name:
            layout.addWidget(QLabel("ì€ë‹‰ì¸µ ìˆ˜:"))
            layers_spin = QSpinBox()
            layers_spin.setRange(1, 10)
            layers_spin.setValue(3)
            layers_spin.setObjectName("layers")
            layout.addWidget(layers_spin)
            
            layout.addWidget(QLabel("ìœ ë‹› ìˆ˜:"))
            units_spin = QSpinBox()
            units_spin.setRange(32, 512)
            units_spin.setValue(128)
            units_spin.setSingleStep(32)
            units_spin.setObjectName("units")
            layout.addWidget(units_spin)
            
            layout.addWidget(QLabel("ë°°ì¹˜ í¬ê¸°:"))
            batch_spin = QSpinBox()
            batch_spin.setRange(1, 128)
            batch_spin.setValue(32)
            batch_spin.setObjectName("batch_size")
            layout.addWidget(batch_spin)
            
        elif "ARIMA" in node.name:
            layout.addWidget(QLabel("p (ìê¸°íšŒê·€):"))
            p_spin = QSpinBox()
            p_spin.setRange(0, 10)
            p_spin.setValue(2)
            p_spin.setObjectName("p")
            layout.addWidget(p_spin)
            
            layout.addWidget(QLabel("d (ì°¨ë¶„):"))
            d_spin = QSpinBox()
            d_spin.setRange(0, 5)
            d_spin.setValue(1)
            d_spin.setObjectName("d")
            layout.addWidget(d_spin)
            
            layout.addWidget(QLabel("q (ì´ë™í‰ê· ):"))
            q_spin = QSpinBox()
            q_spin.setRange(0, 10)
            q_spin.setValue(2)
            q_spin.setObjectName("q")
            layout.addWidget(q_spin)
            
    def create_vector_config(self, layout, node):
        """ë²¡í„° ì €ì¥ ë…¸ë“œ ì„¤ì • UI"""
        layout.addWidget(QLabel("RAG ë²¡í„° ì €ì¥ ì„¤ì •"))
        
        layout.addWidget(QLabel("ì„ë² ë”© ëª¨ë¸:"))
        embed_combo = QComboBox()
        embed_combo.addItems(["OpenAI", "Sentence-BERT", "Custom", "Multilingual"])
        embed_combo.setObjectName("embedding_model")
        layout.addWidget(embed_combo)
        
        layout.addWidget(QLabel("ë²¡í„° ì°¨ì›:"))
        dim_spin = QSpinBox()
        dim_spin.setRange(128, 2048)
        dim_spin.setValue(768)
        dim_spin.setSingleStep(128)
        dim_spin.setObjectName("vector_dim")
        layout.addWidget(dim_spin)
        
        layout.addWidget(QLabel("ë²¡í„° ì €ì¥ì†Œ:"))
        store_combo = QComboBox()
        store_combo.addItems(["ChromaDB", "Pinecone", "Weaviate", "FAISS"])
        store_combo.setObjectName("vector_store")
        layout.addWidget(store_combo)
        
    def create_analysis_config(self, layout, node):
        """ë¶„ì„ ë…¸ë“œ ì„¤ì • UI"""
        layout.addWidget(QLabel("íŒ¨í„´ ë¶„ì„ ì„¤ì •"))
        
        layout.addWidget(QLabel("ë¶„ì„ ê¸°ê°„:"))
        period_combo = QComboBox()
        period_combo.addItems(["7ì¼", "14ì¼", "30ì¼", "90ì¼", "180ì¼", "1ë…„"])
        period_combo.setCurrentText("30ì¼")
        period_combo.setObjectName("analysis_period")
        layout.addWidget(period_combo)
        
        layout.addWidget(QLabel("íŒ¨í„´ ìœ í˜•:"))
        patterns = ["ê³„ì ˆì„±", "ì£¼ê¸°ì„±", "íŠ¸ë Œë“œ", "ì´ìƒíŒ¨í„´", "í”¼í¬ì‹œê°„"]
        for i, pattern in enumerate(patterns):
            check = QCheckBox(pattern)
            check.setChecked(True)
            check.setObjectName(f"pattern_{i}")
            layout.addWidget(check)
            
    def create_prompt_config(self, layout, node):
        """í”„ë¡¬í”„íŠ¸ ë…¸ë“œ ì„¤ì • UI"""
        # ì œëª©
        title_label = QLabel("<h3>í”„ë¡¬í”„íŠ¸ ìƒì„± ì„¤ì •</h3>")
        layout.addWidget(title_label)
        
        # êµ¬ë¶„ì„ 
        line = QFrame()
        line.setFrameShape(QFrame.HLine)
        line.setFrameShadow(QFrame.Sunken)
        layout.addWidget(line)
        
        # í”„ë¡¬í”„íŠ¸ í…œí”Œë¦¿ ì„¹ì…˜
        template_label = QLabel("<b>í”„ë¡¬í”„íŠ¸ í…œí”Œë¦¿:</b>")
        layout.addWidget(template_label)
        
        # í…ìŠ¤íŠ¸ í¸ì§‘ê¸°
        template_text = QTextEdit()
        template_text.setObjectName("template")
        
        # ê¸°ë³¸ í…œí”Œë¦¿
        default_template = """ë‹¤ìŒ ë¬¼ë¥˜ ë°ì´í„°ë¥¼ ë¶„ì„í•˜ì—¬ ì˜ˆì¸¡í•´ì£¼ì„¸ìš”:
- í˜„ì¬ ìƒí™©: {current_status}
- ê³¼ê±° íŒ¨í„´: {past_patterns}
- ì‹œê³„ì—´ ì˜ˆì¸¡: {time_series_prediction}
- íŠ¹ì´ì‚¬í•­: {anomalies}

24ì‹œê°„ ì´ë‚´ì˜ ë¬¼ë¥˜ ì´ë™ì„ ì˜ˆì¸¡í•˜ê³ ,
ì£¼ì˜í•´ì•¼ í•  ë¦¬ìŠ¤í¬ë¥¼ ë¶„ì„í•´ì£¼ì„¸ìš”."""
        
        # ê¸°ì¡´ ì„¤ì •ì´ ìˆìœ¼ë©´ ë¶ˆëŸ¬ì˜¤ê¸°, ì—†ìœ¼ë©´ ê¸°ë³¸ í…œí”Œë¦¿ ì‚¬ìš©
        if 'template' in node.settings:
            template_text.setPlainText(node.settings['template'])
        else:
            template_text.setPlainText(default_template)
        
        # í…ìŠ¤íŠ¸ í¸ì§‘ê¸° ìŠ¤íƒ€ì¼ ì„¤ì •
        template_text.setStyleSheet("""
            QTextEdit {
                background-color: #3c3c3c;
                color: #ffffff;
                border: 2px solid #555555;
                border-radius: 5px;
                padding: 10px;
                font-family: Consolas, 'Courier New', monospace;
                font-size: 12px;
            }
        """)
        template_text.setMinimumHeight(250)
        template_text.setMaximumHeight(400)
        
        layout.addWidget(template_text)
        
        # ë³€ìˆ˜ ì„¤ëª… ê·¸ë£¹ë°•ìŠ¤
        variables_group = QGroupBox("ì‚¬ìš© ê°€ëŠ¥í•œ ë³€ìˆ˜")
        variables_layout = QVBoxLayout()
        
        variables_info = [
            ("{current_status}", "í˜„ì¬ ë¬¼ë¥˜ ìƒí™©"),
            ("{past_patterns}", "ê³¼ê±° íŒ¨í„´ ë¶„ì„ ê²°ê³¼"),
            ("{time_series_prediction}", "ì‹œê³„ì—´ ì˜ˆì¸¡ ê²°ê³¼"),
            ("{anomalies}", "ì´ìƒ ì§•í›„")
        ]
        
        for var, desc in variables_info:
            var_label = QLabel(f"<code style='background-color: #555555; padding: 2px;'>{var}</code> - {desc}")
            variables_layout.addWidget(var_label)
        
        variables_group.setLayout(variables_layout)
        layout.addWidget(variables_group)
        
        # ì»¨í…ìŠ¤íŠ¸ ì„¹ì…˜
        layout.addSpacing(10)
        context_label = QLabel("<b>í¬í•¨í•  ì»¨í…ìŠ¤íŠ¸:</b>")
        layout.addWidget(context_label)
        
        contexts = ["ë‚ ì”¨ ì •ë³´", "êµí†µ ìƒí™©", "ê³¼ê±° ì§€ì—° ì´ë ¥", "íŠ¹ë³„ ì´ë²¤íŠ¸"]
        for i, context in enumerate(contexts):
            check = QCheckBox(context)
            # ê¸°ì¡´ ì„¤ì •ì´ ìˆìœ¼ë©´ ë¶ˆëŸ¬ì˜¤ê¸°
            if f'context_{i}' in node.settings:
                check.setChecked(node.settings[f'context_{i}'])
            else:
                check.setChecked(True)
            check.setObjectName(f"context_{i}")
            check.setStyleSheet("QCheckBox { color: #ffffff; }")
            layout.addWidget(check)
        
        # í…ŒìŠ¤íŠ¸ ë²„íŠ¼ ì¶”ê°€
        test_btn = QPushButton("í…œí”Œë¦¿ í…ŒìŠ¤íŠ¸")
        test_btn.clicked.connect(lambda: self.test_prompt_template(template_text.toPlainText()))
        layout.addWidget(test_btn)
            
    def create_llm_config(self, layout, node):
        """LLM ë…¸ë“œ ì„¤ì • UI"""
        layout.addWidget(QLabel("PHI-4 LLM ì„¤ì •"))
        
        layout.addWidget(QLabel("Temperature:"))
        temp_slider = QSlider(Qt.Horizontal)
        temp_slider.setRange(0, 100)
        temp_slider.setValue(70)
        temp_slider.setObjectName("temperature")
        temp_label = QLabel("0.7")
        temp_slider.valueChanged.connect(lambda v: temp_label.setText(f"{v/100:.1f}"))
        
        temp_layout = QHBoxLayout()
        temp_layout.addWidget(temp_slider)
        temp_layout.addWidget(temp_label)
        layout.addLayout(temp_layout)
        
        layout.addWidget(QLabel("Max Tokens:"))
        tokens_spin = QSpinBox()
        tokens_spin.setRange(512, 8192)
        tokens_spin.setValue(2048)
        tokens_spin.setSingleStep(512)
        tokens_spin.setObjectName("max_tokens")
        layout.addWidget(tokens_spin)
        
        layout.addWidget(QLabel("ì¶”ë¡  ëª¨ë“œ:"))
        mode_combo = QComboBox()
        mode_combo.addItems(["ì¢…í•©ë¶„ì„", "ë¦¬ìŠ¤í¬ í‰ê°€", "ìµœì í™” ì œì•ˆ", "ì´ìƒíƒì§€"])
        mode_combo.setObjectName("inference_mode")
        layout.addWidget(mode_combo)
        
        layout.addWidget(QLabel("ì¶œë ¥ í˜•ì‹:"))
        format_combo = QComboBox()
        format_combo.addItems(["êµ¬ì¡°í™”ëœ JSON", "ìì—°ì–´ ì„¤ëª…", "ëŒ€ì‹œë³´ë“œ ë°ì´í„°", "ë¦¬í¬íŠ¸"])
        format_combo.setObjectName("output_format")
        layout.addWidget(format_combo)
        
    def test_prompt_template(self, template):
        """í”„ë¡¬í”„íŠ¸ í…œí”Œë¦¿ í…ŒìŠ¤íŠ¸"""
        # í…ŒìŠ¤íŠ¸ìš© ìƒ˜í”Œ ë°ì´í„°ë¡œ ë³€ìˆ˜ ì±„ìš°ê¸°
        test_prompt = template
        test_prompt = test_prompt.replace("{current_status}", "ì •ìƒ ìš´ì˜ ì¤‘ (í…ŒìŠ¤íŠ¸)")
        test_prompt = test_prompt.replace("{past_patterns}", "['ì£¼ì¤‘ ì˜¤í›„ í”¼í¬', 'ê¸ˆìš”ì¼ ì¦ê°€'] (í…ŒìŠ¤íŠ¸)")
        test_prompt = test_prompt.replace("{time_series_prediction}", "{'24h': 1234í†¤} (í…ŒìŠ¤íŠ¸)")
        test_prompt = test_prompt.replace("{anomalies}", "['7/15 ë¹„ì •ìƒ ì¦ê°€'] (í…ŒìŠ¤íŠ¸)")
        
        # ê²°ê³¼ í‘œì‹œ
        msg = QMessageBox()
        msg.setWindowTitle("í”„ë¡¬í”„íŠ¸ í…œí”Œë¦¿ í…ŒìŠ¤íŠ¸")
        msg.setText("ë³€ìˆ˜ê°€ ì±„ì›Œì§„ í”„ë¡¬í”„íŠ¸ ë¯¸ë¦¬ë³´ê¸°:")
        msg.setDetailedText(test_prompt)
        msg.setIcon(QMessageBox.Information)
        msg.exec_()
        
    def save_node_config(self, dialog, node):
        """ë…¸ë“œ ì„¤ì • ì €ì¥"""
        # ëŒ€í™”ìƒìì—ì„œ ì„¤ì • ê°’ ìˆ˜ì§‘
        settings = {}
        for child in dialog.findChildren(QWidget):
            if child.objectName():
                if isinstance(child, QLineEdit):
                    settings[child.objectName()] = child.text()
                elif isinstance(child, QComboBox):
                    settings[child.objectName()] = child.currentText()
                elif isinstance(child, QSpinBox) or isinstance(child, QDoubleSpinBox):
                    settings[child.objectName()] = child.value()
                elif isinstance(child, QCheckBox):
                    settings[child.objectName()] = child.isChecked()
                elif isinstance(child, QTextEdit):
                    settings[child.objectName()] = child.toPlainText()
                elif isinstance(child, QSlider):
                    settings[child.objectName()] = child.value() / 100
                    
        node.settings = settings
        node.is_configured = True
        node.update_status()
        
        self.log(f"{node.name} ì„¤ì •ì´ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤")
        self.update_properties()
        
        dialog.accept()
        
    def new_pipeline(self):
        """ìƒˆ íŒŒì´í”„ë¼ì¸"""
        reply = QMessageBox.question(self, "í™•ì¸", "í˜„ì¬ ì‘ì—…ì„ ì§€ìš°ê³  ìƒˆë¡œ ì‹œì‘í•˜ì‹œê² ìŠµë‹ˆê¹Œ?")
        if reply == QMessageBox.Yes:
            self.scene.clear()
            self.log("ìƒˆ íŒŒì´í”„ë¼ì¸ì´ ìƒì„±ë˜ì—ˆìŠµë‹ˆë‹¤")
            
    def save_pipeline(self):
        """íŒŒì´í”„ë¼ì¸ ì €ì¥"""
        filename, _ = QFileDialog.getSaveFileName(self, "íŒŒì´í”„ë¼ì¸ ì €ì¥", "", "JSON Files (*.json)")
        if filename:
            data = {
                "nodes": [],
                "connections": [],
                "memos": []
            }
            
            # ë…¸ë“œ ì •ë³´ ìˆ˜ì§‘
            node_map = {}
            for item in self.scene.items():
                if isinstance(item, Node):
                    node_data = {
                        "id": item.node_id,
                        "type": item.node_type.value,
                        "name": item.name,
                        "x": item.x(),
                        "y": item.y(),
                        "configured": item.is_configured,
                        "settings": item.settings
                    }
                    data["nodes"].append(node_data)
                    node_map[item] = item.node_id
                    
            # ì—°ê²° ì •ë³´ ìˆ˜ì§‘
            for item in self.scene.items():
                if isinstance(item, Connection) and item.start_port and item.end_port:
                    start_node = item.start_port.parentItem()
                    end_node = item.end_port.parentItem()
                    
                    if start_node in node_map and end_node in node_map:
                        conn_data = {
                            "start": node_map[start_node],
                            "start_port": start_node.output_ports.index(item.start_port),
                            "end": node_map[end_node],
                            "end_port": end_node.input_ports.index(item.end_port)
                        }
                        data["connections"].append(conn_data)
                        
            # ë©”ëª¨ ì •ë³´ ìˆ˜ì§‘
            for item in self.scene.items():
                if isinstance(item, MemoItem):
                    data["memos"].append(item.get_data())
                        
            # JSON íŒŒì¼ë¡œ ì €ì¥
            with open(filename, 'w', encoding='utf-8') as f:
                json.dump(data, f, indent=2, ensure_ascii=False)
                
            self.log(f"íŒŒì´í”„ë¼ì¸ì´ ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤: {filename}")
            
    def load_pipeline(self):
        """íŒŒì´í”„ë¼ì¸ ë¶ˆëŸ¬ì˜¤ê¸°"""
        filename, _ = QFileDialog.getOpenFileName(self, "íŒŒì´í”„ë¼ì¸ ì—´ê¸°", "", "JSON Files (*.json)")
        if filename:
            with open(filename, 'r', encoding='utf-8') as f:
                data = json.load(f)
                
            # ì”¬ ì´ˆê¸°í™”
            self.scene.clear()
            
            # ë…¸ë“œ ìƒì„±
            node_map = {}
            for node_data in data["nodes"]:
                node_type = NodeType(node_data["type"])
                node = Node(node_type, node_data["name"], node_data["x"], node_data["y"])
                node.is_configured = node_data.get("configured", False)
                node.settings = node_data.get("settings", {})
                node.update_status()
                
                self.scene.addItem(node)
                node_map[node_data["id"]] = node
                
            # ì—°ê²° ìƒì„±
            for conn_data in data["connections"]:
                start_node = node_map[conn_data["start"]]
                end_node = node_map[conn_data["end"]]
                
                start_port = start_node.output_ports[conn_data.get("start_port", 0)]
                end_port = end_node.input_ports[conn_data.get("end_port", 0)]
                
                connection = Connection(start_port, end_port)
                self.scene.addItem(connection)
                
            # ë©”ëª¨ ìƒì„±
            if "memos" in data:
                for memo_data in data["memos"]:
                    memo = MemoItem()
                    memo.set_data(memo_data)
                    self.scene.addItem(memo)
                
            self.log(f"íŒŒì´í”„ë¼ì¸ì„ ë¶ˆëŸ¬ì™”ìŠµë‹ˆë‹¤: {filename}")
            
    def delete_selected(self):
        """ì„ íƒëœ ì•„ì´í…œ ì‚­ì œ"""
        for item in self.scene.selectedItems():
            if isinstance(item, Node):
                self.view.delete_node(item)
            elif isinstance(item, Connection):
                item.remove()
            elif isinstance(item, MemoItem):
                self.scene.removeItem(item)
                
    def toggle_grid(self, checked):
        """ê·¸ë¦¬ë“œ í‘œì‹œ í† ê¸€"""
        self.scene.grid_visible = checked
        self.scene.update()
        
    def fit_view(self):
        """ì „ì²´ ë³´ê¸°"""
        self.view.fitInView(self.scene.itemsBoundingRect(), Qt.KeepAspectRatio)
        self.view.zoom_level = 0
        
    def reset_zoom(self):
        """ì¤Œ ì´ˆê¸°í™”"""
        self.view.resetTransform()
        self.view.zoom_level = 0
        
    def validate_pipeline(self):
        """íŒŒì´í”„ë¼ì¸ ê²€ì¦"""
        errors = []
        warnings = []
        
        # ë…¸ë“œ ìˆ˜ì§‘
        nodes = [item for item in self.scene.items() if isinstance(item, Node)]
        
        if not nodes:
            errors.append("ë…¸ë“œê°€ ì—†ìŠµë‹ˆë‹¤")
        else:
            # ë°ì´í„° ì…ë ¥ ë…¸ë“œ í™•ì¸
            data_nodes = [n for n in nodes if n.node_type == NodeType.DATA]
            if not data_nodes:
                errors.append("ë°ì´í„° ì…ë ¥ ë…¸ë“œê°€ í•„ìš”í•©ë‹ˆë‹¤")
                
            # LLM ë…¸ë“œ í™•ì¸
            llm_nodes = [n for n in nodes if n.node_type == NodeType.LLM]
            if not llm_nodes:
                errors.append("LLM ë…¸ë“œê°€ í•„ìš”í•©ë‹ˆë‹¤")
                
            # ë¯¸ì„¤ì • ë…¸ë“œ í™•ì¸
            unconfigured = [n.name for n in nodes if not n.is_configured]
            if unconfigured:
                warnings.append(f"ë¯¸ì„¤ì • ë…¸ë“œ: {', '.join(unconfigured)}")
                
            # ì—°ê²° í™•ì¸
            for node in nodes:
                if node.node_type != NodeType.DATA:
                    has_input = any(port.connections for port in node.input_ports)
                    if not has_input:
                        warnings.append(f"{node.name}ì— ì…ë ¥ì´ ì—†ìŠµë‹ˆë‹¤")
                        
        # ê²°ê³¼ í‘œì‹œ
        if errors or warnings:
            msg = ""
            if errors:
                msg += "ì˜¤ë¥˜:\n" + "\n".join(f"- {e}" for e in errors) + "\n\n"
            if warnings:
                msg += "ê²½ê³ :\n" + "\n".join(f"- {w}" for w in warnings)
                
            QMessageBox.warning(self, "ê²€ì¦ ê²°ê³¼", msg)
            self.log("íŒŒì´í”„ë¼ì¸ ê²€ì¦ ì‹¤íŒ¨")
        else:
            QMessageBox.information(self, "ê²€ì¦ ê²°ê³¼", "íŒŒì´í”„ë¼ì¸ì´ ìœ íš¨í•©ë‹ˆë‹¤!")
            self.log("íŒŒì´í”„ë¼ì¸ ê²€ì¦ ì„±ê³µ")
            
    def run_pipeline(self):
        """íŒŒì´í”„ë¼ì¸ ì‹¤í–‰"""
        # ê²€ì¦
        self.validate_pipeline()

        self.log("íŒŒì´í”„ë¼ì¸ ì‹¤í–‰ ì‹œì‘...")
        
        # ë…¸ë“œ ì‹¤í–‰ ìˆœì„œ ê²°ì •
        execution_order = self.determine_execution_order()
        
        # ì‹¤í–‰ ê²°ê³¼ ì €ì¥
        node_outputs = {}
        
        # ìˆœì°¨ì ìœ¼ë¡œ ë…¸ë“œ ì‹¤í–‰
        for node in execution_order:
            self.log(f"ì‹¤í–‰ ì¤‘: {node.name}")
            
            # ì…ë ¥ ë°ì´í„° ìˆ˜ì§‘
            input_data = {}
            for port in node.input_ports:
                for connection in port.connections:
                    source_node = connection.start_port.parentItem()
                    if source_node in node_outputs:
                        input_data[source_node.node_type.value] = node_outputs[source_node]
            
            # ë…¸ë“œ ì‹¤í–‰
            output = self.execute_node(node, input_data)
            node_outputs[node] = output
        
        # ìµœì¢… ê²°ê³¼ í‘œì‹œ
        self.show_execution_results(node_outputs)
        
    def determine_execution_order(self):
        """ë…¸ë“œ ì‹¤í–‰ ìˆœì„œ ê²°ì • (ìœ„ìƒ ì •ë ¬)"""
        nodes = [item for item in self.scene.items() if isinstance(item, Node)]
        
        # ì§„ì… ì°¨ìˆ˜ ê³„ì‚°
        in_degree = {node: 0 for node in nodes}
        for node in nodes:
            for port in node.input_ports:
                in_degree[node] += len(port.connections)
        
        # ì§„ì… ì°¨ìˆ˜ê°€ 0ì¸ ë…¸ë“œë¶€í„° ì‹œì‘
        queue = [node for node in nodes if in_degree[node] == 0]
        execution_order = []
        
        while queue:
            current = queue.pop(0)
            execution_order.append(current)
            
            # ì—°ê²°ëœ ë‹¤ìŒ ë…¸ë“œë“¤ì˜ ì§„ì… ì°¨ìˆ˜ ê°ì†Œ
            for port in current.output_ports:
                for connection in port.connections:
                    next_node = connection.end_port.parentItem()
                    in_degree[next_node] -= 1
                    if in_degree[next_node] == 0:
                        queue.append(next_node)
        
        return execution_order
        
    def execute_node(self, node, input_data):
        """ê°œë³„ ë…¸ë“œ ì‹¤í–‰"""
        output = {}
        
        if node.node_type == NodeType.DATA:
            # ë°ì´í„° ë¡œë“œ ì‹œë®¬ë ˆì´ì…˜
            output = {
                "data": "MCS ë¡œê·¸ ë°ì´í„° ë¡œë“œë¨",
                "records": 10000,
                "time_range": "2025-07-01 ~ 2025-07-30"
            }
            
        elif node.node_type == NodeType.PREPROCESS:
            # ì „ì²˜ë¦¬ ì‹¤í–‰
            if "ì´ìƒì¹˜" in node.name:
                output = {
                    "cleaned_data": "ì´ìƒì¹˜ ì œê±° ì™„ë£Œ",
                    "removed": 234,
                    "method": node.settings.get("method", "IQR")
                }
            elif "ì‹œê°„ë³„" in node.name:
                output = {
                    "grouped_data": "ì‹œê°„ë³„ ë¶„ë¥˜ ì™„ë£Œ",
                    "time_unit": node.settings.get("time_unit", "1ì‹œê°„")
                }
                
        elif node.node_type == NodeType.VECTOR:
            # RAG ë²¡í„° ì €ì¥
            output = {
                "vector_store": node.settings.get("vector_store", "ChromaDB"),
                "embeddings": "ë²¡í„° ì €ì¥ ì™„ë£Œ",
                "dimension": node.settings.get("vector_dim", 768)
            }
            
        elif node.node_type == NodeType.MODEL:
            # ì‹œê³„ì—´ ëª¨ë¸ ì‹¤í–‰
            output = {
                "prediction": "í–¥í›„ 24ì‹œê°„ ì˜ˆì¸¡ ì™„ë£Œ",
                "accuracy": 92.3,
                "forecast": {
                    "6h": 1100,
                    "12h": 1250,
                    "24h": 1234
                }
            }
            
        elif node.node_type == NodeType.ANALYSIS:
            # íŒ¨í„´ ë¶„ì„
            output = {
                "patterns": ["ì£¼ì¤‘ ì˜¤í›„ í”¼í¬", "ê¸ˆìš”ì¼ ì¦ê°€", "ì›”ìš”ì¼ ê°ì†Œ"],
                "anomalies": ["7/15 ë¹„ì •ìƒ ì¦ê°€", "7/22 ê¸‰ê°"],
                "period": node.settings.get("analysis_period", "30ì¼")
            }
            
        elif node.node_type == NodeType.PROMPT:
            # í”„ë¡¬í”„íŠ¸ ìƒì„±
            template = node.settings.get("template", "")
            
            # ì…ë ¥ ë°ì´í„°ë¡œ í”„ë¡¬í”„íŠ¸ ì±„ìš°ê¸°
            filled_prompt = template
            
            # ì»¨í…ìŠ¤íŠ¸ ì¶”ê°€
            contexts = []
            for i in range(4):
                if node.settings.get(f"context_{i}", False):
                    contexts.append(["ë‚ ì”¨ ì •ë³´", "êµí†µ ìƒí™©", "ê³¼ê±° ì§€ì—° ì´ë ¥", "íŠ¹ë³„ ì´ë²¤íŠ¸"][i])
            
            if "analysis" in input_data:
                filled_prompt = filled_prompt.replace("{past_patterns}",
                    str(input_data["analysis"].get("patterns", [])))
                filled_prompt = filled_prompt.replace("{anomalies}",
                    str(input_data["analysis"].get("anomalies", [])))
                    
            if "model" in input_data:
                filled_prompt = filled_prompt.replace("{time_series_prediction}",
                    str(input_data["model"].get("forecast", {})))
                    
            filled_prompt = filled_prompt.replace("{current_status}",
                "í˜„ì¬ ì •ìƒ ìš´ì˜ ì¤‘")
            
            output = {
                "prompt": filled_prompt,
                "contexts": contexts
            }
            
        elif node.node_type == NodeType.LLM:
            # LLM ì‹¤í–‰
            prompt_data = input_data.get("prompt", {})
            prompt_text = prompt_data.get("prompt", "ê¸°ë³¸ í”„ë¡¬í”„íŠ¸")
            
            # LLM ì‘ë‹µ ì‹œë®¬ë ˆì´ì…˜
            output = {
                "response": f"""PHI-4 LLM ë¶„ì„ ê²°ê³¼:
                
í”„ë¡¬í”„íŠ¸: {prompt_text[:100]}...

=== ì˜ˆì¸¡ ê²°ê³¼ ===
í–¥í›„ 24ì‹œê°„ ë¬¼ë¥˜ ì´ë™ ì˜ˆì¸¡:
- ì˜ˆìƒ ë¬¼ë™ëŸ‰: 1,234í†¤ (Â±5%)
- ì£¼ìš” ê²½ë¡œ: ì„œìš¸â†’ë¶€ì‚° (45%), ì¸ì²œâ†’ê´‘ì£¼ (30%)
- ë³‘ëª© êµ¬ê°„: ê²½ë¶€ê³ ì†ë„ë¡œ (14:00-18:00)
- ì§€ì—° ìœ„í—˜ë„: ì¤‘ê°„ (ë‚ ì”¨ ì˜í–¥)

ê¶Œì¥ ì‚¬í•­:
1. ì˜¤í›„ 2-6ì‹œ ê²½ë¶€ê³ ì†ë„ë¡œ ìš°íšŒ ê²½ë¡œ í™œìš©
2. ê¸´ê¸‰ í™”ë¬¼ì€ ì˜¤ì „ ë°°ì†¡ ê¶Œì¥
3. ì˜ˆë¹„ ì°¨ëŸ‰ 20% ì¶”ê°€ ë°°ì¹˜ í•„ìš”

Temperature: {node.settings.get('temperature', 0.7)}
Max Tokens: {node.settings.get('max_tokens', 2048)}
ì¶”ë¡  ëª¨ë“œ: {node.settings.get('inference_mode', 'ì¢…í•©ë¶„ì„')}""",
                "settings": node.settings
            }
            
        return output
        
    def show_execution_results(self, node_outputs):
        """ì‹¤í–‰ ê²°ê³¼ í‘œì‹œ"""
        result_dialog = QDialog(self)
        result_dialog.setWindowTitle("íŒŒì´í”„ë¼ì¸ ì‹¤í–‰ ê²°ê³¼")
        result_dialog.setModal(True)
        layout = QVBoxLayout()
        
        # íƒ­ ìœ„ì ¯ìœ¼ë¡œ ê²°ê³¼ í‘œì‹œ
        tabs = QTabWidget()
        
        # LLM ê²°ê³¼ ì°¾ê¸°
        llm_result = None
        for node, output in node_outputs.items():
            if node.node_type == NodeType.LLM:
                llm_result = output
                break
        
        # ìš”ì•½ íƒ­
        summary_text = QTextEdit()
        summary_text.setReadOnly(True)
        if llm_result:
            summary_text.setPlainText(llm_result.get("response", "ê²°ê³¼ ì—†ìŒ"))
        else:
            summary_text.setPlainText("LLM ë…¸ë“œê°€ ì‹¤í–‰ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.")
        tabs.addTab(summary_text, "ìµœì¢… ê²°ê³¼")
        
        # ê° ë…¸ë“œë³„ ê²°ê³¼ íƒ­
        for node, output in node_outputs.items():
            node_text = QTextEdit()
            node_text.setReadOnly(True)
            node_text.setPlainText(json.dumps(output, indent=2, ensure_ascii=False))
            tabs.addTab(node_text, f"{node.name}")
        
        layout.addWidget(tabs)
        
        # ë‹«ê¸° ë²„íŠ¼
        close_btn = QPushButton("ë‹«ê¸°")
        close_btn.clicked.connect(result_dialog.accept)
        layout.addWidget(close_btn)
        if self.isSelected():
        result_dialog.setLayout(layout)
        result_dialog.resize(800, 600)
        result_dialog.exec_()
        
        self.log("íŒŒì´í”„ë¼ì¸ ì‹¤í–‰ ì™„ë£Œ")
            
    def update_properties(self):
        """ì†ì„± íŒ¨ë„ ì—…ë°ì´íŠ¸"""
        selected = self.scene.selectedItems()
        if selected and isinstance(selected[0], Node):
            node = selected[0]
            info = f"""ë…¸ë“œ ì •ë³´
---------
ì´ë¦„: {node.name}
íƒ€ì…: {node.node_type.value}
ID: {node.node_id}
ì„¤ì • ìƒíƒœ: {'ì™„ë£Œ' if node.is_configured else 'ë¯¸ì™„ë£Œ'}
ìœ„ì¹˜: ({int(node.x())}, {int(node.y())})

ì„¤ì • ë‚´ìš©:
{json.dumps(node.settings, indent=2, ensure_ascii=False) if node.settings else 'ì—†ìŒ'}"""
            
            self.properties_widget.setPlainText(info)
        elif selected and isinstance(selected[0], MemoItem):
            memo = selected[0]
            info = f"""ë©”ëª¨ ì •ë³´
---------
ID: {memo.memo_id}
ìœ„ì¹˜: ({int(memo.x())}, {int(memo.y())})
í¬ê¸°: {int(memo.rect().width())} x {int(memo.rect().height())}

ë‚´ìš©:
{memo.text_item.toPlainText()}"""
            
            self.properties_widget.setPlainText(info)
        else:
            self.properties_widget.setPlainText("ë…¸ë“œë‚˜ ë©”ëª¨ë¥¼ ì„ íƒí•˜ì„¸ìš”")
            
    def log(self, message):
        """ì½˜ì†”ì— ë¡œê·¸ ì¶œë ¥"""
        from datetime import datetime
        timestamp = datetime.now().strftime("%H:%M:%S")
        self.console.append(f"[{timestamp}] {message}")
        self.statusBar().showMessage(message, 3000)


def main():
    app = QApplication(sys.argv)
    
    # ì• í”Œë¦¬ì¼€ì´ì…˜ ìŠ¤íƒ€ì¼ ì„¤ì •
    app.setStyle("Fusion")
    
    # ë‹¤í¬ íŒ”ë ˆíŠ¸
    palette = QPalette()
    palette.setColor(QPalette.Window, QColor(30, 30, 30))
    palette.setColor(QPalette.WindowText, Qt.white)
    palette.setColor(QPalette.Base, QColor(45, 45, 45))
    palette.setColor(QPalette.AlternateBase, QColor(60, 60, 60))
    palette.setColor(QPalette.ToolTipBase, Qt.black)
    palette.setColor(QPalette.ToolTipText, Qt.white)
    palette.setColor(QPalette.Text, Qt.white)
    palette.setColor(QPalette.Button, QColor(45, 45, 45))
    palette.setColor(QPalette.ButtonText, Qt.white)
    palette.setColor(QPalette.BrightText, Qt.red)
    palette.setColor(QPalette.Link, QColor(42, 130, 218))
    palette.setColor(QPalette.Highlight, QColor(42, 130, 218))
    palette.setColor(QPalette.HighlightedText, Qt.black)
    app.setPalette(palette)
    
    window = LogisticsPredictionSystem()
    window.show()
    
    sys.exit(app.exec_())


if __name__ == "__main__":
    main()