"""
ë°˜ë„ì²´ ë¬¼ë¥˜ ì˜ˆì¸¡ í•˜ì´ë¸Œë¦¬ë“œ ë”¥ëŸ¬ë‹ ëª¨ë¸ GUI ì• í”Œë¦¬ì¼€ì´ì…˜
=======================================================
LSTM, RNN, GRU, ARIMAë¥¼ í†µí•©í•œ í•˜ì´ë¸Œë¦¬ë“œ ëª¨ë¸ì„
ì‚¬ìš©í•˜ê¸° ì‰¬ìš´ GUIë¡œ ì œê³µí•©ë‹ˆë‹¤.

ì£¼ìš” ê¸°ëŠ¥:
1. ë°ì´í„° íŒŒì¼ ì„ íƒ ë° ë¡œë“œ
2. í•™ìŠµ íŒŒë¼ë¯¸í„° ì„¤ì •
3. ì‹¤ì‹œê°„ í•™ìŠµ ì§„í–‰ ëª¨ë‹ˆí„°ë§
4. ëª¨ë¸ ì˜ˆì¸¡ ë° í‰ê°€
5. ê²°ê³¼ ì‹œê°í™” ë° ì €ì¥

ê°œë°œì¼: 2024ë…„
ë²„ì „: 2.1 GUI
"""

import tkinter as tk
from tkinter import ttk, filedialog, messagebox, scrolledtext
import threading
import queue
import numpy as np
import pandas as pd
import tensorflow as tf
from sklearn.preprocessing import StandardScaler
from tensorflow.keras.models import Sequential, load_model
from tensorflow.keras.layers import Input, LSTM, Dense, Dropout, BatchNormalization, GRU, SimpleRNN, Bidirectional
from tensorflow.keras.callbacks import EarlyStopping, ReduceLROnPlateau, ModelCheckpoint
from tensorflow.keras.optimizers import Adam
from sklearn.metrics import mean_squared_error, mean_absolute_error, r2_score
import matplotlib.pyplot as plt
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg
import matplotlib.font_manager as fm
import os
import platform
import json
import joblib
import warnings
from datetime import datetime, timedelta
import sys

# ê²½ê³  ë©”ì‹œì§€ ìˆ¨ê¸°ê¸°
warnings.filterwarnings('ignore')

# ===================================
# í•œê¸€ í°íŠ¸ ì„¤ì •
# ===================================
def setup_korean_font():
    """ìš´ì˜ì²´ì œë³„ í•œê¸€ í°íŠ¸ ìë™ ì„¤ì •"""
    system = platform.system()

    # í°íŠ¸ ì„¤ì • ì‹œë„
    if system == 'Windows':
        # ìœˆë„ìš°
        font_candidates = ['Malgun Gothic', 'NanumGothic', 'ë§‘ì€ ê³ ë”•', 'ë‚˜ëˆ”ê³ ë”•']
    elif system == 'Darwin':
        # ë§¥OS
        font_candidates = ['AppleGothic', 'NanumGothic', 'Apple SD Gothic Neo']
    else:
        # ë¦¬ëˆ…ìŠ¤
        font_candidates = ['NanumGothic', 'DejaVu Sans']

    # ì‚¬ìš© ê°€ëŠ¥í•œ í°íŠ¸ ì°¾ê¸°
    font_set = False
    for font_name in font_candidates:
        if font_name in [f.name for f in fm.fontManager.ttflist]:
            plt.rcParams['font.family'] = font_name
            font_set = True
            print(f"âœ“ í•œê¸€ í°íŠ¸ ì„¤ì •: {font_name}")
            break

    # í°íŠ¸ë¥¼ ì°¾ì§€ ëª»í•œ ê²½ìš° ì§ì ‘ ê²½ë¡œ ì„¤ì • ì‹œë„
    if not font_set:
        if system == 'Windows':
            font_path = 'C:/Windows/Fonts/malgun.ttf'
            if os.path.exists(font_path):
                font_prop = fm.FontProperties(fname=font_path)
                plt.rcParams['font.family'] = font_prop.get_name()
                font_set = True
        elif system == 'Darwin':
            font_path = '/System/Library/Fonts/Supplemental/AppleGothic.ttf'
            if os.path.exists(font_path):
                font_prop = fm.FontProperties(fname=font_path)
                plt.rcParams['font.family'] = font_prop.get_name()
                font_set = True

    # ë§ˆì´ë„ˆìŠ¤ ê¸°í˜¸ ê¹¨ì§ ë°©ì§€
    plt.rcParams['axes.unicode_minus'] = False

    # í°íŠ¸ í¬ê¸° ì„¤ì •
    plt.rcParams['font.size'] = 10
    plt.rcParams['axes.titlesize'] = 12
    plt.rcParams['axes.labelsize'] = 10
    plt.rcParams['xtick.labelsize'] = 9
    plt.rcParams['ytick.labelsize'] = 9
    plt.rcParams['legend.fontsize'] = 9

    return font_set

# í•œê¸€ í°íŠ¸ ì„¤ì • ì‹¤í–‰
font_initialized = setup_korean_font()
if not font_initialized:
    print("âš  í•œê¸€ í°íŠ¸ ì„¤ì • ì‹¤íŒ¨ - ì˜ë¬¸ìœ¼ë¡œ í‘œì‹œë©ë‹ˆë‹¤.")

# CPU ëª¨ë“œ ì„¤ì •
os.environ['CUDA_VISIBLE_DEVICES'] = '-1'
tf.config.set_visible_devices([], 'GPU')

# ëœë¤ ì‹œë“œ ê³ ì •
RANDOM_SEED = 2079936
tf.random.set_seed(RANDOM_SEED)
np.random.seed(RANDOM_SEED)

class HybridModelGUI:
    def __init__(self, root):
        self.root = root
        self.root.title("ğŸš€ ë°˜ë„ì²´ ë¬¼ë¥˜ ì˜ˆì¸¡ í•˜ì´ë¸Œë¦¬ë“œ AI ì‹œìŠ¤í…œ")

        # í•œê¸€ í°íŠ¸ í™•ì¸ ë° í…ìŠ¤íŠ¸ ì„¤ì •
        if not font_initialized:
            print("âš  í•œê¸€ í°íŠ¸ê°€ ì„¤ì •ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤. matplotlib ê·¸ë˜í”„ì—ì„œ í•œê¸€ì´ ê¹¨ì§ˆ ìˆ˜ ìˆìŠµë‹ˆë‹¤.")
            print("  í•´ê²°ë°©ë²•: ë‚˜ëˆ”ê³ ë”• ë˜ëŠ” ë§‘ì€ ê³ ë”• í°íŠ¸ë¥¼ ì„¤ì¹˜í•˜ì„¸ìš”.")
            self.use_korean = False
            # ì˜ë¬¸ í…ìŠ¤íŠ¸ ì„¤ì •
            self.text_labels = {
                'training_progress': 'Training Progress',
                'epoch': 'Epoch',
                'loss': 'Loss',
                'prediction_comparison': 'Prediction vs Actual',
                'time_index': 'Time Index',
                'logistics_volume': 'Logistics Volume',
                'actual': 'Actual',
                'predicted': 'Predicted'
            }
        else:
            self.use_korean = True
            # í•œê¸€ í…ìŠ¤íŠ¸ ì„¤ì •
            self.text_labels = {
                'training_progress': 'í•™ìŠµ ì§„í–‰ ìƒí™©',
                'epoch': 'ì—í­',
                'loss': 'ì†ì‹¤ê°’',
                'prediction_comparison': 'ì˜ˆì¸¡ ê²°ê³¼ ë¹„êµ',
                'time_index': 'ì‹œê°„ ì¸ë±ìŠ¤',
                'logistics_volume': 'ë¬¼ë¥˜ëŸ‰',
                'actual': 'ì‹¤ì œê°’',
                'predicted': 'ì˜ˆì¸¡ê°’'
            }

        # ë‹¤í¬ í…Œë§ˆ ìŠ¤íƒ€ì¼ ì„¤ì •
        self.setup_styles()

        # ë³€ìˆ˜ ì´ˆê¸°í™”
        self.data_path = tk.StringVar()
        self.models = {}
        self.scaler = None
        self.data = None
        self.X_train = None
        self.y_train = None
        self.X_val = None
        self.y_val = None
        self.X_test = None
        self.y_test = None
        self.is_training = False
        self.log_queue = queue.Queue()

        # UI êµ¬ì„±
        self.create_widgets()

        # ë¡œê·¸ ì—…ë°ì´íŠ¸ ì‹œì‘
        self.update_logs()

    def setup_styles(self):
        """GUI ìŠ¤íƒ€ì¼ ì„¤ì •"""
        style = ttk.Style()
        style.theme_use('clam')

        # ë‹¤í¬ í…Œë§ˆ ìƒ‰ìƒ
        bg_color = "#2b2b2b"
        fg_color = "#ffffff"
        button_bg = "#4CAF50"
        button_hover = "#45a049"

        self.root.configure(bg=bg_color)

        style.configure("Title.TLabel", background=bg_color, foreground=fg_color,
                       font=('Arial', 16, 'bold'))
        style.configure("Heading.TLabel", background=bg_color, foreground=fg_color,
                       font=('Arial', 12, 'bold'))
        style.configure("Dark.TFrame", background=bg_color)
        style.configure("Success.TButton", font=('Arial', 10, 'bold'))

    def create_widgets(self):
        """ìœ„ì ¯ ìƒì„± ë° ë°°ì¹˜"""
        # ë©”ì¸ ì»¨í…Œì´ë„ˆ
        main_container = ttk.Frame(self.root, style="Dark.TFrame")
        main_container.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)

        # ì™¼ìª½ íŒ¨ë„ - ë°ì´í„° ë° ì„¤ì •
        left_panel = ttk.Frame(main_container, style="Dark.TFrame")
        left_panel.grid(row=0, column=0, sticky="nsew", padx=5)

        # ë°ì´í„° ì„ íƒ ì„¹ì…˜
        self.create_data_section(left_panel)

        # íŒŒë¼ë¯¸í„° ì„¤ì • ì„¹ì…˜
        self.create_parameter_section(left_panel)

        # ì»¨íŠ¸ë¡¤ ë²„íŠ¼ ì„¹ì…˜
        self.create_control_section(left_panel)

        # ì¤‘ì•™ íŒ¨ë„ - ì§„í–‰ ìƒí™© ë° ë¡œê·¸
        center_panel = ttk.Frame(main_container, style="Dark.TFrame")
        center_panel.grid(row=0, column=1, sticky="nsew", padx=5)

        # ì§„í–‰ ìƒí™© ì„¹ì…˜
        self.create_progress_section(center_panel)

        # ë¡œê·¸ ì„¹ì…˜
        self.create_log_section(center_panel)

        # ì˜¤ë¥¸ìª½ íŒ¨ë„ - ê²°ê³¼ ë° ì‹œê°í™”
        right_panel = ttk.Frame(main_container, style="Dark.TFrame")
        right_panel.grid(row=0, column=2, sticky="nsew", padx=5)

        # ê²°ê³¼ ì„¹ì…˜
        self.create_results_section(right_panel)

        # ì‹œê°í™” ì„¹ì…˜
        self.create_visualization_section(right_panel)

        # ê·¸ë¦¬ë“œ ê°€ì¤‘ì¹˜ ì„¤ì •
        main_container.grid_rowconfigure(0, weight=1)
        main_container.grid_columnconfigure(0, weight=2)
        main_container.grid_columnconfigure(1, weight=3)
        main_container.grid_columnconfigure(2, weight=3)

    def create_data_section(self, parent):
        """ë°ì´í„° ì„ íƒ ì„¹ì…˜"""
        frame = ttk.LabelFrame(parent, text="ğŸ“ ë°ì´í„° ì„¤ì •", padding=10)
        frame.pack(fill=tk.X, pady=5)

        # íŒŒì¼ ê²½ë¡œ í‘œì‹œ
        ttk.Label(frame, text="ë°ì´í„° íŒŒì¼:").pack(anchor=tk.W)
        path_frame = ttk.Frame(frame)
        path_frame.pack(fill=tk.X, pady=5)

        self.path_entry = ttk.Entry(path_frame, textvariable=self.data_path, width=30)
        self.path_entry.pack(side=tk.LEFT, fill=tk.X, expand=True)

        ttk.Button(path_frame, text="ì°¾ì•„ë³´ê¸°",
                  command=self.browse_file).pack(side=tk.LEFT, padx=5)

        # ë°ì´í„° ì •ë³´
        self.data_info = tk.Text(frame, height=4, width=40, bg="#3c3c3c", fg="white")
        self.data_info.pack(fill=tk.X, pady=5)
        self.data_info.insert(tk.END, "ë°ì´í„°ë¥¼ ì„ íƒí•˜ì„¸ìš”...")
        self.data_info.config(state=tk.DISABLED)

    def create_parameter_section(self, parent):
        """íŒŒë¼ë¯¸í„° ì„¤ì • ì„¹ì…˜"""
        frame = ttk.LabelFrame(parent, text="âš™ï¸ í•™ìŠµ íŒŒë¼ë¯¸í„°", padding=10)
        frame.pack(fill=tk.X, pady=5)

        # ì—í­ ìˆ˜
        ttk.Label(frame, text="ì—í­ ìˆ˜:").grid(row=0, column=0, sticky=tk.W, pady=2)
        self.epochs_var = tk.IntVar(value=100)
        ttk.Spinbox(frame, from_=10, to=500, textvariable=self.epochs_var,
                   width=15).grid(row=0, column=1, pady=2)

        # ë°°ì¹˜ í¬ê¸°
        ttk.Label(frame, text="ë°°ì¹˜ í¬ê¸°:").grid(row=1, column=0, sticky=tk.W, pady=2)
        self.batch_var = tk.IntVar(value=64)
        ttk.Spinbox(frame, from_=16, to=256, increment=16, textvariable=self.batch_var,
                   width=15).grid(row=1, column=1, pady=2)

        # í•™ìŠµë¥ 
        ttk.Label(frame, text="í•™ìŠµë¥ :").grid(row=2, column=0, sticky=tk.W, pady=2)
        self.lr_var = tk.DoubleVar(value=0.001)
        ttk.Entry(frame, textvariable=self.lr_var, width=15).grid(row=2, column=1, pady=2)

        # ì‹œí€€ìŠ¤ ê¸¸ì´
        ttk.Label(frame, text="ì‹œí€€ìŠ¤ ê¸¸ì´:").grid(row=3, column=0, sticky=tk.W, pady=2)
        self.seq_var = tk.IntVar(value=30)
        ttk.Spinbox(frame, from_=10, to=100, textvariable=self.seq_var,
                   width=15).grid(row=3, column=1, pady=2)

        # ì˜ˆì¸¡ ì‹œê°„
        ttk.Label(frame, text="ì˜ˆì¸¡ ì‹œê°„(ë¶„):").grid(row=4, column=0, sticky=tk.W, pady=2)
        self.future_var = tk.IntVar(value=10)
        ttk.Spinbox(frame, from_=5, to=60, increment=5, textvariable=self.future_var,
                   width=15).grid(row=4, column=1, pady=2)

        # ëª¨ë¸ ì„ íƒ
        ttk.Label(frame, text="ëª¨ë¸ ì„ íƒ:").grid(row=5, column=0, sticky=tk.W, pady=2)
        model_frame = ttk.Frame(frame)
        model_frame.grid(row=5, column=1, pady=2)

        self.model_vars = {
            'LSTM': tk.BooleanVar(value=True),
            'GRU': tk.BooleanVar(value=True),
            'RNN': tk.BooleanVar(value=True),
            'Bi-LSTM': tk.BooleanVar(value=True)
        }

        for i, (name, var) in enumerate(self.model_vars.items()):
            ttk.Checkbutton(model_frame, text=name, variable=var).grid(row=i//2, column=i%2)

    def create_control_section(self, parent):
        """ì»¨íŠ¸ë¡¤ ë²„íŠ¼ ì„¹ì…˜"""
        frame = ttk.LabelFrame(parent, text="ğŸ® ì»¨íŠ¸ë¡¤", padding=10)
        frame.pack(fill=tk.X, pady=5)

        # ë²„íŠ¼ë“¤
        self.load_btn = ttk.Button(frame, text="ğŸ“Š ë°ì´í„° ë¡œë“œ",
                                  command=self.load_data, style="Success.TButton")
        self.load_btn.pack(fill=tk.X, pady=2)

        self.train_btn = ttk.Button(frame, text="ğŸš€ í•™ìŠµ ì‹œì‘",
                                   command=self.start_training, style="Success.TButton")
        self.train_btn.pack(fill=tk.X, pady=2)
        self.train_btn.config(state=tk.DISABLED)

        self.stop_btn = ttk.Button(frame, text="â¹ï¸ í•™ìŠµ ì¤‘ì§€",
                                  command=self.stop_training)
        self.stop_btn.pack(fill=tk.X, pady=2)
        self.stop_btn.config(state=tk.DISABLED)

        self.predict_btn = ttk.Button(frame, text="ğŸ”® ì˜ˆì¸¡ ì‹¤í–‰",
                                     command=self.run_prediction)
        self.predict_btn.pack(fill=tk.X, pady=2)
        self.predict_btn.config(state=tk.DISABLED)

        self.save_btn = ttk.Button(frame, text="ğŸ’¾ ëª¨ë¸ ì €ì¥",
                                  command=self.save_models)
        self.save_btn.pack(fill=tk.X, pady=2)
        self.save_btn.config(state=tk.DISABLED)

        ttk.Separator(frame, orient='horizontal').pack(fill=tk.X, pady=5)

        self.load_model_btn = ttk.Button(frame, text="ğŸ“‚ ëª¨ë¸ ë¶ˆëŸ¬ì˜¤ê¸°",
                                        command=self.load_saved_models)
        self.load_model_btn.pack(fill=tk.X, pady=2)

    def create_progress_section(self, parent):
        """ì§„í–‰ ìƒí™© ì„¹ì…˜"""
        frame = ttk.LabelFrame(parent, text="ğŸ“ˆ í•™ìŠµ ì§„í–‰ ìƒí™©", padding=10)
        frame.pack(fill=tk.X, pady=5)

        # ì „ì²´ ì§„í–‰ë¥ 
        ttk.Label(frame, text="ì „ì²´ ì§„í–‰ë¥ :").pack(anchor=tk.W)
        self.overall_progress = ttk.Progressbar(frame, mode='determinate')
        self.overall_progress.pack(fill=tk.X, pady=2)

        # í˜„ì¬ ëª¨ë¸
        self.current_model_label = ttk.Label(frame, text="ëŒ€ê¸° ì¤‘...")
        self.current_model_label.pack(anchor=tk.W, pady=2)

        # ì—í­ ì§„í–‰ë¥ 
        ttk.Label(frame, text="ì—í­ ì§„í–‰ë¥ :").pack(anchor=tk.W)
        self.epoch_progress = ttk.Progressbar(frame, mode='determinate')
        self.epoch_progress.pack(fill=tk.X, pady=2)

        # í˜„ì¬ ì—í­
        self.current_epoch_label = ttk.Label(frame, text="")
        self.current_epoch_label.pack(anchor=tk.W, pady=2)

        # ì„±ëŠ¥ ì§€í‘œ
        self.metrics_frame = ttk.Frame(frame)
        self.metrics_frame.pack(fill=tk.X, pady=5)

        metrics_labels = ["Loss:", "Val Loss:", "MAE:", "Val MAE:"]
        self.metric_labels = {}

        for i, label in enumerate(metrics_labels):
            ttk.Label(self.metrics_frame, text=label).grid(row=i//2, column=(i%2)*2, sticky=tk.W)
            metric_label = ttk.Label(self.metrics_frame, text="--")
            metric_label.grid(row=i//2, column=(i%2)*2+1, sticky=tk.W, padx=5)
            self.metric_labels[label] = metric_label

    def create_log_section(self, parent):
        """ë¡œê·¸ ì„¹ì…˜"""
        frame = ttk.LabelFrame(parent, text="ğŸ“ ë¡œê·¸", padding=10)
        frame.pack(fill=tk.BOTH, expand=True, pady=5)

        # ë¡œê·¸ í…ìŠ¤íŠ¸
        self.log_text = scrolledtext.ScrolledText(frame, height=15, width=50,
                                                  bg="#1e1e1e", fg="#00ff00",
                                                  font=('Consolas', 9))
        self.log_text.pack(fill=tk.BOTH, expand=True)

    def create_results_section(self, parent):
        """ê²°ê³¼ ì„¹ì…˜"""
        frame = ttk.LabelFrame(parent, text="ğŸ“Š ì˜ˆì¸¡ ê²°ê³¼", padding=10)
        frame.pack(fill=tk.X, pady=5)

        # ê²°ê³¼ í…ìŠ¤íŠ¸
        self.results_text = tk.Text(frame, height=10, width=40,
                                   bg="#3c3c3c", fg="white", font=('Arial', 9))
        self.results_text.pack(fill=tk.X)
        self.results_text.insert(tk.END, "í•™ìŠµ í›„ ê²°ê³¼ê°€ ì—¬ê¸°ì— í‘œì‹œë©ë‹ˆë‹¤...")
        self.results_text.config(state=tk.DISABLED)

    def create_visualization_section(self, parent):
        """ì‹œê°í™” ì„¹ì…˜"""
        frame = ttk.LabelFrame(parent, text="ğŸ“ˆ ì‹œê°í™”", padding=10)
        frame.pack(fill=tk.BOTH, expand=True, pady=5)

        # ê·¸ë˜í”„ ìº”ë²„ìŠ¤ (í•œê¸€/ì˜ë¬¸ ìë™ ì„ íƒ)
        self.fig, self.ax = plt.subplots(figsize=(6, 4), facecolor='#2b2b2b')
        self.ax.set_facecolor('#3c3c3c')

        # ì–¸ì–´ì— ë”°ë¥¸ ì œëª©ê³¼ ë¼ë²¨ ì„¤ì •
        self.ax.set_title(self.text_labels['training_progress'], color='white', fontsize=12, pad=10)
        self.ax.set_xlabel(self.text_labels['epoch'], color='white', fontsize=10)
        self.ax.set_ylabel(self.text_labels['loss'], color='white', fontsize=10)
        self.ax.tick_params(colors='white', labelsize=9)
        self.ax.grid(True, alpha=0.3)

        # ìº”ë²„ìŠ¤ ìƒì„± ë° í°íŠ¸ ì ìš©
        self.canvas = FigureCanvasTkAgg(self.fig, master=frame)
        self.canvas.draw()
        self.canvas.get_tk_widget().pack(fill=tk.BOTH, expand=True)

    def browse_file(self):
        """íŒŒì¼ ì„ íƒ ë‹¤ì´ì–¼ë¡œê·¸"""
        filename = filedialog.askopenfilename(
            title="ë°ì´í„° íŒŒì¼ ì„ íƒ",
            filetypes=[("CSV files", "*.csv"), ("All files", "*.*")]
        )
        if filename:
            self.data_path.set(filename)
            self.log("íŒŒì¼ ì„ íƒ: " + os.path.basename(filename))

    def log(self, message):
        """ë¡œê·¸ ë©”ì‹œì§€ ì¶”ê°€"""
        timestamp = datetime.now().strftime("%H:%M:%S")
        log_message = f"[{timestamp}] {message}\n"
        self.log_queue.put(log_message)

    def update_logs(self):
        """ë¡œê·¸ ì—…ë°ì´íŠ¸"""
        try:
            while True:
                message = self.log_queue.get_nowait()
                self.log_text.insert(tk.END, message)
                self.log_text.see(tk.END)
        except queue.Empty:
            pass
        finally:
            self.root.after(100, self.update_logs)

    def load_data(self):
        """ë°ì´í„° ë¡œë“œ ë° ì „ì²˜ë¦¬"""
        if not self.data_path.get():
            messagebox.showerror("ì˜¤ë¥˜", "ë°ì´í„° íŒŒì¼ì„ ì„ íƒí•˜ì„¸ìš”!")
            return

        try:
            self.log("ë°ì´í„° ë¡œë”© ì‹œì‘...")

            # ë°ì´í„° ë¡œë“œ
            self.data = pd.read_csv(self.data_path.get())

            # ë°ì´í„° ì •ë³´ ì—…ë°ì´íŠ¸
            self.data_info.config(state=tk.NORMAL)
            self.data_info.delete(1.0, tk.END)
            info_text = f"ğŸ“Š ë°ì´í„° ì •ë³´\n"
            info_text += f"í–‰ ìˆ˜: {len(self.data):,}\n"
            info_text += f"ì—´ ìˆ˜: {len(self.data.columns)}\n"
            info_text += f"ì»¬ëŸ¼: {', '.join(self.data.columns[:5])}..."
            self.data_info.insert(tk.END, info_text)
            self.data_info.config(state=tk.DISABLED)

            # ì „ì²˜ë¦¬
            self.preprocess_data()

            self.log("âœ… ë°ì´í„° ë¡œë“œ ì™„ë£Œ!")
            self.train_btn.config(state=tk.NORMAL)
            
            # ëª¨ë¸ì´ ë¯¸ë¦¬ ë¡œë“œëœ ìƒíƒœì˜€ë‹¤ë©´, ë°ì´í„°ê°€ ë¡œë“œë˜ì—ˆìœ¼ë¯€ë¡œ ì˜ˆì¸¡ ë²„íŠ¼ í™œì„±í™”
            if self.models:
                self.predict_btn.config(state=tk.NORMAL)

            messagebox.showinfo("ì„±ê³µ", "ë°ì´í„° ë¡œë“œ ë° ì „ì²˜ë¦¬ ì™„ë£Œ!")

        except Exception as e:
            self.log(f"âŒ ë°ì´í„° ë¡œë“œ ì‹¤íŒ¨: {str(e)}")
            messagebox.showerror("ì˜¤ë¥˜", f"ë°ì´í„° ë¡œë“œ ì‹¤íŒ¨:\n{str(e)}")

    def preprocess_data(self):
        """ë°ì´í„° ì „ì²˜ë¦¬"""
        self.log("ë°ì´í„° ì „ì²˜ë¦¬ ì¤‘...")

        # ì‹œê°„ ì»¬ëŸ¼ ë³€í™˜
        self.data['CURRTIME'] = pd.to_datetime(self.data['CURRTIME'], format='%Y%m%d%H%M')
        self.data['TIME'] = pd.to_datetime(self.data['TIME'], format='%Y%m%d%H%M')

        # SUM ì»¬ëŸ¼ ì œê±°
        columns_to_drop = [col for col in self.data.columns if 'SUM' in col]
        self.data = self.data.drop(columns=columns_to_drop)

        # í•„ìš”í•œ ì»¬ëŸ¼ë§Œ ì„ íƒ
        self.data = self.data[['CURRTIME', 'TOTALCNT', 'TIME']]
        self.data.set_index('CURRTIME', inplace=True)

        # FUTURE ì»¬ëŸ¼ ìƒì„±
        self.data['FUTURE'] = pd.NA
        future_minutes = self.future_var.get()

        for i in self.data.index:
            future_time = i + pd.Timedelta(minutes=future_minutes)
            if (future_time <= self.data.index.max()) & (future_time in self.data.index):
                self.data.loc[i, 'FUTURE'] = self.data.loc[future_time, 'TOTALCNT']

        self.data.dropna(subset=['FUTURE'], inplace=True)

        # íŠ¹ì§• ì—”ì§€ë‹ˆì–´ë§
        self.data['hour'] = self.data.index.hour
        self.data['dayofweek'] = self.data.index.dayofweek
        self.data['is_weekend'] = (self.data.index.dayofweek >= 5).astype(int)
        self.data['MA_5'] = self.data['TOTALCNT'].rolling(window=5, min_periods=1).mean()
        self.data['MA_10'] = self.data['TOTALCNT'].rolling(window=10, min_periods=1).mean()
        self.data['MA_30'] = self.data['TOTALCNT'].rolling(window=30, min_periods=1).mean()
        self.data['STD_5'] = self.data['TOTALCNT'].rolling(window=5, min_periods=1).std()
        self.data['STD_10'] = self.data['TOTALCNT'].rolling(window=10, min_periods=1).std()
        self.data['change_rate'] = self.data['TOTALCNT'].pct_change()
        self.data['change_rate_5'] = self.data['TOTALCNT'].pct_change(5)
        self.data = self.data.ffill().fillna(0)

        # ìŠ¤ì¼€ì¼ë§
        self.scaler = StandardScaler()
        scaled_list = ['TOTALCNT', 'FUTURE', 'MA_5', 'MA_10', 'MA_30', 'STD_5', 'STD_10']
        scaled_list = [col for col in scaled_list if col in self.data.columns]

        scaled_data = self.scaler.fit_transform(self.data[scaled_list])
        scaled_columns = [f'scaled_{col}' for col in scaled_list]
        scaled_df = pd.DataFrame(scaled_data, columns=scaled_columns, index=self.data.index)

        self.data = pd.merge(self.data, scaled_df, left_index=True, right_index=True, how='left')

        # ì‹œí€€ìŠ¤ ìƒì„±
        self.create_sequences()

        self.log(f"ì „ì²˜ë¦¬ ì™„ë£Œ - í›ˆë ¨: {len(self.X_train)}, ê²€ì¦: {len(self.X_val)}, í…ŒìŠ¤íŠ¸: {len(self.X_test)}")

    def create_sequences(self):
        """ì‹œí€€ìŠ¤ ë°ì´í„° ìƒì„±"""
        seq_length = self.seq_var.get()

        # ì—°ì†ì„± í™•ì¸í•˜ì—¬ ë°ì´í„° ë¶„í• 
        time_diff = self.data.index.to_series().diff()
        split_points = time_diff > pd.Timedelta(minutes=1)
        segment_ids = split_points.cumsum()

        input_features = [col for col in self.data.columns if col.startswith('scaled_') and col != 'scaled_FUTURE']

        all_X, all_y = [], []

        for segment_id in segment_ids.unique():
            segment = self.data[segment_ids == segment_id]

            if len(segment) > seq_length:
                X_data = segment[input_features].values
                y_data = segment['scaled_FUTURE'].values

                for i in range(len(segment) - seq_length):
                    all_X.append(X_data[i:i+seq_length])
                    all_y.append(y_data[i+seq_length])

        X = np.array(all_X)
        y = np.array(all_y)

        # ë°ì´í„° ë¶„í• 
        train_size = int(0.7 * len(X))
        val_size = int(0.15 * len(X))

        self.X_train = X[:train_size]
        self.y_train = y[:train_size]
        self.X_val = X[train_size:train_size+val_size]
        self.y_val = y[train_size:train_size+val_size]
        self.X_test = X[train_size+val_size:]
        self.y_test = y[train_size+val_size:]

    def start_training(self):
        """í•™ìŠµ ì‹œì‘"""
        if self.is_training:
            messagebox.showwarning("ê²½ê³ ", "ì´ë¯¸ í•™ìŠµì´ ì§„í–‰ ì¤‘ì…ë‹ˆë‹¤!")
            return

        self.is_training = True
        self.train_btn.config(state=tk.DISABLED)
        self.stop_btn.config(state=tk.NORMAL)
        self.load_model_btn.config(state=tk.DISABLED) # í•™ìŠµ ì¤‘ì—ëŠ” ëª¨ë¸ ë¡œë“œ ë¶ˆê°€

        # í•™ìŠµ ìŠ¤ë ˆë“œ ì‹œì‘
        self.training_thread = threading.Thread(target=self.train_models)
        self.training_thread.start()

    def stop_training(self):
        """í•™ìŠµ ì¤‘ì§€"""
        self.is_training = False
        self.log("â¹ï¸ í•™ìŠµ ì¤‘ì§€ ìš”ì²­...")

    def train_models(self):
        """ëª¨ë¸ í•™ìŠµ"""
        try:
            self.log("ğŸš€ í•˜ì´ë¸Œë¦¬ë“œ ëª¨ë¸ í•™ìŠµ ì‹œì‘")
            self.models.clear() # í•™ìŠµ ì‹œì‘ ì‹œ ê¸°ì¡´ ëª¨ë¸ ì´ˆê¸°í™”

            input_shape = (self.X_train.shape[1], self.X_train.shape[2])
            selected_models = []

            # ì„ íƒëœ ëª¨ë¸ í™•ì¸
            if self.model_vars['LSTM'].get():
                selected_models.append(('lstm', self.build_lstm_model(input_shape)))
            if self.model_vars['GRU'].get():
                selected_models.append(('gru', self.build_gru_model(input_shape)))
            if self.model_vars['RNN'].get():
                selected_models.append(('rnn', self.build_rnn_model(input_shape)))
            if self.model_vars['Bi-LSTM'].get():
                selected_models.append(('bi_lstm', self.build_bilstm_model(input_shape)))

            total_models = len(selected_models)

            for idx, (model_name, model) in enumerate(selected_models):
                if not self.is_training:
                    break

                self.log(f"\nğŸ“Š {model_name.upper()} ëª¨ë¸ í•™ìŠµ ì‹œì‘")
                self.root.after(0, self.update_current_model, f"{model_name.upper()} ëª¨ë¸ í•™ìŠµ ì¤‘...")

                # ì „ì²´ ì§„í–‰ë¥  ì—…ë°ì´íŠ¸
                overall_progress = (idx / total_models) * 100
                self.root.after(0, self.update_overall_progress, overall_progress)

                # ëª¨ë¸ ì»´íŒŒì¼
                optimizer = Adam(learning_rate=self.lr_var.get())
                model.compile(optimizer=optimizer, loss='mse', metrics=['mae'])

                # ì½œë°± ì„¤ì •
                early_stop = EarlyStopping(monitor='val_loss', patience=20, restore_best_weights=True)
                reduce_lr = ReduceLROnPlateau(monitor='val_loss', factor=0.5, patience=5)

                # í•™ìŠµ
                epochs = self.epochs_var.get()
                batch_size = self.batch_var.get()

                for epoch in range(epochs):
                    if not self.is_training:
                        break

                    history = model.fit(
                        self.X_train, self.y_train,
                        validation_data=(self.X_val, self.y_val),
                        epochs=1,
                        batch_size=batch_size,
                        verbose=0,
                        callbacks=[early_stop, reduce_lr]
                    )

                    # ì§„í–‰ë¥  ì—…ë°ì´íŠ¸
                    epoch_progress = ((epoch + 1) / epochs) * 100
                    self.root.after(0, self.update_epoch_progress, epoch_progress)
                    self.root.after(0, self.update_current_epoch, f"ì—í­: {epoch+1}/{epochs}")

                    # ë©”íŠ¸ë¦­ ì—…ë°ì´íŠ¸
                    loss = history.history['loss'][0]
                    val_loss = history.history['val_loss'][0]
                    mae = history.history['mae'][0]
                    val_mae = history.history['val_mae'][0]

                    self.root.after(0, self.update_metrics, loss, val_loss, mae, val_mae)

                    # ê·¸ë˜í”„ ì—…ë°ì´íŠ¸
                    if epoch % 5 == 0:
                        self.log(f"  ì—í­ {epoch+1}: Loss={loss:.4f}, Val_Loss={val_loss:.4f}")

                    # Early stopping ì²´í¬
                    if early_stop.stopped_epoch > 0:
                        self.log(f"  ì¡°ê¸° ì¢…ë£Œ: ì—í­ {epoch+1}")
                        break

                self.models[model_name] = model
                self.log(f"âœ… {model_name.upper()} ëª¨ë¸ í•™ìŠµ ì™„ë£Œ")

            if self.is_training:
                self.log("\nğŸ‰ ëª¨ë“  ëª¨ë¸ í•™ìŠµ ì™„ë£Œ!")
                if self.models: # í•™ìŠµëœ ëª¨ë¸ì´ ìˆì„ ê²½ìš°ì—ë§Œ í‰ê°€ ì§„í–‰
                    self.evaluate_models()
                    # ë²„íŠ¼ ìƒíƒœ ì—…ë°ì´íŠ¸
                    self.root.after(0, self.training_completed)
            else:
                self.log("â¹ï¸ í•™ìŠµì´ ì¤‘ì§€ë˜ì—ˆìŠµë‹ˆë‹¤.")

        except Exception as e:
            self.log(f"âŒ í•™ìŠµ ì¤‘ ì˜¤ë¥˜ ë°œìƒ: {str(e)}")
            messagebox.showerror("ì˜¤ë¥˜", f"í•™ìŠµ ì¤‘ ì˜¤ë¥˜ ë°œìƒ:\n{str(e)}")
        finally:
            self.is_training = False
            self.root.after(0, self.reset_buttons)

    def build_lstm_model(self, input_shape):
        """LSTM ëª¨ë¸ êµ¬ì¶•"""
        model = Sequential([
            Input(shape=input_shape),
            LSTM(units=100, return_sequences=True),
            Dropout(0.2),
            BatchNormalization(),
            LSTM(units=100, return_sequences=True),
            Dropout(0.2),
            BatchNormalization(),
            LSTM(units=100, return_sequences=False),
            Dropout(0.2),
            Dense(units=50, activation='relu'),
            Dense(units=1)
        ])
        return model

    def build_gru_model(self, input_shape):
        """GRU ëª¨ë¸ êµ¬ì¶•"""
        model = Sequential([
            Input(shape=input_shape),
            GRU(units=100, return_sequences=True),
            Dropout(0.2),
            GRU(units=100, return_sequences=True),
            Dropout(0.2),
            GRU(units=50, return_sequences=False),
            Dropout(0.2),
            Dense(units=30, activation='relu'),
            Dense(units=1)
        ])
        return model

    def build_rnn_model(self, input_shape):
        """RNN ëª¨ë¸ êµ¬ì¶•"""
        model = Sequential([
            Input(shape=input_shape),
            SimpleRNN(units=100, return_sequences=True),
            Dropout(0.2),
            SimpleRNN(units=50, return_sequences=False),
            Dropout(0.2),
            Dense(units=30, activation='relu'),
            Dense(units=1)
        ])
        return model

    def build_bilstm_model(self, input_shape):
        """Bidirectional LSTM ëª¨ë¸ êµ¬ì¶•"""
        model = Sequential([
            Input(shape=input_shape),
            Bidirectional(LSTM(units=50, return_sequences=True)),
            Dropout(0.2),
            Bidirectional(LSTM(units=50, return_sequences=False)),
            Dropout(0.2),
            Dense(units=30, activation='relu'),
            Dense(units=1)
        ])
        return model

    def evaluate_models(self):
        """ëª¨ë¸ í‰ê°€"""
        self.log("\nğŸ“Š ëª¨ë¸ í‰ê°€ ì‹œì‘...")

        results_text = "=" * 50 + "\n"
        results_text += "ğŸ“Š ëª¨ë¸ ì„±ëŠ¥ í‰ê°€ ê²°ê³¼\n"
        results_text += "=" * 50 + "\n\n"
        
        y_test_original = self.inverse_scale(self.y_test)

        # ê°œë³„ ëª¨ë¸ í‰ê°€
        for model_name, model in self.models.items():
            y_pred = model.predict(self.X_test, verbose=0).flatten()
            y_pred_original = self.inverse_scale(y_pred)
            
            mae = mean_absolute_error(y_test_original, y_pred_original)
            mse = mean_squared_error(y_test_original, y_pred_original)
            rmse = np.sqrt(mse)
            r2 = r2_score(y_test_original, y_pred_original)
            
            results_text += f"ğŸ”¹ {model_name.upper()} ëª¨ë¸\n"
            results_text += f"  MAE: {mae:.2f}\n"
            results_text += f"  RMSE: {rmse:.2f}\n"
            results_text += f"  RÂ²: {r2:.4f}\n\n"
            self.log(f"{model_name.upper()} - MAE: {mae:.2f}, RÂ²: {r2:.4f}")

        # ì•™ìƒë¸” ì˜ˆì¸¡ (ëª¨ë¸ì´ 2ê°œ ì´ìƒì¼ ë•Œë§Œ ì˜ë¯¸ ìˆìŒ)
        if len(self.models) > 1:
            ensemble_pred = self.ensemble_predict(self.X_test)
            ensemble_pred_original = self.inverse_scale(ensemble_pred)
            
            mae = mean_absolute_error(y_test_original, ensemble_pred_original)
            mse = mean_squared_error(y_test_original, ensemble_pred_original)
            rmse = np.sqrt(mse)
            r2 = r2_score(y_test_original, ensemble_pred_original)
            
            results_text += f"ğŸ”¸ ì•™ìƒë¸” ëª¨ë¸\n"
            results_text += f"  MAE: {mae:.2f}\n"
            results_text += f"  RMSE: {rmse:.2f}\n"
            results_text += f"  RÂ²: {r2:.4f}\n"
            self.log(f"ì•™ìƒë¸” - MAE: {mae:.2f}, RÂ²: {r2:.4f}")
            # ì‹œê°í™”ëŠ” ì•™ìƒë¸” ê²°ê³¼ë¡œ ì—…ë°ì´íŠ¸
            self.update_visualization(y_test_original, ensemble_pred_original)
        else: # ëª¨ë¸ì´ í•˜ë‚˜ì¼ ê²½ìš°
            # ë§ˆì§€ë§‰ìœ¼ë¡œ í‰ê°€ëœ ëª¨ë¸ì˜ ì˜ˆì¸¡ ê²°ê³¼ë¡œ ì‹œê°í™”
            self.update_visualization(y_test_original, y_pred_original)


        # ê²°ê³¼ í…ìŠ¤íŠ¸ ì—…ë°ì´íŠ¸
        self.root.after(0, self.update_results, results_text)

    def ensemble_predict(self, X):
        """ì•™ìƒë¸” ì˜ˆì¸¡"""
        if not self.models:
            return np.array([])
        predictions = [model.predict(X, verbose=0).flatten() for model in self.models.values()]
        return np.mean(predictions, axis=0)

    def inverse_scale(self, scaled_data):
        """ì—­ìŠ¤ì¼€ì¼ë§"""
        n_features = self.scaler.n_features_in_
        dummy = np.zeros((len(scaled_data), n_features))
        # 'FUTURE'ê°€ ìŠ¤ì¼€ì¼ë§ ëŒ€ìƒ ì»¬ëŸ¼ ì¤‘ 2ë²ˆì§¸ì˜€ìœ¼ë¯€ë¡œ í•´ë‹¹ ìœ„ì¹˜ì— ë°ì´í„° ì‚½ì…
        # ì£¼ì˜: preprocess_dataì˜ scaled_list ìˆœì„œì— ì˜ì¡´ì 
        # ['TOTALCNT', 'FUTURE', 'MA_5', ...] -> FUTUREëŠ” 1ë²ˆ ì¸ë±ìŠ¤
        dummy[:, 1] = scaled_data # scaled_listì—ì„œ 'FUTURE'ê°€ ë‘ë²ˆì§¸(ì¸ë±ìŠ¤ 1)ì˜€ìŒì„ ê°€ì •
        return self.scaler.inverse_transform(dummy)[:, 1]

    def run_prediction(self):
        """ì˜ˆì¸¡ ì‹¤í–‰"""
        if not self.models:
            messagebox.showerror("ì˜¤ë¥˜", "ë¨¼ì € ëª¨ë¸ì„ í•™ìŠµí•˜ê±°ë‚˜ ë¶ˆëŸ¬ì˜¤ì„¸ìš”!")
            return
        if self.X_test is None:
            messagebox.showerror("ì˜¤ë¥˜", "í…ŒìŠ¤íŠ¸ ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤. ë¨¼ì € ë°ì´í„°ë¥¼ ë¡œë“œí•˜ì„¸ìš”!")
            return

        try:
            self.log("ğŸ”® ì˜ˆì¸¡ ì‹¤í–‰ ì¤‘...")

            # ì˜ˆì¸¡ ìˆ˜í–‰
            ensemble_pred = self.ensemble_predict(self.X_test[-100:])
            ensemble_pred_original = self.inverse_scale(ensemble_pred)
            y_test_original = self.inverse_scale(self.y_test[-100:])

            # ë³‘ëª© êµ¬ê°„ ê°ì§€
            threshold = np.percentile(y_test_original, 85)
            bottlenecks = ensemble_pred_original > threshold

            # ê²°ê³¼ ì¶œë ¥
            result_text = "=" * 50 + "\n"
            result_text += "ğŸ”® ì˜ˆì¸¡ ê²°ê³¼ (ìµœê·¼ 10ê°œ)\n"
            result_text += "=" * 50 + "\n\n"

            for i in range(-10, 0):
                actual = y_test_original[i]
                predicted = ensemble_pred_original[i]
                error = abs(actual - predicted)
                is_bottleneck = "âš ï¸ ë³‘ëª©" if bottlenecks[i] else "ì •ìƒ"

                result_text += f"ì‹¤ì œ: {actual:.0f} | ì˜ˆì¸¡: {predicted:.0f}\n"
                result_text += f"ì˜¤ì°¨: {error:.1f} | ìƒíƒœ: {is_bottleneck}\n"
                result_text += "-" * 30 + "\n"

            # ë³‘ëª© ì˜ˆì¸¡ í†µê³„
            n_bottlenecks = np.sum(bottlenecks)
            bottleneck_ratio = n_bottlenecks / len(bottlenecks) * 100

            result_text += f"\nğŸ“Š ë³‘ëª© ì˜ˆì¸¡ í†µê³„\n"
            result_text += f"ë³‘ëª© êµ¬ê°„: {n_bottlenecks}ê°œ ({bottleneck_ratio:.1f}%)\n"
            result_text += f"ì„ê³„ê°’: {threshold:.0f}\n"

            self.root.after(0, self.update_results, result_text)
            self.log("âœ… ì˜ˆì¸¡ ì™„ë£Œ!")

            # ì‹œê°í™” ì—…ë°ì´íŠ¸
            self.update_visualization(y_test_original, ensemble_pred_original)

        except Exception as e:
            self.log(f"âŒ ì˜ˆì¸¡ ì‹¤íŒ¨: {str(e)}")
            messagebox.showerror("ì˜¤ë¥˜", f"ì˜ˆì¸¡ ì‹¤íŒ¨:\n{str(e)}")

    def save_models(self):
        """ëª¨ë¸ ì €ì¥"""
        if not self.models:
            messagebox.showerror("ì˜¤ë¥˜", "ì €ì¥í•  ëª¨ë¸ì´ ì—†ìŠµë‹ˆë‹¤!")
            return

        try:
            # ì €ì¥ ë””ë ‰í† ë¦¬ ìƒì„±
            save_dir = f"saved_models_{datetime.now().strftime('%Y%m%d_%H%M%S')}"
            os.makedirs(save_dir, exist_ok=True)

            # ê° ëª¨ë¸ ì €ì¥
            for model_name, model in self.models.items():
                model_path = os.path.join(save_dir, f'{model_name}_model.keras')
                model.save(model_path)
                self.log(f"ğŸ’¾ {model_name} ëª¨ë¸ ì €ì¥: {model_path}")

            # ìŠ¤ì¼€ì¼ëŸ¬ ì €ì¥
            scaler_path = os.path.join(save_dir, 'scaler.pkl')
            joblib.dump(self.scaler, scaler_path)
            self.log(f"ğŸ’¾ ìŠ¤ì¼€ì¼ëŸ¬ ì €ì¥: {scaler_path}")

            # ì„¤ì • ì €ì¥
            config = {
                'seq_length': self.seq_var.get(),
                'future_minutes': self.future_var.get(),
                'input_shape': (self.X_train.shape[1], self.X_train.shape[2])
            }

            with open(os.path.join(save_dir, 'config.json'), 'w') as f:
                json.dump(config, f)

            self.log(f"âœ… ëª¨ë“  ëª¨ë¸ ë° ì„¤ì • ì €ì¥ ì™„ë£Œ! (í´ë”: {save_dir})")
            messagebox.showinfo("ì„±ê³µ", f"ëª¨ë¸ì´ '{save_dir}' í´ë”ì— ì„±ê³µì ìœ¼ë¡œ ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤!")

        except Exception as e:
            self.log(f"âŒ ëª¨ë¸ ì €ì¥ ì‹¤íŒ¨: {str(e)}")
            messagebox.showerror("ì˜¤ë¥˜", f"ëª¨ë¸ ì €ì¥ ì‹¤íŒ¨:\n{str(e)}")

    def load_saved_models(self):
        """ì €ì¥ëœ ëª¨ë¸ì„ ì‚¬ìš©ìê°€ ì„ íƒí•˜ì—¬ ë¶ˆëŸ¬ì˜¤ê¸°"""
        try:
            # íŒŒì¼ ì„ íƒ ë‹¤ì´ì–¼ë¡œê·¸ ì—´ê¸°
            initial_dir = 'saved_models' if os.path.exists('saved_models') else '.'
            model_path = filedialog.askopenfilename(
                title="ëª¨ë¸ íŒŒì¼ ì„ íƒ",
                initialdir=os.path.abspath(initial_dir), # ì‹œì‘ ë””ë ‰í† ë¦¬ ì„¤ì •
                filetypes=[("Keras ëª¨ë¸", "*.keras"), ("ëª¨ë“  íŒŒì¼", "*.*")]
            )

            # ì‚¬ìš©ìê°€ íŒŒì¼ì„ ì„ íƒí•œ ê²½ìš°
            if model_path:
                self.log("ğŸ“‚ ì„ íƒí•œ ëª¨ë¸ ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘...")
                self.models.clear() # ê¸°ì¡´ ëª¨ë¸ ì´ˆê¸°í™”

                model_dir = os.path.dirname(model_path)
                model_filename = os.path.basename(model_path)
                model_name = model_filename.replace('_model.keras', '')

                # ëª¨ë¸ ë¡œë“œ
                self.models[model_name] = load_model(model_path, compile=False)
                self.log(f"âœ… {model_name} ëª¨ë¸ ë¡œë“œ ì™„ë£Œ: {model_filename}")

                # ìŠ¤ì¼€ì¼ëŸ¬ ë¡œë“œ (ëª¨ë¸ê³¼ ë™ì¼í•œ ë””ë ‰í† ë¦¬ì—ì„œ ì°¾ê¸°)
                scaler_path = os.path.join(model_dir, 'scaler.pkl')
                if os.path.exists(scaler_path):
                    self.scaler = joblib.load(scaler_path)
                    self.log("âœ… ìŠ¤ì¼€ì¼ëŸ¬ ë¡œë“œ ì™„ë£Œ")
                else:
                    self.scaler = None # ìŠ¤ì¼€ì¼ëŸ¬ê°€ ì—†ìœ¼ë©´ Noneìœ¼ë¡œ ì„¤ì •
                    self.log("âš ï¸ ìŠ¤ì¼€ì¼ëŸ¬ íŒŒì¼(scaler.pkl)ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.")
                    messagebox.showwarning("ê²½ê³ ", "ëª¨ë¸ê³¼ í•¨ê»˜ ì €ì¥ëœ ìŠ¤ì¼€ì¼ëŸ¬(scaler.pkl)ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.\nì •í™•í•œ ì˜ˆì¸¡ì„ ìœ„í•´ì„  ë°˜ë“œì‹œ ë°ì´í„° ë¡œë“œë¥¼ ë‹¤ì‹œ ì§„í–‰í•´ì•¼ í•©ë‹ˆë‹¤.")

                # ì„¤ì • ë¡œë“œ (ëª¨ë¸ê³¼ ë™ì¼í•œ ë””ë ‰í† ë¦¬ì—ì„œ ì°¾ê¸°)
                config_path = os.path.join(model_dir, 'config.json')
                if os.path.exists(config_path):
                    with open(config_path, 'r') as f:
                        config = json.load(f)
                    self.seq_var.set(config.get('seq_length', 30))
                    self.future_var.set(config.get('future_minutes', 10))
                    self.log("âœ… ì„¤ì • íŒŒì¼ ë¡œë“œ ì™„ë£Œ")

                # ë²„íŠ¼ ìƒíƒœ ì—…ë°ì´íŠ¸
                self.save_btn.config(state=tk.NORMAL) # ë¶ˆëŸ¬ì˜¨ ëª¨ë¸ì€ ë‹¤ì‹œ ì €ì¥í•  ìˆ˜ ìˆë„ë¡ í™œì„±í™”
                if self.data is not None and self.scaler is not None:
                     self.predict_btn.config(state=tk.NORMAL)
                else:
                     self.predict_btn.config(state=tk.DISABLED)

                messagebox.showinfo("ì„±ê³µ", f"'{model_name}' ëª¨ë¸ì„ ì„±ê³µì ìœ¼ë¡œ ë¶ˆëŸ¬ì™”ìŠµë‹ˆë‹¤!")

        except Exception as e:
            self.log(f"âŒ ëª¨ë¸ ë¶ˆëŸ¬ì˜¤ê¸° ì‹¤íŒ¨: {str(e)}")
            messagebox.showerror("ì˜¤ë¥˜", f"ëª¨ë¸ ë¶ˆëŸ¬ì˜¤ê¸° ì‹¤íŒ¨:\n{str(e)}")

    def update_current_model(self, text):
        """í˜„ì¬ ëª¨ë¸ ë¼ë²¨ ì—…ë°ì´íŠ¸"""
        self.current_model_label.config(text=text)

    def update_overall_progress(self, value):
        """ì „ì²´ ì§„í–‰ë¥  ì—…ë°ì´íŠ¸"""
        self.overall_progress['value'] = value

    def update_epoch_progress(self, value):
        """ì—í­ ì§„í–‰ë¥  ì—…ë°ì´íŠ¸"""
        self.epoch_progress['value'] = value

    def update_current_epoch(self, text):
        """í˜„ì¬ ì—í­ ë¼ë²¨ ì—…ë°ì´íŠ¸"""
        self.current_epoch_label.config(text=text)

    def update_metrics(self, loss, val_loss, mae, val_mae):
        """ë©”íŠ¸ë¦­ ì—…ë°ì´íŠ¸"""
        self.metric_labels["Loss:"].config(text=f"{loss:.4f}")
        self.metric_labels["Val Loss:"].config(text=f"{val_loss:.4f}")
        self.metric_labels["MAE:"].config(text=f"{mae:.4f}")
        self.metric_labels["Val MAE:"].config(text=f"{val_mae:.4f}")

    def update_results(self, text):
        """ê²°ê³¼ í…ìŠ¤íŠ¸ ì—…ë°ì´íŠ¸"""
        self.results_text.config(state=tk.NORMAL)
        self.results_text.delete(1.0, tk.END)
        self.results_text.insert(tk.END, text)
        self.results_text.config(state=tk.DISABLED)

    def update_visualization(self, y_true, y_pred):
        """ì‹œê°í™” ì—…ë°ì´íŠ¸"""
        self.ax.clear()
        self.ax.set_facecolor('#3c3c3c')

        # ì˜ˆì¸¡ ê²°ê³¼ í”Œë¡¯
        self.ax.plot(y_true[:100], label=self.text_labels['actual'], color='#00ff00', linewidth=2)
        self.ax.plot(y_pred[:100], label=self.text_labels['predicted'], color='#ff6b6b', linewidth=1.5, alpha=0.8)

        # ì–¸ì–´ì— ë”°ë¥¸ ì œëª©ê³¼ ë¼ë²¨ ì„¤ì •
        self.ax.set_title(self.text_labels['prediction_comparison'], color='white', fontsize=12, pad=10)
        self.ax.set_xlabel(self.text_labels['time_index'], color='white', fontsize=10)
        self.ax.set_ylabel(self.text_labels['logistics_volume'], color='white', fontsize=10)
        self.ax.tick_params(colors='white', labelsize=9)
        self.ax.legend(loc='upper right', framealpha=0.9)
        self.ax.grid(True, alpha=0.3)

        # tight_layoutìœ¼ë¡œ ë ˆì´ì•„ì›ƒ ì¡°ì •
        self.fig.tight_layout()

        self.canvas.draw()

    def training_completed(self):
        """í•™ìŠµ ì™„ë£Œ ì²˜ë¦¬"""
        self.train_btn.config(state=tk.DISABLED)
        self.stop_btn.config(state=tk.DISABLED)
        self.predict_btn.config(state=tk.NORMAL)
        self.save_btn.config(state=tk.NORMAL)
        self.load_model_btn.config(state=tk.NORMAL)

        messagebox.showinfo("ì™„ë£Œ", "ëª¨ë“  ëª¨ë¸ í•™ìŠµì´ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤!")

    def reset_buttons(self):
        """ë²„íŠ¼ ìƒíƒœ ë¦¬ì…‹"""
        self.train_btn.config(state=tk.NORMAL if self.data is not None else tk.DISABLED)
        self.stop_btn.config(state=tk.DISABLED)
        self.load_model_btn.config(state=tk.NORMAL)

def main():
    """ë©”ì¸ í•¨ìˆ˜"""
    print("="*60)
    print("ë°˜ë„ì²´ ë¬¼ë¥˜ ì˜ˆì¸¡ í•˜ì´ë¸Œë¦¬ë“œ AI ì‹œìŠ¤í…œ ì‹œì‘")
    print("="*60)

    # í•œê¸€ í°íŠ¸ ì²´í¬ ë° ì•ˆë‚´
    if not font_initialized:
        print("\nâš ï¸  í•œê¸€ í°íŠ¸ ì„¤ì • ì•ˆë‚´:")
        print("â”"*50)

        system = platform.system()
        if system == 'Windows':
            print("Windows ì‚¬ìš©ì:")
            print("  1. ë‚˜ëˆ”ê³ ë”• í°íŠ¸ ì„¤ì¹˜: https://hangeul.naver.com/font")
            print("  2. ë˜ëŠ” ì´ë¯¸ ì„¤ì¹˜ëœ 'ë§‘ì€ ê³ ë”•' ì‚¬ìš©")
        elif system == 'Darwin':
            print("macOS ì‚¬ìš©ì:")
            print("  1. ë‚˜ëˆ”ê³ ë”• í°íŠ¸ ì„¤ì¹˜: https://hangeul.naver.com/font")
            print("  2. ì„¤ì¹˜ í›„ í”„ë¡œê·¸ë¨ ì¬ì‹œì‘")
        else:
            print("Linux ì‚¬ìš©ì:")
            print("  1. sudo apt-get install fonts-nanum")
            print("  2. fc-cache -fv")

        print("\ní˜„ì¬ëŠ” ì˜ë¬¸ìœ¼ë¡œ í‘œì‹œë©ë‹ˆë‹¤.")
        print("â”"*50)
    else:
        print("âœ“ í•œê¸€ í°íŠ¸ ì„¤ì • ì™„ë£Œ")

    print("\ní”„ë¡œê·¸ë¨ì„ ì‹œì‘í•©ë‹ˆë‹¤...\n")

    root = tk.Tk()
    app = HybridModelGUI(root)
    root.mainloop()

if __name__ == "__main__":
    main()
