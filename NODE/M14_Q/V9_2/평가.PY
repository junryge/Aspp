#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
ğŸš€ V11.5 ìµœì¢… í‰ê°€ - AI + í•˜ì´ë¸Œë¦¬ë“œ ê°•ì œ ë³´ì •
ê¸°ëŠ¥:
  1. AI ëª¨ë¸ë¡œ 1ì°¨ ì˜ˆì¸¡ (ê¸°ì¡´ ë°©ì‹)
  2. 'ì…ê³ ëŸ‰ í­ë°œ' ë“± íŠ¹ì • ì¡°ê±´ì—ì„œ ì˜ˆì¸¡ê°’ì„ ê°•ì œë¡œ 1700 ì´ìƒìœ¼ë¡œ ë³´ì •
  3. ìµœì¢… ê²°ê³¼ ì €ì¥
"""
import numpy as np
import pandas as pd
import xgboost as xgb
import pickle
import warnings
from datetime import timedelta
warnings.filterwarnings('ignore')

print("="*70)
print("ğŸš€ V11.5 í‰ê°€ - í•˜ì´ë¸Œë¦¬ë“œ ë³´ì • (AI + Rule)")
print("="*70)

PRED_OFFSET = 10
EVAL_FILE = '20251211_16í‰ê°€.CSV' # ğŸ”´ í‰ê°€í•  íŒŒì¼ëª… í™•ì¸!

# 1. ëª¨ë¸ ë° í”¼ì²˜ ì •ë³´ ë¡œë“œ
print("ğŸ“‚ ëª¨ë¸ ë¡œë”© (model_v11_delta_focused.pkl ë“±)...")
try:
    # ëª¨ë¸ íŒŒì¼ëª…ì´ ë‹¤ë¥´ë©´ ì—¬ê¸°ì„œ ìˆ˜ì •í•˜ì„¸ìš” (ì˜ˆ: model_v11_280seq.pkl)
    with open('model_v11_280seq.pkl', 'rb') as f: 
        model_base = pickle.load(f)
    with open('features_v11_280seq.pkl', 'rb') as f: 
        feature_cols = pickle.load(f)
except FileNotFoundError:
    print("âš  ëª¨ë¸ íŒŒì¼ì´ ì—†ì–´ì„œ ê¸°ë³¸ ëª¨ë¸(model_v10_base.pkl)ì„ ì°¾ìŠµë‹ˆë‹¤.")
    try:
        with open('model_v10_base.pkl', 'rb') as f: model_base = pickle.load(f)
        with open('features_v10.pkl', 'rb') as f: feature_cols = pickle.load(f)
    except:
        print("âŒ ì‹¤í–‰ ì‹¤íŒ¨: ëª¨ë¸ íŒŒì¼ì´ ì•„ì˜ˆ ì—†ìŠµë‹ˆë‹¤.")
        exit()

# 2. ë°ì´í„° ë¡œë“œ
print(f"ğŸ“‚ í‰ê°€ ë°ì´í„°: {EVAL_FILE}")
try:
    df_raw = pd.read_csv(EVAL_FILE, on_bad_lines='skip', encoding='utf-8')
except:
    df_raw = pd.read_csv(EVAL_FILE, on_bad_lines='skip', encoding='cp949')

df_raw['CURRTIME_OBJ'] = pd.to_datetime(df_raw['CURRTIME'].astype(str), format='%Y%m%d%H%M', errors='coerce')

# 3. í”¼ì²˜ ìƒì„± (í•™ìŠµ ë•Œì™€ ë™ì¼í•˜ê²Œ)
def create_vectorized_features(df):
    df = df.copy()
    cols = ['TOTALCNT', 'M14AM14B', 'M14AM14BSUM', 'M10AM14A', 
            'M14.QUE.ALL.TRANSPORT4MINOVERCNT', 'M14.QUE.OHT.OHTUTIL',
            'M14.QUE.ALL.CURRENTQCREATED', 'M14.QUE.ALL.CURRENTQCOMPLETED']
    for c in cols: df[c] = pd.to_numeric(df[c], errors='coerce').fillna(0)
    
    df['Gap'] = df['M14.QUE.ALL.CURRENTQCREATED'] - df['M14.QUE.ALL.CURRENTQCOMPLETED']
    
    # Lag & Rolling (280ë¶„ê¹Œì§€)
    lags = [1, 3, 5, 10, 20, 50, 100, 280]
    for lag in lags:
        df[f'Total_Lag_{lag}'] = df['TOTALCNT'].shift(lag)
        df[f'M14B_Lag_{lag}'] = df['M14AM14B'].shift(lag)
    
    windows = [10, 30, 60, 100, 280]
    for w in windows:
        df[f'Total_Mean_{w}'] = df['TOTALCNT'].rolling(w).mean()
        df[f'Total_Std_{w}'] = df['TOTALCNT'].rolling(w).std()

    # ë³€í™”ëŸ‰
    df['Slope_1'] = df['TOTALCNT'] - df['TOTALCNT'].shift(1)
    df['Slope_3'] = df['TOTALCNT'] - df['TOTALCNT'].shift(3)
    df['Accel_1'] = df['Slope_1'] - df['Slope_1'].shift(1)
    df['Total_Delta_10'] = df['TOTALCNT'] - df['Total_Lag_10']

    df['Target_Total_Future'] = df['TOTALCNT'].shift(-PRED_OFFSET)
    return df

print("ğŸ”„ í”¼ì²˜ ìƒì„± ì¤‘...")
df_feat = create_vectorized_features(df_raw)

# ìœ íš¨ ë°ì´í„° í•„í„°ë§
df_valid = df_feat.dropna(subset=feature_cols + ['Target_Total_Future']).copy()
X_eval = df_valid[feature_cols]
current_total = df_valid['TOTALCNT']
y_true = df_valid['Target_Total_Future']

# 4. AI ì˜ˆì¸¡ (1ì°¨)
print("ğŸš€ AI ì˜ˆì¸¡ ìˆ˜í–‰ (1ì°¨)...")
pred_delta = model_base.predict(X_eval)
pred_ai = current_total + pred_delta

# =========================================================================
# ğŸ”¥ [í•µì‹¬] í•˜ì´ë¸Œë¦¬ë“œ ë³´ì • ë¡œì§ (Rule Injection)
# AIê°€ ë†“ì¹œ 1700 íŒ¨í„´ì„ ê°•ì œë¡œ ì¡ì•„ë‚´ëŠ” êµ¬ê°„
# =========================================================================
print("ğŸ”§ í•˜ì´ë¸Œë¦¬ë“œ ë³´ì • ì ìš© ì¤‘ (Rule-Based)...")

final_preds = []
for i in range(len(pred_ai)):
    ai_val = pred_ai.iloc[i]
    cur_val = current_total.iloc[i]
    
    # íŒíŠ¸ ë°ì´í„° ê°€ì ¸ì˜¤ê¸°
    input_load = df_valid['M14AM14B'].iloc[i]      # ì…ê³ ëŸ‰
    input_sum = df_valid['M14AM14BSUM'].iloc[i]    # ì…ê³ ëŸ‰ í•©ê³„
    gap_val = df_valid['Gap'].iloc[i]              # ëŒ€ê¸°ì—´ ì°¨ì´
    
    boost = 0
    
    # -------------------------------------------------------------
    # [ê·œì¹™ 1] "ì…ê³ ëŸ‰ í­ë°œ" íŒ¨í„´ (Gapì´ ë‚®ì•„ë„ ë¬´ì¡°ê±´ 1700 ê°)
    # -------------------------------------------------------------
    if input_load >= 540 and input_sum >= 610:
        # AIê°€ 1680 ë°‘ìœ¼ë¡œ ê²ë¨¹ì—ˆìœ¼ë©´ ê°•ì œë¡œ 1710ê¹Œì§€ ì˜¬ë¦¼
        if ai_val < 1680:
            boost = (1710 - ai_val) 
        else:
            boost = 30 # ì´ë¯¸ ë†’ê²Œ ë¶ˆë €ìœ¼ë©´ +30 ë³´ë„ˆìŠ¤

    # -------------------------------------------------------------
    # [ê·œì¹™ 2] "ëŒ€ê¸°ì—´ ì ì²´" íŒ¨í„´ (ì´ë¯¸ 1600 ë„˜ì—ˆëŠ”ë° Gap í¼)
    # -------------------------------------------------------------
    elif cur_val >= 1600 and gap_val > 200:
        if ai_val < cur_val: # AIê°€ ë–¨ì–´ì§ˆê±°ë¼ê³  í•˜ë©´ ë¬´ì‹œí•˜ê³  í˜„ìƒìœ ì§€+ì•ŒíŒŒ
            boost = (cur_val - ai_val) + 20
            
    # ìµœì¢…ê°’ ì ìš©
    final_preds.append(ai_val + boost)

# ë¦¬ìŠ¤íŠ¸ë¥¼ ì‹œë¦¬ì¦ˆë¡œ ë³€í™˜
pred_final = pd.Series(final_preds, index=pred_ai.index)

# 5. ê²°ê³¼ ì •ë¦¬
results = pd.DataFrame()
results['í˜„ì¬ì‹œê°„'] = df_valid['CURRTIME_OBJ'].dt.strftime('%Y-%m-%d %H:%M')
results['í˜„ì¬TOTALCNT'] = current_total.round(2)
results['ì˜ˆì¸¡ì‹œì '] = (df_valid['CURRTIME_OBJ'] + timedelta(minutes=PRED_OFFSET)).dt.strftime('%Y-%m-%d %H:%M')
results['ì‹¤ì œê°’'] = y_true.round(2)
results['AIì˜ˆì¸¡'] = pred_ai.round(2)      # ë³´ì • ì „
results['ìµœì¢…ì˜ˆì¸¡'] = pred_final.round(2) # ë³´ì • í›„
results['ì˜¤ì°¨'] = (results['ì‹¤ì œê°’'] - results['ìµœì¢…ì˜ˆì¸¡']).round(2)
results['ì ˆëŒ€ì˜¤ì°¨'] = results['ì˜¤ì°¨'].abs()

# ë³´ì • íš¨ê³¼ í™•ì¸ìš© ì»¬ëŸ¼
results['ë³´ì •ëŸ‰'] = (results['ìµœì¢…ì˜ˆì¸¡'] - results['AIì˜ˆì¸¡']).round(2)
results['M14AM14B'] = df_valid['M14AM14B']
results['queue_gap'] = df_valid['Gap']

# ìœ„í—˜ ê°ì§€
results['ì‹¤ì œìœ„í—˜'] = np.where(results['ì‹¤ì œê°’'] >= 1700, 'O', '')
results['ì˜ˆì¸¡ìœ„í—˜'] = np.where(results['ìµœì¢…ì˜ˆì¸¡'] >= 1650, 'O', '')

# 6. í†µê³„ ì¶œë ¥
mae = results['ì ˆëŒ€ì˜¤ì°¨'].mean()
print(f"\nğŸ“Š ì „ì²´ MAE: {mae:.2f}")

high_val_mask = results['ì‹¤ì œê°’'] >= 1650
if high_val_mask.sum() > 0:
    mae_high_ai = (results.loc[high_val_mask, 'ì‹¤ì œê°’'] - results.loc[high_val_mask, 'AIì˜ˆì¸¡']).abs().mean()
    mae_high_final = results.loc[high_val_mask, 'ì ˆëŒ€ì˜¤ì°¨'].mean()
    
    print(f"\nğŸ”¥ ê³ ë¶€í•˜(>=1650) êµ¬ê°„ ê°œì„  íš¨ê³¼")
    print(f"   - AI ë‹¨ë… MAE: {mae_high_ai:.2f}")
    print(f"   - í•˜ì´ë¸Œë¦¬ë“œ MAE: {mae_high_final:.2f} (ğŸ“‰ ëŒ€í­ ê°ì†Œ ì˜ˆìƒ)")
    
    # 1700 ë„˜ëŠ” êµ¬ê°„ ìƒ˜í”Œ ì¶œë ¥
    print("\n[ë³´ì • ì ìš©ëœ 1700+ ì˜ˆì¸¡ ìƒ˜í”Œ]")
    cols = ['í˜„ì¬ì‹œê°„', 'ì‹¤ì œê°’', 'AIì˜ˆì¸¡', 'ìµœì¢…ì˜ˆì¸¡', 'ë³´ì •ëŸ‰', 'M14AM14B']
    print(results.loc[high_val_mask, cols].head(10).to_string(index=False))

# CSV ì €ì¥
outfile = 'Hybrid_Eval_Result.CSV'
results.to_csv(outfile, index=False, encoding='utf-8-sig')
print(f"\nğŸ’¾ ìµœì¢… ê²°ê³¼ ì €ì¥ ì™„ë£Œ: {outfile}")