================================================================================
V10_4 프로젝트 아키텍처 - 핵심 3개 섹션 발췌
================================================================================


━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
§7. 앙상블 모델 5개 규칙 (상세)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

[7-1] 투표 구성 (6~8표)
──────────────────────

6개 모델(또는 PDT 포함 8개)이 각각 1700+ 위험 여부를 판정하고, 투표 합산.

    votes = [
        # --- XGB 회귀 3개: 예측값 >= 1700이면 위험 투표 ---
        1 if pred_xgb_target >= 1700 else 0,       # [1표] XGB 타겟 (TOTALCNT만으로 판단)
        1 if pred_xgb_important >= 1700 else 0,     # [2표] XGB 중요 (로드/큐/허브 패턴)
        1 if pred_xgb_auxiliary >= 1700 else 0,     # [3표] XGB 보조 (물류이동/OHT/CNV)

        # --- LGBM 분류 3개: 모델이 직접 0/1 출력 ---
        pred_lgb_target,                             # [4표] LGBM 타겟 분류 결과
        pred_lgb_important,                          # [5표] LGBM 중요 분류 결과
        pred_lgb_auxiliary,                          # [6표] LGBM 보조 분류 결과
    ]

    # PDT 그룹 있으면 +2표 추가 (총 8표)
    if pred_xgb_pdt is not None:
        votes.append(1 if pred_xgb_pdt >= 1700 else 0)  # [7표] XGB PDT
        votes.append(pred_lgb_pdt)                        # [8표] LGBM PDT

    vote_sum = sum(votes)   # 0~6 (또는 0~8)
    total_votes = len(votes) # 6 또는 8

투표 특성:
  - XGB 회귀는 연속값 → 1700 기준으로 이진화하여 투표
  - LGBM 분류는 직접 0/1 출력을 투표로 사용
  - 각 그룹이 서로 다른 Feature를 보기 때문에 독립적 관점 확보


[7-2] 최종 판정 5개 규칙 (OR 조합)
───────────────────────────────────

5개 규칙 중 하나라도 True이면 최종 위험 판정:

    rule1 = vote_sum >= 3
    rule2 = (prob_lgb_important >= 0.50) and (current_total >= 1450)
    rule3 = (pred_xgb_important >= 1680) and (current_total >= 1500)
    rule4 = (current_total >= 1600) and (vote_sum >= 2)
    rule5 = (pred_xgb_important >= 1700)

    final_pred_danger = 1 if (rule1 or rule2 or rule3 or rule4 or rule5) else 0

┌──────────┬──────────────────────────────────────────┬──────────────────────┬─────────────────┐
│ 규칙     │ 조건                                     │ 설계 의도            │ 감지 대상       │
├──────────┼──────────────────────────────────────────┼──────────────────────┼─────────────────┤
│ Rule 1   │ vote_sum >= 3                            │ 다수결 원칙          │ 전반적 위험     │
│ Rule 2   │ prob_lgb_important>=0.50 & 현재>=1450    │ 확률 기반 조기 감지  │ 확률 조기 감지  │
│ Rule 3   │ pred_xgb_important>=1680 & 현재>=1500    │ 근접 예측 보완       │ 근접 보완       │
│ Rule 4   │ 현재>=1600 & vote_sum>=2                 │ 고위험 구간 민감     │ 고위험 민감     │
│ Rule 5   │ pred_xgb_important >= 1700               │ 강한 신호 단독 신뢰  │ 강신호 단독     │
└──────────┴──────────────────────────────────────────┴──────────────────────┴─────────────────┘


[7-3] 규칙 간 역할 분담 다이어그램
───────────────────────────────────

    [Rule 5] XGB 중요 >= 1700 ─────────────────── 강한 신호 단독
    [Rule 1] 투표 >= 3 ─────────────────────────── 다수결 합의
    [Rule 3] XGB 중요 >= 1680 & 현재 >= 1500 ──── 근접 보완
    [Rule 2] LGBM 확률 >= 0.50 & 현재 >= 1450 ── 확률 조기 감지
    [Rule 4] 현재 >= 1600 & 투표 >= 2 ──────────── 고위험 민감 감지
             ↑ 안전(0)                              위험(1) ↑

  - Rule 5, 1: 모델 예측이 충분히 강할 때 → 현재값 조건 없이 판정
  - Rule 3, 2: 모델이 근접/확률 수준일 때 → 현재값 조건 병행
  - Rule 4:    현재 상황이 이미 위험할 때 → 투표 기준 완화



━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
§8. 예측값 활용 황금 패턴
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

[8-1] V8.3 황금 패턴 (참고: 이전 버전)
──────────────────────────────────────

V8.3에서는 보정 로직에서 아래 패턴을 직접 사용:

    # V8.3 방식 - 1650~1699 구간에서 boost
    if M14AM14B > 540 and M14AM14BSUM > 620:   # gold_strict
        boost += 50
    if M14AM14B > 520 and M14AM14BSUM > 600:   # gold_normal
        boost += 40
    if queue_gap > 350:
        boost += 40


[8-2] V10_4 황금 패턴 활용 방식
────────────────────────────────

V10_4에서는 boost를 직접 적용하지 않고, Feature 엔지니어링으로 모델이 자동 학습:

┌───────────────────────┬─────────────────────────────────────┬──────────────┐
│ V8.3 황금 패턴        │ V10_4 Feature로 전환                │ 학습 그룹    │
├───────────────────────┼─────────────────────────────────────┼──────────────┤
│ M14AM14B > 520        │ current값 + flag_1500/1600 Feature  │ auxiliary    │
│ M14AM14BSUM > 600     │ current값 + delta/velocity Feature  │ auxiliary    │
│ queue_gap > 250       │ QUEUE_GAP의 20개 시계열 Feature     │ auxiliary    │
│ TRANSPORT > 151       │ TRANSPORT4MINOVERCNT의 20개 Feature │ important    │
│ Triple Check 조합     │ 모델이 Feature 상호작용 자동 학습   │ XGB 트리분할 │
└───────────────────────┴─────────────────────────────────────┴──────────────┘


[8-3] Triple Check 패턴 비교 (V8.3 핵심 → V10_4 자동화)
────────────────────────────────────────────────────────

    Triple Check = M14AM14B > 520 & M14AM14BSUM > 600 & queue_gap > 250

┌──────────────┬──────────────────────────────────┬──────────────────────────────────────┐
│ 항목         │ V8.3                             │ V10_4                                │
├──────────────┼──────────────────────────────────┼──────────────────────────────────────┤
│ 적용 방식    │ if문으로 직접 boost              │ XGB가 트리 분할로 자동 학습          │
│ 패턴 발동    │ 1650~1699 구간에서만             │ 전 구간에서 Feature 반영             │
│ 정확도       │ 96.7% (11월 급상승 패턴)         │ 모델이 데이터로부터 최적 임계값 학습 │
│ 한계         │ 12월 점진상승에서 실패            │ 다양한 패턴 대응 가능                │
└──────────────┴──────────────────────────────────┴──────────────────────────────────────┘


[8-4] 대시보드에서의 황금 패턴 시각화
─────────────────────────────────────

    XGB_타겟(MAX) = xgb_target 예측값  → 예측 상한 (가장 공격적 예측)
    XGB_보조(MIN) = xgb_auxiliary 예측값 → 예측 하한 (가장 보수적 예측)
    앙상블예측    = XGB 평균 → 중간값

  - MAX와 MIN이 모두 1700+: 매우 강한 위험 신호 (황금 패턴 수준)
  - MAX만 1700+:            일부 패턴 감지, 주의 필요
  - 둘 다 1700 미만:        안전 구간



━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
§11. 모델 성능 지표 산출 로직
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

[11-1] 혼동 행렬 (기본 4분류)
─────────────────────────────

    actual_danger = df_result['실제위험(1700+)'] == 1    # 실제 돌파 여부
    pred_danger   = df_result['최종판정'] == 1            # 모델 위험 판정

    TP = (actual_danger & pred_danger).sum()       # 실제 위험 & 예측 위험
    TN = (~actual_danger & ~pred_danger).sum()     # 실제 안전 & 예측 안전
    FP = (~actual_danger & pred_danger).sum()      # 실제 안전 & 예측 위험 (오탐)
    FN = (actual_danger & ~pred_danger).sum()      # 실제 위험 & 예측 안전 (놓침)


[11-2] 핵심 성능 지표
─────────────────────

┌───────────────────────┬────────────────────────────────────┬────────────────────────────────┐
│ 지표                  │ 산출식                             │ 의미                           │
├───────────────────────┼────────────────────────────────────┼────────────────────────────────┤
│ Recall (감지율)       │ TP / (TP + FN) × 100              │ 실제 위험 중 몇 %를 감지했는가 │
│ Precision (정밀도)    │ TP / (TP + FP) × 100              │ 위험 예측 중 몇 %가 실제 위험  │
│ Accuracy (정확도)     │ (TP+TN) / (TP+TN+FP+FN) × 100    │ 전체 예측의 정확도             │
└───────────────────────┴────────────────────────────────────┴────────────────────────────────┘

    recall    = TP / actual_danger.sum() * 100       # 목표: 85%+
    precision = TP / pred_danger.sum() * 100          # FP 최소화
    accuracy  = (TP + TN) / (TP + TN + FP + FN) * 100


[11-3] 예측상태 6분류 (get_prediction_status 함수 전체)
──────────────────────────────────────────────────────

기본 4분류(TP/TN/FP/FN)를 시간 맥락으로 세분화하여 실질적 성능 판별:

    def get_prediction_status(row, all_df):
        actual = row['실제위험(1700+)']
        pred   = row['최종판정']
        current_time = row['현재시간_dt']

        # Case 1: 정확한 예측
        if actual == 1 and pred == 1:
            return '정상예측_TP'
        elif actual == 0 and pred == 0:
            return '정상예측_TN'

        # Case 2: 놓침(FN) → 10분 전에는 잡았는지 확인
        elif actual == 1 and pred == 0:
            time_10min_ago = current_time - timedelta(minutes=10)
            prev_data = all_df[all_df['현재시간_dt'] == time_10min_ago]
            if len(prev_data) > 0 and prev_data['최종판정'].values[0] == 1:
                return 'FN_10분전예측'    # 10분 전에 이미 잡음 → 실질적 OK
            else:
                return 'FN_완전놓침'      # 10분 전에도 못 잡음 → 실질적 문제!

        # Case 3: 오탐(FP) → 10분 후에 실제 돌파하는지 확인
        else:  # actual == 0 and pred == 1
            time_10min_later = current_time + timedelta(minutes=10)
            later_data = all_df[all_df['현재시간_dt'] == time_10min_later]
            if len(later_data) > 0 and later_data['실제위험(1700+)'].values[0] == 1:
                return 'FP_10분후돌파'    # 10분 후 실제 돌파 → 유효한 조기 경고
            else:
                return 'FP_잘못된경고'    # 10분 후에도 안전 → 실질적 오탐!


[11-4] 예측상태 분류표
──────────────────────

┌─────────────────┬────────┬────────┬──────────────────────────────────┬─────────────────────────┐
│ 상태            │ 실제   │ 예측   │ 시간 맥락                        │ 실질 평가               │
├─────────────────┼────────┼────────┼──────────────────────────────────┼─────────────────────────┤
│ 정상예측_TP     │ 위험   │ 위험   │ -                                │ ✅ 정확                 │
│ 정상예측_TN     │ 안전   │ 안전   │ -                                │ ✅ 정확                 │
│ FN_10분전예측   │ 위험   │ 안전   │ 10분 전 시점에서 이미 위험 예측  │ ⚠️ 허용 (조기 감지됨)   │
│ FN_완전놓침     │ 위험   │ 안전   │ 10분 전에도 안전으로 판정        │ ❌ 실질적 놓침          │
│ FP_10분후돌파   │ 안전   │ 위험   │ 10분 후 실제로 1700+ 돌파        │ ⚠️ 허용 (유효 조기경고) │
│ FP_잘못된경고   │ 안전   │ 위험   │ 10분 후에도 안전 유지            │ ❌ 실질적 오탐          │
└─────────────────┴────────┴────────┴──────────────────────────────────┴─────────────────────────┘


[11-5] 실질적 FN/FP 구분
─────────────────────────

    status_counts = df_result['예측상태'].value_counts()

    # 실질적으로 문제가 되는 건수만 추출
    real_fn = status_counts.get('FN_완전놓침', 0)      # 완전히 놓친 위험
    real_fp = status_counts.get('FP_잘못된경고', 0)    # 완전히 잘못된 경고

실질적 관점 재해석:
  - FN_10분전예측: FN이지만 10분 전에 이미 감지 → 허용 가능
  - FP_10분후돌파: FP이지만 유효한 조기 경고 → 허용 가능
  - 진짜 문제: FN_완전놓침 (위험 미감지) + FP_잘못된경고 (헛경고)


[11-6] 대시보드 vs 평가코드 산출 차이점
───────────────────────────────────────

  [평가코드 (V10_4평가10min.py)]
    - 기본 혼동행렬 기준 Recall:  TP / (TP + FN) × 100
    - FN = FN_10분전예측 + FN_완전놓침 모두 포함
    - → 단순 TP/(TP+FN) 계산

  [대시보드 (트렌드그래프10min.py)]
    - 예측상태 기반 Recall:
        total_positive = TP + FN_10min + FN_miss
        recall    = TP / total_positive * 100
        precision = TP / (TP + FP_10min + FP_false) * 100
    - FN_10분전예측을 FN에 포함하므로 Recall이 더 보수적
    - FP_10분후돌파도 FP에 포함하므로 Precision도 더 보수적

  주의:
    대시보드의 Recall/Precision은 예측상태 기반이므로
    평가 코드의 기본 혼동행렬과 약간 다를 수 있음.
    (FN_10분전예측을 FN에 포함 → Recall 수치가 더 낮게 나옴)


================================================================================
작성일: 2025-02-06
버전: V10_4 (XGBoost 회귀 + LightGBM 분류 + 투표 앙상블)
================================================================================
