# 🔍 V8_2평가.PY - 코드 한 줄씩 완전 분석

**고객용 - 모든 코드를 한 줄씩 설명합니다**

---

## 📑 목차

1. [파일 헤더 및 라이브러리](#1-파일-헤더-및-라이브러리-1~19행)
2. [Feature 생성 함수](#2-feature-생성-함수-21~245행)
3. [Boost 함수](#3-boost-함수-247~294행)
4. [모델 로드](#4-모델-로드-296~305행)
5. [데이터 로드](#5-데이터-로드-307~310행)
6. [평가 루프](#6-평가-루프-312~430행)
7. [통계 분석](#7-통계-분석-432~530행)
8. [검증 및 요약](#8-검증-및-요약-532~573행)

---

## 1. 파일 헤더 및 라이브러리 (1~19행)

### 코드

```python
#!/usr/bin/env python3
```
**설명:** 이 파일이 Python3로 실행되는 스크립트임을 알려줌

---

```python
# -*- coding: utf-8 -*-
```
**설명:** 한글 등 특수문자를 제대로 읽기 위한 인코딩 설정

---

```python
"""
🚀 평가 FINAL - multiplier=90 + 최적 보정 (주요값 +8)
완전판!
"""
```
**설명:** 파일 설명 주석
- multiplier=90으로 학습된 모델 평가
- boost 보정 적용
- 최종 완성 버전

---

```python
import numpy as np
```
**설명:** numpy 라이브러리 불러오기
- 용도: 수치 계산

---

```python
import pandas as pd
```
**설명:** pandas 라이브러리 불러오기
- 용도: CSV 파일 읽기, DataFrame 처리

---

```python
import pickle
```
**설명:** pickle 라이브러리 불러오기
- 용도: 저장된 모델 불러오기

---

```python
from datetime import timedelta
```
**설명:** datetime에서 timedelta 불러오기
- 용도: 시간 계산 (10분 후 시점 계산)

---

```python
import os
```
**설명:** os 라이브러리 불러오기
- 용도: 파일 존재 확인

---

```python
import gc
```
**설명:** garbage collector 불러오기
- 용도: 메모리 정리

---

```python
import warnings
warnings.filterwarnings('ignore')
```
**설명:** 경고 메시지 숨기기

---

```python
print("="*80)
print("🚀 평가 FINAL - multiplier=90 + 최적 보정 (주요값 +8)")
print("="*80)
```
**설명:** 프로그램 시작 메시지 출력

---

## 2. Feature 생성 함수 (21~245행)

```python
def create_features_13col_optimized(row_dict):
```
**설명:** Feature 생성 함수 (학습과 100% 동일)
- 입력: row_dict (13개 컬럼의 280분 데이터)
- 출력: 222개 Feature

---

```python
    """Feature 생성 (학습과 100% 동일)"""
```
**설명:** 함수 설명 - 학습 때와 완전히 같아야 함!

---

```python
    features = {}
```
**설명:** 빈 딕셔너리 생성 (Feature 저장용)

---

### 시퀀스 추출 (25~36행)

```python
    seq_m14b = np.array(row_dict['M14AM14B'])
```
**설명:** M14AM14B 데이터 배열로 변환

```python
    seq_m14b_sum = np.array(row_dict['M14AM14BSUM'])
```
**설명:** M14AM14BSUM 데이터 배열로 변환

```python
    seq_m14b_rev = np.array(row_dict['M14BM14A'])
```
**설명:** M14BM14A 데이터 배열로 변환

```python
    seq_m10a = np.array(row_dict['M14AM10A'])
```
**설명:** M14AM10A 데이터 배열로 변환

```python
    seq_m10a_rev = np.array(row_dict['M10AM14A'])
```
**설명:** M10AM14A 데이터 배열로 변환

```python
    seq_m16_rev = np.array(row_dict['M16M14A'])
```
**설명:** M16M14A 데이터 배열로 변환

```python
    seq_m16_sum = np.array(row_dict['M14AM16SUM'])
```
**설명:** M14AM16SUM 데이터 배열로 변환

```python
    seq_totalcnt = np.array(row_dict['TOTALCNT'])
```
**설명:** TOTALCNT 데이터 배열로 변환

```python
    seq_q_created = np.array(row_dict['M14.QUE.ALL.CURRENTQCREATED'])
```
**설명:** Queue Created 데이터 배열로 변환

```python
    seq_q_completed = np.array(row_dict['M14.QUE.ALL.CURRENTQCOMPLETED'])
```
**설명:** Queue Completed 데이터 배열로 변환

```python
    seq_oht = np.array(row_dict['M14.QUE.OHT.OHTUTIL'])
```
**설명:** OHT 사용률 데이터 배열로 변환

```python
    seq_transport = np.array(row_dict['M14.QUE.ALL.TRANSPORT4MINOVERCNT'])
```
**설명:** Transport 데이터 배열로 변환

```python
    seq_queue_gap = seq_q_created - seq_q_completed
```
**설명:** queue_gap 계산 (생성 - 완료)

---

**💡 참고:** 
- 37행~244행: 학습 코드와 100% 동일한 Feature 생성
- M14AM14B (10개), M14AM14BSUM (10개), ... 총 222개 Feature
- 자세한 설명은 학습 코드 리뷰 참조
- **중요:** 평가 시 Feature 생성은 학습과 완전히 같아야 함!

---

```python
    return features
```
**설명:** 생성된 222개 Feature 반환

---

## 3. Boost 함수 (247~294행)

### 함수 시작

```python
def adjust_light_plus(pred, m14b, m14bsum, gap, trans):
```
**설명:** boost 보정 함수 ⭐ 핵심!
- 입력:
  - pred: 원본 예측값
  - m14b: 현재 M14AM14B 값
  - m14bsum: 현재 M14AM14BSUM 값
  - gap: 현재 queue_gap 값
  - trans: 현재 transport 값
- 출력: 보정된 예측값

---

```python
    """🎯 1650~1699만 집중 - 조금만 더!"""
```
**설명:** 함수 설명
- 1650~1699 구간만 boost 적용
- 다른 구간은 그대로

---

```python
    boost = 0
```
**설명:** boost 초기화
- 기본값 0 (보정 없음)

---

### 1650~1699 구간 boost (253~291행)

```python
    if 1650 <= pred < 1700:
```
**설명:** 예측값이 1650~1699 구간이면
- 이 구간만 boost 적용!
- 다른 구간은 건드리지 않음

---

#### 황금 패턴 boost (256~263행)

```python
        if (m14b > 520 and m14bsum > 588):
            boost += 50  # 45→50
```
**설명:** 엄격한 황금 패턴
- 조건: M14AM14B > 520 AND M14AM14BSUM > 588
- boost: +50
- 주석: 원래 45였는데 50으로 강화

---

```python
        elif (m14b > 517 and m14bsum > 576):
            boost += 45  # 40→45
```
**설명:** 보통 황금 패턴
- 조건: M14AM14B > 517 AND M14AM14BSUM > 576
- boost: +45

---

```python
        elif (m14b > 509 and m14bsum > 570):
            boost += 35  # 30→35
```
**설명:** 느슨한 황금 패턴
- boost: +35

---

```python
        elif (m14b > 497 and m14bsum > 566):
            boost += 30  # 25→30
```
**설명:** 필수 조건
- boost: +30

---

#### queue_gap boost (266~273행)

```python
        if gap > 400:
            boost += 47  # 42→47
```
**설명:** gap이 400 초과
- boost: +47
- 의미: 작업 극심하게 밀림!

---

```python
        elif gap > 350:
            boost += 40  # 35→40
```
**설명:** gap이 350 초과
- boost: +40

---

```python
        elif gap > 300:
            boost += 40  # 35→40
```
**설명:** gap이 300 초과
- boost: +40

---

```python
        elif gap > 250:
            boost += 30  # 25→30
```
**설명:** gap이 250 초과
- boost: +30

---

#### Transport boost (276~279행)

```python
        if trans > 200:
            boost += 43  # 38→43
```
**설명:** transport가 200 초과
- boost: +43
- 의미: 운송 지연 극심!

---

```python
        elif trans > 180:
            boost += 40  # 35→40
```
**설명:** transport가 180 초과
- boost: +40

---

#### 극단값 boost (282~283행)

```python
        if m14b > 550:
            boost += 37  # 32→37
```
**설명:** M14AM14B가 550 초과
- boost: +37
- 의미: 매우 높은 수준!

---

#### 복합 조건 boost (286~291행)

```python
        if gap > 300 and trans > 151:
            boost += 37  # 32→37
```
**설명:** gap과 transport 동시 위험
- 조건: gap > 300 AND transport > 151
- boost: +37
- 의미: 밀림 + 지연 동시 발생!

---

```python
        if m14b > 520 and m14bsum > 588 and gap > 300 and trans > 151:
            boost += 45  # 38→45
```
**설명:** 최강 복합 위험
- 조건: 황금패턴 + gap > 300 + transport > 151
- boost: +45
- 의미: 모든 위험 요소 동시 발생! 🚨

---

### boost 적용 (293~295행)

```python
    pred = pred + boost
```
**설명:** 원본 예측값에 boost 더하기
- 예: 1680 + 40 = 1720

---

```python
    pred = min(pred, 2000)
```
**설명:** 최대값 제한
- min(): 둘 중 작은 값
- 2000 초과 방지

---

```python
    return pred
```
**설명:** 보정된 예측값 반환

---

### Boost 함수 핵심 요약

```
1650~1699 구간만 boost!

예시 1:
원본 1680 + boost 40 = 1720 ✅ 1700 넘음!

예시 2:
원본 1400 + boost 0 = 1400 ✅ 그대로

예시 3:
원본 1750 + boost 0 = 1750 ✅ 그대로

→ 1650~1699만 집중 보정!
```

---

## 4. 모델 로드 (296~305행)

```python
model = None
```
**설명:** model 변수 초기화

---

```python
for mf in ['model_13col_final.pkl', 'model_13col_final.pkl']:
```
**설명:** 모델 파일 리스트 (중복되어 있음)
- 실제로는 하나만 있어도 됨

---

```python
    if os.path.exists(mf):
```
**설명:** 파일이 존재하는지 확인
- os.path.exists(): 파일 존재 여부

---

```python
        with open(mf, 'rb') as f:
            model = pickle.load(f)
```
**설명:** 모델 파일 불러오기
- 'rb': 읽기 모드 (read binary)
- pickle.load(): 모델 로드

---

```python
        print(f"✅ 모델: {mf}")
        break
```
**설명:** 성공 메시지 출력 후 루프 종료

---

```python
if not model:
    print("❌ 모델 없음!")
    exit(1)
```
**설명:** 모델 로드 실패 시
- 에러 메시지 출력
- 프로그램 종료

---

## 5. 데이터 로드 (307~310행)

```python
df = pd.read_csv('data/M14_Q_20251014_TO_20251015.CSV', on_bad_lines='skip')
```
**설명:** 평가 데이터 CSV 파일 로드
- 경로: data/M14_Q_20251014_TO_20251015.CSV
- on_bad_lines='skip': 잘못된 라인 건너뛰기

---

```python
print(f"✅ 데이터: {len(df):,}행")
```
**설명:** 데이터 행 수 출력

---

```python
df['CURRTIME'] = pd.to_datetime(df['CURRTIME'].astype(str), format='%Y%m%d%H%M')
```
**설명:** CURRTIME을 datetime 형식으로 변환
- 예: '202510141430' → 2025-10-14 14:30:00

---

## 6. 평가 루프 (312~430행)

### 초기화

```python
results = []
```
**설명:** 결과를 저장할 리스트 초기화

---

```python
total = len(df) - 290
```
**설명:** 평가할 샘플 개수 계산
- len(df) - 290: 처음 280분(시퀀스) + 마지막 10분(타겟)

---

```python
print(f"\n🔄 평가 중... {total:,}개")
```
**설명:** 평가 시작 메시지

---

### 메인 루프

```python
for i in range(280, len(df) - 10):
```
**설명:** 슬라이딩 윈도우 루프
- 280번째부터 마지막-10까지
- i: 현재 위치

---

#### 데이터 추출 (315~327행)

```python
    row_dict = {
        'M14AM14B': df['M14AM14B'].iloc[i-280:i].values,
        'M14AM14BSUM': df['M14AM14BSUM'].iloc[i-280:i].values,
        # ... (13개 컬럼 모두)
    }
```
**설명:** 280분 시퀀스 데이터 추출
- iloc[i-280:i]: i-280부터 i-1까지 (280개)

---

#### 현재값 추출 (329~334행)

```python
    seq_totalcnt = row_dict['TOTALCNT']
```
**설명:** TOTALCNT 시퀀스

---

```python
    seq_m14b = row_dict['M14AM14B']
```
**설명:** M14AM14B 시퀀스

---

```python
    seq_m14b_sum = row_dict['M14AM14BSUM']
```
**설명:** M14AM14BSUM 시퀀스

---

```python
    seq_qc = row_dict['M14.QUE.ALL.CURRENTQCREATED']
    seq_qd = row_dict['M14.QUE.ALL.CURRENTQCOMPLETED']
    seq_gap = seq_qc - seq_qd
```
**설명:** queue_gap 계산

---

```python
    seq_trans = row_dict['M14.QUE.ALL.TRANSPORT4MINOVERCNT']
```
**설명:** Transport 시퀀스

---

#### 시간 정보 (336~343행)

```python
    current_time = df['CURRTIME'].iloc[i-1]
```
**설명:** 현재 시간
- iloc[i-1]: 시퀀스의 마지막 시점

---

```python
    actual = df['TOTALCNT'].iloc[i+9]
```
**설명:** 실제 10분 후 TOTALCNT (정답)
- iloc[i+9]: 현재(i-1)에서 10분 후

---

```python
    seq_start_time = df['CURRTIME'].iloc[i-280]
```
**설명:** 시퀀스 시작 시간
- 280분 전 시점

---

```python
    prediction_time = current_time + timedelta(minutes=10)
```
**설명:** 예측 시점 계산
- timedelta(minutes=10): 10분 더하기
- 예: 14:30 + 10분 = 14:40

---

```python
    actual_time = df['CURRTIME'].iloc[i+9]
```
**설명:** 실제 10분 후 시간

---

#### Feature 생성 및 예측 (345~352행)

```python
    features = create_features_13col_optimized(row_dict)
```
**설명:** 222개 Feature 생성

---

```python
    X = pd.DataFrame([features])
```
**설명:** Feature를 DataFrame으로 변환
- [features]: 리스트로 감싸기 (1행짜리 DataFrame)

---

```python
    pred_raw = model.predict(X)[0]
```
**설명:** 원본 예측
- model.predict(X): 예측 수행
- [0]: 첫 번째 값 (1개만 예측)

---

```python
    pred = adjust_light_plus(pred_raw, seq_m14b[-1], seq_m14b_sum[-1], seq_gap[-1], seq_trans[-1])
```
**설명:** boost 보정 적용
- 입력: 원본 예측, m14b 현재값, m14bsum 현재값, gap 현재값, trans 현재값
- 출력: 보정된 예측

---

#### 패턴 감지 (354~362행)

```python
    gold_strict = (seq_m14b[-1] > 520 and seq_m14b_sum[-1] > 588)
```
**설명:** 엄격한 황금 패턴 여부

---

```python
    gold_normal = (seq_m14b[-1] > 517 and seq_m14b_sum[-1] > 576)
```
**설명:** 보통 황금 패턴 여부

---

```python
    gold_loose = (seq_m14b[-1] > 509 and seq_m14b_sum[-1] > 570)
```
**설명:** 느슨한 황금 패턴 여부

---

```python
    must_condition = (seq_m14b[-1] > 497 and seq_m14b_sum[-1] > 566)
```
**설명:** 필수 조건 여부

---

```python
    danger_in_seq = np.sum(seq_totalcnt >= 1700) > 0
```
**설명:** 시퀀스 중 1700+ 발생 여부
- np.sum(seq_totalcnt >= 1700): 1700 이상인 횟수
- > 0: 한 번이라도 있었는지

---

#### 조기 경보 감지 (365~366행)

```python
    last_10min = seq_totalcnt[-10:]
```
**설명:** 최근 10분 데이터

---

```python
    early_warning = (np.max(last_10min) >= 1650) and ((last_10min[-1] - last_10min[0]) > 20)
```
**설명:** 조기 경보 조건
- np.max(last_10min) >= 1650: 최근 10분 중 1650+ 발생
- (last_10min[-1] - last_10min[0]) > 20: 10분간 20 이상 증가
- 의미: 1650+ 수준에서 급증 중 → 곧 1700 넘을 가능성!

---

#### 위험 신호 (369~370행)

```python
    danger_gap = seq_gap[-1] > 300
```
**설명:** queue_gap 위험 여부

---

```python
    danger_trans = seq_trans[-1] > 151
```
**설명:** transport 위험 여부

---

#### 복합 체크 (373~374행)

```python
    triple_check = (seq_m14b[-1] > 517 and seq_m14b_sum[-1] > 576 and seq_gap[-1] > 250)
```
**설명:** 3중 체크 (황금패턴 + gap)

---

```python
    quad_check = (seq_m14b[-1] > 517 and seq_m14b_sum[-1] > 576 and seq_gap[-1] > 250 and seq_trans[-1] > 145)
```
**설명:** 4중 체크 (황금패턴 + gap + transport)

---

#### 결과 저장 (377~428행)

```python
    results.append({
```
**설명:** 결과 딕셔너리를 results 리스트에 추가

---

```python
        '시퀀스시작': seq_start_time.strftime('%Y-%m-%d %H:%M'),
```
**설명:** 시퀀스 시작 시간
- strftime(): 날짜 포맷팅
- 예: '2025-10-14 10:00'

---

```python
        '현재시간': current_time.strftime('%Y-%m-%d %H:%M'),
```
**설명:** 현재 시간

---

```python
        '현재TOTALCNT': round(seq_totalcnt[-1], 2),
```
**설명:** 현재 TOTALCNT 값
- round(값, 2): 소수점 2자리

---

```python
        '예측시점': prediction_time.strftime('%Y-%m-%d %H:%M'),
```
**설명:** 예측 시점 (10분 후)

---

```python
        '실제시점': actual_time.strftime('%Y-%m-%d %H:%M'),
```
**설명:** 실제 10분 후 시점

---

```python
        '실제값': round(actual, 2),
```
**설명:** 실제 10분 후 TOTALCNT (정답)

---

```python
        '원본예측': round(pred_raw, 2),
```
**설명:** boost 적용 전 예측값

---

```python
        '보정예측': round(pred, 2),
```
**설명:** boost 적용 후 예측값

---

```python
        '오차': round(actual - pred, 2),
```
**설명:** 오차 (실제값 - 예측값)
- 양수: 과소 예측
- 음수: 과대 예측

---

```python
        '절대오차': round(abs(actual - pred), 2),
```
**설명:** 절대 오차
- abs(): 절대값

---

```python
        '오차율(%)': round(abs(actual - pred) / max(actual, 1) * 100, 2),
```
**설명:** 오차율
- (절대오차 / 실제값) × 100
- max(actual, 1): 0으로 나누기 방지

---

```python
        'M14AM14B': round(seq_m14b[-1], 2),
        'M14AM14BSUM': round(seq_m14b_sum[-1], 2),
        'M14BM14A': round(row_dict['M14BM14A'][-1], 2),
        'M14AM10A': round(row_dict['M14AM10A'][-1], 2),
        'M10AM14A': round(row_dict['M10AM14A'][-1], 2),
        'M16M14A': round(row_dict['M16M14A'][-1], 2),
        'M14AM16SUM': round(row_dict['M14AM16SUM'][-1], 2),
```
**설명:** 각 컬럼의 현재값 저장

---

```python
        'queue_gap': round(seq_gap[-1], 2),
        'TRANSPORT': round(seq_trans[-1], 2),
        'OHT_UTIL': round(row_dict['M14.QUE.OHT.OHTUTIL'][-1], 2),
```
**설명:** queue_gap, transport, OHT 현재값

---

```python
        '시퀀스TOTALCNT_MAX': round(np.max(seq_totalcnt), 2),
        '시퀀스TOTALCNT_MIN': round(np.min(seq_totalcnt), 2),
        '시퀀스TOTALCNT_평균': round(np.mean(seq_totalcnt), 2),
```
**설명:** 시퀀스 280분 동안의 TOTALCNT 통계

---

```python
        '마지막10분_MAX': round(np.max(last_10min), 2),
        '마지막10분_상승폭': round(last_10min[-1] - last_10min[0], 2),
```
**설명:** 최근 10분 통계

---

```python
        '필수조건': 'O' if must_condition else '',
        '황금패턴(엄격)': 'O' if gold_strict else '',
        '황금패턴(보통)': 'O' if gold_normal else '',
        '황금패턴(느슨)': 'O' if gold_loose else '',
```
**설명:** 패턴 감지 결과
- True이면 'O', False이면 빈칸

---

```python
        'Gap위험': 'O' if danger_gap else '',
        'Trans위험': 'O' if danger_trans else '',
        '3중체크': 'O' if triple_check else '',
        '4중체크': 'O' if quad_check else '',
```
**설명:** 위험 신호 결과

---

```python
        '시퀀스위험': 'O' if danger_in_seq else '',
        '조기경보': 'O' if early_warning else '',
```
**설명:** 시퀀스 위험 및 조기 경보

---

```python
        '실제위험(1700+)': 'O' if actual >= 1700 else '',
        '예측위험(1700+)': 'O' if pred >= 1700 else ''
```
**설명:** 실제 위험 및 예측 위험
- 실제값 >= 1700: 실제 위험
- 예측값 >= 1700: 예측 위험

---

```python
    })
```
**설명:** 딕셔너리 끝

---

#### 진행률 출력 및 메모리 정리

```python
    if (i - 280) % 1000 == 0:
        print(f"  {i-280:,}/{total:,}")
        gc.collect()
```
**설명:** 1000개마다 진행률 출력 및 메모리 정리
- gc.collect(): 가비지 컬렉션 (메모리 정리)

---

```python
print(f"✅ 완료!")
```
**설명:** 평가 루프 완료 메시지

---

### 결과 저장 (432~443행)

```python
df_result = pd.DataFrame(results)
```
**설명:** results 리스트를 DataFrame으로 변환

---

```python
output = 'evaluation_COMPLETE.csv'
```
**설명:** 출력 파일 이름

---

```python
df_result.to_csv(output, index=False, encoding='utf-8-sig')
```
**설명:** CSV 파일로 저장
- index=False: 인덱스 없이
- encoding='utf-8-sig': 한글 깨짐 방지 (BOM 추가)

---

```python
print(f"✅ 저장: {output}")
```
**설명:** 저장 완료 메시지

---

```python
del df
gc.collect()
```
**설명:** 메모리 정리
- del df: DataFrame 삭제
- gc.collect(): 메모리 회수

---

## 7. 통계 분석 (432~530행)

### 기본 통계

```python
print("\n" + "="*80)
print("📊 평가 통계 (280분 → 10분 후, 13개 컬럼 FINAL)")
print("="*80)
```
**설명:** 통계 출력 시작

---

```python
print(f"총 예측 수: {len(df_result):,}개")
```
**설명:** 전체 예측 개수

---

```python
print(f"평균 절대 오차(MAE): {df_result['절대오차'].mean():.2f}")
```
**설명:** MAE 계산 및 출력

---

```python
print(f"평균 오차율: {df_result['오차율(%)'].mean():.2f}%")
```
**설명:** 평균 오차율

---

```python
print(f"최대 절대 오차: {df_result['절대오차'].max():.2f}")
```
**설명:** 최대 오차

---

```python
print(f"최소 절대 오차: {df_result['절대오차'].min():.2f}")
```
**설명:** 최소 오차

---

### 패턴 발생 빈도

```python
print(f"\n필수 조건 발생: {df_result['필수조건'].value_counts().get('O', 0):,}개")
```
**설명:** 필수 조건 발생 횟수
- value_counts(): 값별 개수
- .get('O', 0): 'O'의 개수, 없으면 0

---

```python
print(f"황금 패턴(엄격) 발생: {df_result['황금패턴(엄격)'].value_counts().get('O', 0):,}개")
print(f"황금 패턴(보통) 발생: {df_result['황금패턴(보통)'].value_counts().get('O', 0):,}개")
print(f"황금 패턴(느슨) 발생: {df_result['황금패턴(느슨)'].value_counts().get('O', 0):,}개")
```
**설명:** 각 황금 패턴 발생 횟수

---

```python
print(f"Gap 위험 발생: {df_result['Gap위험'].value_counts().get('O', 0):,}개")
print(f"Transport 위험 발생: {df_result['Trans위험'].value_counts().get('O', 0):,}개")
```
**설명:** Gap, Transport 위험 발생 횟수

---

```python
print(f"3중 체크 발생: {df_result['3중체크'].value_counts().get('O', 0):,}개")
print(f"4중 체크 발생: {df_result['4중체크'].value_counts().get('O', 0):,}개")
```
**설명:** 복합 체크 발생 횟수

---

```python
print(f"시퀀스 위험 구간: {df_result['시퀀스위험'].value_counts().get('O', 0):,}개")
print(f"🔥 조기 경보 발생: {df_result['조기경보'].value_counts().get('O', 0):,}개")
```
**설명:** 시퀀스 위험 및 조기 경보 발생 횟수

---

### 위험 구간 분석

```python
actual_danger = df_result['실제위험(1700+)'] == 'O'
```
**설명:** 실제 1700+ 마스크
- True/False 배열

---

```python
pred_danger = df_result['예측위험(1700+)'] == 'O'
```
**설명:** 예측 1700+ 마스크

---

```python
early_warning = df_result['조기경보'] == 'O'
```
**설명:** 조기 경보 마스크

---

```python
actual_danger_count = actual_danger.sum()
pred_danger_count = pred_danger.sum()
danger_detected = (actual_danger & pred_danger).sum()
early_warning_count = early_warning.sum()
```
**설명:** 각 카운트 계산
- actual_danger_count: 실제 1700+ 개수
- pred_danger_count: 예측 1700+ 개수
- danger_detected: 실제도 1700+ AND 예측도 1700+ (감지 성공!)
- early_warning_count: 조기 경보 개수

---

```python
early_to_danger = (early_warning & actual_danger).sum()
```
**설명:** 조기 경보가 맞은 횟수
- 조기 경보 발생 AND 실제 1700+ 발생

---

```python
print(f"\n실제 위험(1700+): {actual_danger_count:,}개")
print(f"예측 위험(1700+): {pred_danger_count:,}개")
print(f"위험 감지 성공: {danger_detected:,}개")
```
**설명:** 위험 구간 통계 출력

---

```python
if actual_danger_count > 0:
    print(f"🎯 위험 감지율: {danger_detected/actual_danger_count*100:.1f}%")
```
**설명:** 위험 감지율 계산 및 출력
- 공식: (감지 성공 / 실제 1700+) × 100
- 중요 지표! 이게 높아야 함!

---

```python
if early_warning_count > 0:
    print(f"\n🔥 조기 경보 → 실제 1700+ 발생: {early_to_danger:,}개 ({early_to_danger/early_warning_count*100:.1f}%)")
```
**설명:** 조기 경보 정확도
- 조기 경보가 실제로 1700+로 이어진 비율

---

### 보정 효과 분석

```python
if actual_danger_count > 0:
    danger_rows = df_result[actual_danger]
```
**설명:** 1700+ 구간만 필터링

---

```python
    print(f"\n🔥 보정 효과 (1700+ 구간):")
    print(f"  원본 예측 평균: {danger_rows['원본예측'].mean():.1f}")
    print(f"  보정 예측 평균: {danger_rows['보정예측'].mean():.1f}")
    print(f"  실제값 평균: {danger_rows['실제값'].mean():.1f}")
```
**설명:** 1700+ 구간에서 원본/보정/실제 평균 비교

---

```python
    print(f"  평균 보정량: +{(danger_rows['보정예측'] - danger_rows['원본예측']).mean():.1f}")
```
**설명:** 평균적으로 얼마나 boost 했는지

---

```python
    raw_detected = ((actual_danger) & (df_result['원본예측'] >= 1700)).sum()
```
**설명:** 원본 예측으로 감지한 개수
- 원본 예측 >= 1700인 것만

---

```python
    print(f"\n  원본 감지율: {raw_detected/actual_danger_count*100:.1f}% ({raw_detected:,}/{actual_danger_count:,})")
    print(f"  보정 감지율: {danger_detected/actual_danger_count*100:.1f}% ({danger_detected:,}/{actual_danger_count:,})")
```
**설명:** 원본 vs 보정 감지율 비교

---

```python
    print(f"  개선: +{(danger_detected-raw_detected)/actual_danger_count*100:.1f}%p")
```
**설명:** boost로 인한 감지율 개선
- %p: 퍼센트 포인트 (percentage point)

---

### 오차 상위 10개

```python
print("\n" + "="*80)
print("오차 상위 10개 구간")
print("="*80)
```
**설명:** 오차 큰 케이스 분석 시작

---

```python
top_errors = df_result.nlargest(10, '절대오차')
```
**설명:** 절대오차 기준 상위 10개 추출
- nlargest(10, '절대오차'): 절대오차가 큰 순서로 10개

---

```python
print(top_errors[['현재시간', '현재TOTALCNT', '실제값', '보정예측', '절대오차', 'M14AM14B', 'M14AM14BSUM', 'queue_gap', '조기경보']].to_string(index=False))
```
**설명:** 주요 컬럼만 출력
- to_string(index=False): 인덱스 없이 문자열로

---

## 8. 검증 및 요약 (532~573행)

### 10칸 검증

```python
print("\n" + "="*80)
print("🔍 10칸 내려서 예측 검증 (샘플 10개)")
print("="*80)
print("Line 1의 예측값 vs Line 11의 현재TOTALCNT 비교")
print("-"*80)
```
**설명:** 검증 시작
- 1번째 줄의 예측값과 11번째 줄의 현재값 비교
- 10분 후 예측이 정확한지 확인

---

```python
for idx in [0, 1000, 5000, 10000, 15000, 20000, 25000, 30000, 35000, 40000]:
```
**설명:** 샘플 10개 위치

---

```python
    if idx + 10 < len(df_result):
```
**설명:** 범위 체크 (10칸 내려갈 수 있는지)

---

```python
        line1_time = df_result.iloc[idx]['현재시간']
        line1_pred = df_result.iloc[idx]['보정예측']
```
**설명:** 1번 라인 정보
- 현재 시간, 예측값

---

```python
        line11_time = df_result.iloc[idx+10]['현재시간']
        line11_current = df_result.iloc[idx+10]['현재TOTALCNT']
```
**설명:** 11번 라인 정보 (10칸 아래)
- 시간, 현재 TOTALCNT

---

```python
        diff = abs(line11_current - line1_pred)
```
**설명:** 차이 계산
- 예측값과 실제 현재값의 차이

---

```python
        print(f"Line {idx+1:5d} (예측): {line1_time} → 예측값: {line1_pred:7.2f}")
        print(f"Line {idx+11:5d} (실제): {line11_time} → 현재값: {line11_current:7.2f}")
        print(f"            차이: {diff:.2f}")
        print("-"*40)
```
**설명:** 비교 결과 출력

---

### 최종 요약

```python
print("\n" + "="*80)
print("✅ 최종 평가 요약")
print("="*80)
```
**설명:** 최종 요약 시작

---

```python
print(f"1. 전체 성능:")
print(f"   - MAE: {df_result['절대오차'].mean():.2f}")
```
**설명:** 전체 MAE

---

```python
if actual_danger_count > 0:
    print(f"   - 위험 감지율: {danger_detected/actual_danger_count*100:.1f}% ({danger_detected:,}/{actual_danger_count:,})")
```
**설명:** 위험 감지율

---

```python
print(f"\n2. 저장 파일:")
print(f"   - {output}")
```
**설명:** 저장된 파일 이름

---

```python
print("="*80)
```
**설명:** 마무리 구분선

---

## 🎯 전체 흐름 요약

```
1. 모델 로드
   (model_13col_final.pkl)
   ↓
2. 평가 데이터 로드
   (M14_Q_20251014_TO_20251015.CSV)
   ↓
3. 슬라이딩 윈도우 루프
   - 280분 시퀀스 추출
   - Feature 생성 (222개)
   - 원본 예측
   - boost 보정 (1650~1699만)
   - 패턴 감지
   - 결과 저장
   ↓
4. CSV 저장
   (evaluation_COMPLETE.csv)
   ↓
5. 통계 분석
   - 전체 성능 (MAE, 오차율)
   - 패턴 발생 빈도
   - 위험 감지율 ⭐ 핵심!
   - 보정 효과 분석
   - 오차 상위 10개
   ↓
6. 검증
   - 10칸 내려서 비교
   ↓
7. 최종 요약
```

---

## 💡 핵심 포인트

### 1. Feature 생성
- **학습과 100% 동일해야 함!**
- 222개 Feature
- 한 글자라도 다르면 예측 실패

### 2. Boost 보정
- **1650~1699 구간만!**
- 황금 패턴: +30~50
- queue_gap: +30~47
- transport: +40~43
- 복합: +37~45
- **다른 구간은 boost = 0**

### 3. 위험 감지율
- **가장 중요한 지표!**
- 공식: (감지 성공 / 실제 1700+) × 100
- 목표: 85% 이상
- boost로 30~40%p 개선

### 4. 조기 경보
- 1650+ 수준에서 급증 감지
- 실제 1700+ 도달 전에 경고
- 사전 대응 가능

---

## 📊 출력 CSV 구조

### 시간 정보
- 시퀀스시작
- 현재시간
- 예측시점
- 실제시점

### 값 정보
- 현재TOTALCNT
- 실제값 (10분 후)
- 원본예측
- 보정예측

### 오차 정보
- 오차
- 절대오차
- 오차율(%)

### 컬럼 현재값
- M14AM14B
- M14AM14BSUM
- queue_gap
- TRANSPORT
- ...

### 패턴 정보
- 필수조건 (O/빈칸)
- 황금패턴(엄격)
- 황금패턴(보통)
- 황금패턴(느슨)
- Gap위험
- Trans위험
- 3중체크
- 4중체크

### 위험 정보
- 시퀀스위험
- 조기경보
- 실제위험(1700+)
- 예측위험(1700+)

---

## 🔥 왜 이렇게 설계했나?

### Q1. 왜 1650~1699만 boost?
```
A: 학습 데이터 부족으로 이 구간만 낮게 예측됨
   실제 1710인데 1680으로 예측
   → 이 구간만 +30~50 boost
   → 다른 구간은 영향 없음!
```

### Q2. boost 값은 어떻게 정했나?
```
A: 실험을 통해 최적값 발견
   황금 패턴: 1700+ 확률 높음 → boost 크게
   queue_gap: 상관계수 4.2배 → boost 크게
   transport: 상관계수 1.29배 → boost 중간
```

### Q3. 조기 경보는 왜 필요?
```
A: 1700 넘기 전에 미리 경고
   1650+ 수준에서 급증 → 곧 1700 넘을 가능성
   → 사전 대응 시간 확보!
```

### Q4. 10칸 검증은 뭔가?
```
A: 예측의 정확성 확인
   1번 라인의 예측값 vs 11번 라인의 현재값
   → 10분 후 예측이 맞는지 검증
```

---

## 🎓 용어 정리

| 용어 | 설명 |
|------|------|
| 원본예측 | boost 적용 전 XGBoost 예측값 |
| 보정예측 | boost 적용 후 최종 예측값 |
| 감지율 | 1700+ 중 1700+로 예측한 비율 |
| 조기경보 | 1650+ 급증 시 사전 경고 |
| boost | 1650~1699 구간 예측값 보정 |
| 황금패턴 | M14B > 520 & M14BSUM > 588 |
| queue_gap | 생성 큐 - 완료 큐 |

---

## 🚀 실행 방법

```bash
# 1. 모델 파일 확인
ls -l model_13col_final.pkl

# 2. 평가 데이터 준비
# data/ 폴더에 CSV 파일 넣기

# 3. 평가 실행
python V8_2평가.PY

# 4. 결과 확인
# evaluation_COMPLETE.csv 생성됨
```

---

**📅 작성일:** 2024-11-06  
**✍️ 작성:** 존 포레스트  
**📧 문의:** 프로젝트 담당자

---