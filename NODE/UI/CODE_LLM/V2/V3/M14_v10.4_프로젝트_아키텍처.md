# V10_4 프로젝트 지침서

버전: V10_4 (XGBoost 회귀 + LightGBM 분류 + 투표 앙상블)
날짜: 2025-02

---

## 1. 핵심 목적

반도체 M14 Fab 물류량(TOTALCNT)을 **10분/30분 후** 예측하여 **1700+ 위험 사전 경고** 제공.
XGBoost 회귀 앙상블 + LightGBM 분류 앙상블 + 5개 규칙 투표 방식으로 최종 판정.

---

## 2. 기술 스택

| 항목 | 값 |
|------|-----|
| 회귀 모델 | XGBoost Regressor × 3~4그룹 |
| 분류 모델 | LightGBM Classifier × 3~4그룹 |
| 판정 방식 | 투표 + 5개 규칙 OR 조합 |
| 입력 시퀀스 | 280분 시계열 |
| 예측 범위 | 10분 / 30분 내 최대값 |
| Feature 수 | 컬럼당 20개 × 43컬럼 = ~860 (그룹별 분리) |
| 스케일링 | StandardScaler (그룹별 독립) |

---

## 3. 전체 아키텍처 (파이프라인)

```
[1] 학습 (V10_4학습10min.py / 30min.py)
    CSV 로드 → Feature 그룹 분리 → 시퀀스 Feature 생성
    → StandardScaler → XGB 회귀 + LGBM 분류 학습 → pkl 저장

[2] 평가 (V10_4평가10min.py / 30min.py)
    pkl 로드 → 평가CSV 로드 → 시퀀스 Feature 생성
    → 그룹별 예측 → 투표 + 5규칙 → 최종판정
    → 예측상태 분류 (TP/TN/FN/FP 세분화) → CSV 저장

[3] 대시보드 (트렌드그래프10min.py / 30min.py)
    평가 CSV 로드 → 통계 분석 → HTML 대시보드 생성
    (Chart.js 기반, 필터/모달/툴팁 인터랙션)
```

---

## 4. Feature 그룹 (4개)

### 4-1. target (1개 컬럼)
| 컬럼명 | 설명 |
|--------|------|
| `TOTALCNT` | M14 전체 물류 총량 (**예측 목표**) |

### 4-2. important (17개 컬럼)
| 컬럼명 | 설명 |
|--------|------|
| `M14.QUE.LOAD.CURRENTLOADQCNT` | 현재 로드 대기 큐 카운트 |
| `M14.QUE.LOAD.AVGLOADTIME` | 평균 로드 시간 |
| `M14.QUE.LOAD.AVGLOADTIME1MIN` | 1분 평균 로드 시간 |
| `M14.QUE.LOAD.AVGFOUPLOADTIME` | FOUP 평균 로드 시간 |
| `M14.QUE.LOAD.AVGRETICLELOADTIME` | 레티클 평균 로드 시간 |
| `M14.QUE.LOAD.CURRENTRETICLELOADQCNT` | 레티클 로드 대기 큐 카운트 |
| `M14.QUE.ALL.CURRENTQCOMPLETED` | 현재 완료된 큐 카운트 |
| `M14.QUE.ALL.CURRENTQCREATED` | 현재 생성된 큐 카운트 |
| `M14.QUE.ALL.TRANSPORT4MINOVERCNT` | 4분 초과 반송 건수 |
| `M14.QUE.ALL.TRANSPORT4MINOVERTIMEAVG` | 4분 초과 반송 평균 시간 |
| `M14.QUE.ALL.TRANSPORT4MINOVERRATIO` | 4분 초과 반송 비율 |
| `M16HUB.QUE.M16TOM14B.CURRENTQCREATED` | M16→M14B 생성 큐 |
| `M16HUB.QUE.M14BTOM16.CURRENTQCREATED` | M14B→M16 생성 큐 |
| `M16HUB.QUE.M14TOM16.CURRENTQCREATED` | M14→M16 생성 큐 |
| `M16HUB.QUE.M16TOM14.CURRENTQCREATED` | M16→M14 생성 큐 |
| `M16HUB.QUE.M14TOM16.MESCURRENTQCNT` | M14→M16 MES 현재 큐 |
| `M16HUB.QUE.M16TOM14.MESCURRENTQCNT` | M16→M14 MES 현재 큐 |

### 4-3. auxiliary (21개 컬럼 + 파생 1개)
| 컬럼명 | 설명 |
|--------|------|
| `M14AM10A` | M14A→M10A 물량 |
| `M10AM14A` | M10A→M14A 물량 |
| `M14AM10ASUM` | M14A↔M10A 합계 |
| `M14AM14B` | M14A→M14B 물량 |
| `M14BM14A` | M14B→M14A 물량 |
| `M14AM14BSUM` | M14A↔M14B 합계 |
| `M14AM16` | M14A→M16 물량 |
| `M16M14A` | M16→M14A 물량 |
| `M14AM16SUM` | M14A↔M16 합계 |
| `M14.QUE.SFAB.SENDQUEUETOTAL` | S-Fab 송신 큐 합계 |
| `M14.QUE.SFAB.RECEIVEQUEUETOTAL` | S-Fab 수신 큐 합계 |
| `M14.QUE.SFAB.RETURNQUEUETOTAL` | S-Fab 반환 큐 합계 |
| `M14.QUE.SFAB.COMPLETEQUEUETOTAL` | S-Fab 완료 큐 합계 |
| `M14.QUE.OHT.OHTUTIL` | OHT 사용률 |
| `M14.QUE.OHT.RTCOHTUTIL` | RTC OHT 사용률 |
| `M14.QUE.OHT.CURRENTOHTQCNT` | OHT 현재 큐 카운트 |
| `M14.QUE.OHT.CURRENTRETICLEOHTQCNT` | 레티클 OHT 큐 카운트 |
| `M14.QUE.CNV.NORTHCURRENTQCNT` | 컨베이어 북쪽 큐 카운트 |
| `M14.QUE.CNV.SOUTHCURRENTQCNT` | 컨베이어 남쪽 큐 카운트 |
| `M14.QUE.CNV.ALLTONORTHCNVCURRENTQCNT` | 전체→북쪽 컨베이어 큐 |
| `M14.QUE.CNV.ALLTOSOUTHCNVCURRENTQCNT` | 전체→남쪽 컨베이어 큐 |
| **`QUEUE_GAP`** (파생) | `CURRENTQCREATED - CURRENTQCOMPLETED` (대기 작업량) |

### 4-4. pdt_new (3개 컬럼)
| 컬럼명 | 설명 |
|--------|------|
| `M14.STRATE.N2.STORAGERATIO` | N2 스토리지 비율 |
| `M14.PDT.LAYOUT.M14A_M14ATOM14ACNV_CURRENTQCNT` | M14A→M14A CNV 현재 큐 |
| `M14.PDT.LAYOUT.HUBROOM_M14TOM16_CURRENTQCNT` | HubRoom M14→M16 현재 큐 |

---

## 5. Feature 엔지니어링 (컬럼당 20개)

280분 시퀀스에서 각 컬럼마다 아래 20개 통계 Feature 생성:

| # | Feature | 수식/설명 |
|---|---------|----------|
| 1 | mean | `np.mean(seq)` - 280분 평균 |
| 2 | std | `np.std(seq)` - 280분 표준편차 |
| 3 | min | `np.min(seq)` - 280분 최솟값 |
| 4 | max | `np.max(seq)` - 280분 최댓값 |
| 5 | current | `seq[-1]` - 현재값 |
| 6 | total_change | `seq[-1] - seq[0]` - 전체 변화량 |
| 7 | percentile_25 | `np.percentile(seq, 25)` |
| 8 | percentile_75 | `np.percentile(seq, 75)` |
| 9 | momentum | `mean(last10) - mean(first10)` - 모멘텀 |
| 10 | recent_max_30 | `max(last30)` - 최근 30분 최대 |
| 11 | delta_10 | `seq[-1] - seq[-10]` - 10분 변화 |
| 12 | delta_30 | `seq[-1] - seq[-30]` - 30분 변화 |
| 13 | delta_60 | `seq[-1] - seq[-60]` - 60분 변화 |
| 14 | velocity_10 | `(seq[-1] - seq[-10]) / 10` - 10분 속도 |
| 15 | velocity_30 | `(seq[-1] - seq[-30]) / 30` - 30분 속도 |
| 16 | range_10 | `max(last10) - min(last10)` - 10분 범위 |
| 17 | range_30 | `max(last30) - min(last30)` - 30분 범위 |
| 18 | distance_to_limit | `1700 - current` - 임계치까지 거리 |
| 19 | flag_1500 | `1 if current >= 1500 else 0` |
| 20 | flag_1600 | `1 if current >= 1600 else 0` |

---

## 6. 모델 구성

### 6-1. XGBoost 회귀 (3~4개)
**목적:** 연속값 예측 (10분/30분 내 TOTALCNT 최대값)

| 모델 | 입력 | 역할 |
|------|------|------|
| `xgb_target` | target 그룹 Feature | TOTALCNT 자체 패턴 학습 |
| `xgb_important` | important 그룹 Feature | 로드/큐/허브 패턴 학습 |
| `xgb_auxiliary` | auxiliary 그룹 Feature | 물류이동/OHT/CNV 패턴 학습 |
| `xgb_pdt_new` | pdt_new 그룹 Feature | 스토리지/레이아웃 패턴 (선택) |

### 6-2. LightGBM 분류 (3~4개)
**목적:** 이진 분류 (1700+ 여부)

| 모델 | 입력 | 역할 |
|------|------|------|
| `lgb_target` | target 그룹 Feature | TOTALCNT 기반 위험 분류 |
| `lgb_important` | important 그룹 Feature | 로드/큐 기반 위험 분류 |
| `lgb_auxiliary` | auxiliary 그룹 Feature | 물류 기반 위험 분류 |
| `lgb_pdt_new` | pdt_new 그룹 Feature | PDT 기반 위험 분류 (선택) |

### 6-3. 하이퍼파라미터

```python
# XGBoost
xgb_params = {
    'n_estimators': 200,
    'max_depth': 6,
    'learning_rate': 0.05,
    'random_state': 42,
    'n_jobs': -1
}

# LightGBM
lgb_params = {
    'n_estimators': 200,
    'max_depth': 6,
    'learning_rate': 0.05,
    'random_state': 42,
    'n_jobs': -1,
    'verbose': -1
}
```

---

## 7. 앙상블 모델 5개 규칙 (상세)

### 7-1. 투표 구성 (6~8표)

6개 모델(또는 PDT 포함 8개)이 각각 1700+ 위험 여부를 판정하고, 투표 합산.

```python
votes = [
    # --- XGB 회귀 3개: 예측값 >= 1700이면 위험 투표 ---
    1 if pred_xgb_target >= 1700 else 0,       # [1표] XGB 타겟 (TOTALCNT만으로 판단)
    1 if pred_xgb_important >= 1700 else 0,     # [2표] XGB 중요 (로드/큐/허브 패턴)
    1 if pred_xgb_auxiliary >= 1700 else 0,     # [3표] XGB 보조 (물류이동/OHT/CNV)
    
    # --- LGBM 분류 3개: 모델이 직접 0/1 출력 ---
    pred_lgb_target,                             # [4표] LGBM 타겟 분류 결과
    pred_lgb_important,                          # [5표] LGBM 중요 분류 결과
    pred_lgb_auxiliary,                          # [6표] LGBM 보조 분류 결과
]

# PDT 그룹 있으면 +2표 추가 (총 8표)
if pred_xgb_pdt is not None:
    votes.append(1 if pred_xgb_pdt >= 1700 else 0)  # [7표] XGB PDT
    votes.append(pred_lgb_pdt)                        # [8표] LGBM PDT

vote_sum = sum(votes)   # 0~6 (또는 0~8)
total_votes = len(votes) # 6 또는 8
```

**투표 특성:**
- XGB 회귀는 연속값 → 1700 기준으로 이진화하여 투표
- LGBM 분류는 직접 0/1 출력을 투표로 사용
- 각 그룹이 서로 다른 Feature를 보기 때문에 독립적 관점 확보

### 7-2. 최종 판정 5개 규칙 (OR 조합)

5개 규칙 중 **하나라도 True**이면 최종 위험 판정:

| 규칙 | 조건 | 설계 의도 | 감지 대상 |
|------|------|----------|----------|
| **Rule 1** | `vote_sum >= 3` | 다수결 원칙 - 과반수가 위험으로 판단 | 전반적 위험 |
| **Rule 2** | `prob_lgb_important >= 0.50 AND 현재값 >= 1450` | LGBM 확률이 높고 현재값도 경계 진입 | 확률 기반 조기 감지 |
| **Rule 3** | `pred_xgb_important >= 1680 AND 현재값 >= 1500` | XGB가 1700 근접 예측 + 현재 위험 근접 | 근접 예측 보완 |
| **Rule 4** | `현재값 >= 1600 AND vote_sum >= 2` | 이미 위험 근접 시 낮은 투표로도 경고 | 고위험 구간 민감 감지 |
| **Rule 5** | `pred_xgb_important >= 1700` | XGB 중요 모델의 단독 판정 신뢰 | 강한 신호 단독 감지 |

```python
rule1 = vote_sum >= 3
rule2 = (prob_lgb_important >= 0.50) and (current_total >= 1450)
rule3 = (pred_xgb_important >= 1680) and (current_total >= 1500)
rule4 = (current_total >= 1600) and (vote_sum >= 2)
rule5 = (pred_xgb_important >= 1700)

final_pred_danger = 1 if (rule1 or rule2 or rule3 or rule4 or rule5) else 0
```

### 7-3. 규칙 간 역할 분담

```
[Rule 5] XGB 중요 >= 1700 ─────────────────── 강한 신호 단독
[Rule 1] 투표 >= 3 ─────────────────────────── 다수결 합의
[Rule 3] XGB 중요 >= 1680 & 현재 >= 1500 ──── 근접 보완
[Rule 2] LGBM 확률 >= 0.50 & 현재 >= 1450 ── 확률 조기 감지
[Rule 4] 현재 >= 1600 & 투표 >= 2 ──────────── 고위험 민감 감지
         ↑ 안전(0)                              위험(1) ↑
```

- **Rule 5, 1:** 모델 예측이 충분히 강할 때 → 현재값 조건 없이 판정
- **Rule 3, 2:** 모델이 근접/확률 수준일 때 → 현재값 조건 병행
- **Rule 4:** 현재 상황이 이미 위험할 때 → 투표 기준 완화

---

## 8. 예측값 활용 황금 패턴

### 8-1. V8.3 황금 패턴 (참고: 이전 버전)

V8.3에서는 보정 로직에서 아래 패턴을 직접 사용:

```python
# V8.3 방식 - 1650~1699 구간에서 boost
if M14AM14B > 540 and M14AM14BSUM > 620:   # gold_strict
    boost += 50
if M14AM14B > 520 and M14AM14BSUM > 600:   # gold_normal
    boost += 40
if queue_gap > 350:
    boost += 40
```

### 8-2. V10_4 황금 패턴 활용 방식

V10_4에서는 boost를 **직접 적용하지 않고**, Feature 엔지니어링으로 모델이 자동 학습:

| V8.3 황금 패턴 | V10_4 Feature로 전환 | 학습 그룹 |
|---------------|---------------------|----------|
| `M14AM14B > 520` | current값 + flag_1500/1600 Feature | auxiliary |
| `M14AM14BSUM > 600` | current값 + delta/velocity Feature | auxiliary |
| `queue_gap > 250` | QUEUE_GAP의 20개 시계열 Feature | auxiliary |
| `TRANSPORT > 151` | TRANSPORT4MINOVERCNT의 20개 Feature | important |
| Triple Check 조합 | 모델이 Feature 상호작용 자동 학습 | XGB가 트리 분할로 포착 |

### 8-3. Triple Check 패턴 (V8.3 핵심 → V10_4 자동화)

```
Triple Check = M14AM14B > 520 & M14AM14BSUM > 600 & queue_gap > 250
```

| 항목 | V8.3 | V10_4 |
|------|------|-------|
| 적용 방식 | if문으로 직접 boost | XGB가 트리 분할로 자동 학습 |
| 패턴 발동 | 1650~1699 구간에서만 | 전 구간에서 Feature 반영 |
| 정확도 | 96.7% (11월 급상승 패턴) | 모델이 데이터로부터 최적 임계값 학습 |
| 한계 | 12월 점진상승에서 실패 | 다양한 패턴 대응 가능 |

### 8-4. 대시보드에서의 황금 패턴 시각화

대시보드에서는 XGB_타겟(MAX)과 XGB_보조(MIN)의 범위로 위험도를 표현:

```
XGB_타겟(MAX) = xgb_target 예측값  → 예측 상한 (가장 공격적 예측)
XGB_보조(MIN) = xgb_auxiliary 예측값 → 예측 하한 (가장 보수적 예측)
앙상블예측 = XGB 평균 → 중간값
```

- **MAX와 MIN이 모두 1700+:** 매우 강한 위험 신호 (황금 패턴 수준)
- **MAX만 1700+:** 일부 패턴 감지, 주의 필요
- **둘 다 1700 미만:** 안전 구간

---

## 9. 앙상블 회귀 예측값

```python
# PDT 없을 때
ensemble_pred = (xgb_target + xgb_important + xgb_auxiliary) / 3

# PDT 있을 때
ensemble_pred = (xgb_target + xgb_important + xgb_auxiliary + xgb_pdt) / 4
```

**각 모델의 예측 특성:**
| 모델 | 역할 | 예측 경향 |
|------|------|----------|
| `xgb_target` | TOTALCNT 자체 패턴 | 가장 공격적 (MAX 역할) |
| `xgb_important` | 로드/큐/허브 패턴 | 중간 (판정 규칙의 핵심) |
| `xgb_auxiliary` | 물류이동/OHT/CNV | 가장 보수적 (MIN 역할) |
| `xgb_pdt_new` | 스토리지/레이아웃 | 보조 관점 |

---

## 10. 예측 타겟 정의

| 항목 | 10분 예측 | 30분 예측 |
|------|----------|----------|
| 회귀 타겟 | `df[TOTALCNT].iloc[idx:idx+10].max()` | `df[TOTALCNT].iloc[idx:idx+30].max()` |
| 분류 타겟 | 위 값 >= 1700 → 1, 아니면 0 | 동일 |
| 의미 | 향후 10분 내 최고점 | 향후 30분 내 최고점 |

---

## 11. 모델 성능 지표 산출 로직

### 11-1. 혼동 행렬 (기본 4분류)

```python
actual_danger = df_result['실제위험(1700+)'] == 1    # 실제 돌파 여부
pred_danger   = df_result['최종판정'] == 1            # 모델 위험 판정

TP = (actual_danger & pred_danger).sum()       # 실제 위험 & 예측 위험
TN = (~actual_danger & ~pred_danger).sum()     # 실제 안전 & 예측 안전
FP = (~actual_danger & pred_danger).sum()      # 실제 안전 & 예측 위험 (오탐)
FN = (actual_danger & ~pred_danger).sum()      # 실제 위험 & 예측 안전 (놓침)
```

### 11-2. 핵심 성능 지표

| 지표 | 산출식 | 의미 |
|------|--------|------|
| **Recall (감지율)** | `TP / (TP + FN) × 100` | 실제 위험 중 몇 %를 감지했는가 |
| **Precision (정밀도)** | `TP / (TP + FP) × 100` | 위험 예측 중 몇 %가 실제 위험인가 |
| **Accuracy (정확도)** | `(TP + TN) / (TP + TN + FP + FN) × 100` | 전체 예측의 정확도 |

```python
recall    = TP / actual_danger.sum() * 100       # 목표: 85%+
precision = TP / pred_danger.sum() * 100          # FP 최소화
accuracy  = (TP + TN) / (TP + TN + FP + FN) * 100
```

### 11-3. 예측상태 6분류 (10분 전후 세분화)

기본 4분류(TP/TN/FP/FN)를 **시간 맥락**으로 세분화하여 실질적 성능 판별:

```python
def get_prediction_status(row, all_df):
    actual = row['실제위험(1700+)']
    pred   = row['최종판정']
    current_time = row['현재시간_dt']
    
    # Case 1: 정확한 예측
    if actual == 1 and pred == 1:
        return '정상예측_TP'
    elif actual == 0 and pred == 0:
        return '정상예측_TN'
    
    # Case 2: 놓침(FN) → 10분 전에는 잡았는지 확인
    elif actual == 1 and pred == 0:
        time_10min_ago = current_time - timedelta(minutes=10)
        prev_data = all_df[all_df['현재시간_dt'] == time_10min_ago]
        if len(prev_data) > 0 and prev_data['최종판정'].values[0] == 1:
            return 'FN_10분전예측'    # 10분 전에 이미 잡음 → 실질적 OK
        else:
            return 'FN_완전놓침'      # 10분 전에도 못 잡음 → 실질적 문제!
    
    # Case 3: 오탐(FP) → 10분 후에 실제 돌파하는지 확인
    else:  # actual == 0 and pred == 1
        time_10min_later = current_time + timedelta(minutes=10)
        later_data = all_df[all_df['현재시간_dt'] == time_10min_later]
        if len(later_data) > 0 and later_data['실제위험(1700+)'].values[0] == 1:
            return 'FP_10분후돌파'    # 10분 후 실제 돌파 → 유효한 조기 경고
        else:
            return 'FP_잘못된경고'    # 10분 후에도 안전 → 실질적 오탐!
```

### 11-4. 예측상태 분류표

| 상태 | 실제 | 예측 | 시간 맥락 | 실질 평가 |
|------|------|------|----------|----------|
| `정상예측_TP` | 위험 | 위험 | - | ✅ 정확 |
| `정상예측_TN` | 안전 | 안전 | - | ✅ 정확 |
| `FN_10분전예측` | 위험 | 안전 | 10분 전 시점에서 이미 위험 예측함 | ⚠️ 허용 (조기 감지됨) |
| `FN_완전놓침` | 위험 | 안전 | 10분 전에도 안전으로 판정 | ❌ **실질적 놓침** |
| `FP_10분후돌파` | 안전 | 위험 | 10분 후 실제로 1700+ 돌파 | ⚠️ 허용 (유효 조기 경고) |
| `FP_잘못된경고` | 안전 | 위험 | 10분 후에도 안전 유지 | ❌ **실질적 오탐** |

### 11-5. 실질적 성능 지표

```python
status_counts = df_result['예측상태'].value_counts()

# 실질적으로 문제가 되는 건수만 추출
real_fn = status_counts.get('FN_완전놓침', 0)      # 완전히 놓친 위험
real_fp = status_counts.get('FP_잘못된경고', 0)    # 완전히 잘못된 경고
```

**실질적 관점에서의 재해석:**
- `FN_10분전예측`은 FN이지만 실질적으로는 **10분 전에 이미 감지** → 허용 가능
- `FP_10분후돌파`는 FP이지만 실질적으로는 **유효한 조기 경고** → 허용 가능
- **진짜 문제:** `FN_완전놓침` (위험 미감지) + `FP_잘못된경고` (헛경고)

### 11-6. 대시보드에서의 성능 산출 (트렌드그래프)

대시보드 코드에서는 예측상태 기반으로 Recall/Precision을 산출:

```python
total_positive = TP + FN_10min + FN_miss        # 실제 위험 전체
recall    = TP / total_positive * 100            # TP만 정상 감지로 인정
precision = TP / (TP + FP_10min + FP_false) * 100  # TP 대비 전체 위험 예측
```

**주의:** 대시보드의 Recall/Precision은 예측상태 기반이므로 평가 코드의 기본 혼동행렬과 약간 다를 수 있음 (FN_10분전예측을 FN에 포함하므로 Recall이 더 보수적)

---

## 12. 파일 구조

### 학습 파일
| 파일명 | 출력 모델 | 예측 범위 |
|--------|----------|----------|
| `V10_4학습10min.py` | `models/v10_4_m14_model.pkl` | 10분 |
| `V10_4학습30min.py` | `models/v10_4_30min_m14_model.pkl` | 30분 |

### 평가 파일
| 파일명 | 입력 모델 | 출력 CSV |
|--------|----------|---------|
| `V10_4평가10min.py` | `v10_4_m14_model.pkl` | `V10_4_평가결과_YYYYMMDD_HHMMSS.csv` |
| `V10_4평가30min.py` | `v10_4_30min_m14_model.pkl` | `V10_4_30min_평가결과_YYYYMMDD_HHMMSS.csv` |

### 대시보드 파일
| 파일명 | 입력 | 출력 HTML |
|--------|------|----------|
| `트렌드그래프10min.py` | 평가 CSV | `V10_4_10min_dashboard_*.html` |
| `트렌드그래프30min.py` | 평가 CSV | `V10_4_30min_dashboard_*.html` |

### 데이터 파일
| 패턴 | 용도 |
|------|------|
| `M14_학습*.CSV` | 학습 데이터 (glob 패턴) |
| `M14_평가.CSV` | 평가 데이터 |

---

## 13. 평가 CSV 출력 컬럼

| 컬럼명 | 타입 | 설명 |
|--------|------|------|
| `현재시간` | str | 예측 수행 시점 (YYYY-MM-DD HH:MM) |
| `현재TOTALCNT` | float | 예측 시점의 TOTALCNT |
| `예측시점` | str | 10분/30분 후 시점 |
| `실제값10min` | float | 10분/30분 내 TOTALCNT 최대값 |
| `실제단일값` | float | 정확히 N분 후 TOTALCNT (단일 시점) |
| `XGB_타겟` | float | xgb_target 예측값 |
| `XGB_중요` | float | xgb_important 예측값 |
| `XGB_보조` | float | xgb_auxiliary 예측값 |
| `XGB_PDT` | float | xgb_pdt_new 예측값 (없으면 빈칸) |
| `LGBM_중요_확률` | float | lgb_important 위험 확률 (0~1) |
| `앙상블예측` | float | XGB 회귀 평균값 |
| `투표(N개중)` | int | 총 투표 합계 |
| `최종판정` | int | 0=안전, 1=위험 |
| `실제위험(1700+)` | int | 0=안전, 1=실제 돌파 |
| `예측상태` | str | TP/TN/FN/FP 세분화 결과 |

---

## 14. 대시보드 구성 (HTML)

### 10분 대시보드
- **X축 기준:** 현재시간
- **Y축 데이터:** 현재 TOTALCNT, 실제 최대값(10분), XGB_타겟(MAX), XGB_보조(MIN)
- **범례:** 현재값=청색, 실제MAX=녹색, XGB타겟=적색, XGB보조=주황 점선

### 30분 대시보드
- **X축 기준:** 예측시점
- **Y축 데이터:** 실제단일값, 실제 최대값(30분), XGB_타겟(MAX), XGB_보조(MIN)
- **범례:** 실제단일값=청색, 실제MAX=녹색, XGB타겟=적색, XGB보조=주황 점선

### 공통 인터랙션
- 차트 범위 조정 (시작/개수)
- 알람 구간 점프 (XGB_타겟 >= 1700)
- 필터 탭 (전체/TP/TN/FN/FP/돌파/MAX 1700+)
- 이벤트 클릭 → 툴팁 상세
- 이벤트 더블클릭 → ±30분 모달 차트
- ESC 키로 닫기

---

## 15. PKL 모델 저장 구조

```python
model_data = {
    'models': {
        'xgb_target': XGBRegressor,
        'xgb_important': XGBRegressor,
        'xgb_auxiliary': XGBRegressor,
        'xgb_pdt_new': XGBRegressor,        # 선택
        'lgb_target': LGBMClassifier,
        'lgb_important': LGBMClassifier,
        'lgb_auxiliary': LGBMClassifier,
        'lgb_pdt_new': LGBMClassifier,      # 선택
    },
    'scalers': {
        'target': StandardScaler,
        'important': StandardScaler,
        'auxiliary': StandardScaler,
        'pdt_new': StandardScaler,           # 선택
    },
    'config': {
        'train_file': str,
        'model_file': str,
        'sequence_length': 280,
        'prediction_offset': 10 or 30,
        'limit_value': 1700,
        'target_column': 'TOTALCNT',
    },
    'feature_groups': {
        'target': [str, ...],
        'important': [str, ...],
        'auxiliary': [str, ...],
        'pdt_new': [str, ...],
    },
    'training_info': {
        'version': 'V10_4',
        'train_date': str,
        'samples': int,
        'danger_samples': int,
    }
}
```

---

## 16. 핵심 파생 변수

```python
QUEUE_GAP = CURRENTQCREATED - CURRENTQCOMPLETED
```

- **의미:** 현재 대기 중인 작업량 (생성된 큐 - 완료된 큐)
- **상관관계:** 0.4+ (합법적 강한 예측 변수)
- **위치:** auxiliary 그룹에 자동 추가

---

## 17. 확장 규칙 (미래 적용 후보)

`추가하게되면_이걸_추가` 파일에 정의된 확장 규칙:

| 규칙 | 조건 | 비고 |
|------|------|------|
| rule6 | `xgb_auxiliary >= 1720 AND 현재값 >= 1550` | 보조 모델 활용 |
| rule9 | `현재값 >= 1600 AND vote_sum >= 2` | 현 rule4와 동일 |
| rule10 | `현재값 >= 1650 AND xgb_target >= 1650` | 고위험 근접 판정 |

---

## 18. V8.3 → V10_4 주요 변경사항

| 항목 | V8.3 | V10_4 |
|------|------|-------|
| 모델 | XGBoost 1개 | XGB 3~4 + LGBM 3~4 |
| 컬럼 수 | 8개 | 43개 (4그룹) |
| Feature 수 | 82개 | ~860개 (그룹별 분리) |
| 판정 방식 | 보정 + 추세 | 투표 + 5규칙 OR |
| 보정 로직 | 하한선 -80, 황금패턴 boost | 제거 (모델이 학습) |
| 추세예측 | 12분 변화량 + 보정 | 제거 (시퀀스 Feature로 대체) |
| 증강 | multiplier=50 | 미사용 |
| 예측 범위 | 10분만 | 10분 + 30분 |
| 평가 세분화 | 없음 | FN/FP 10분전후 분석 |
| 대시보드 | 없음 | HTML 인터랙티브 |

---

## 19. 성능 지표 (참고)

| 지표 | 10분 예측 | 30분 예측 |
|------|----------|----------|
| Recall | 86.5% | 96.9% |
| 실질 FN (완전놓침) | 최소화 목표 | 최소화 목표 |
| 실질 FP (잘못된경고) | 허용 범위 내 | 허용 범위 내 |

---

## 20. 용어 정리

| 용어 | 설명 |
|------|------|
| TOTALCNT | M14 Fab 전체 물류 큐 총량 (예측 목표) |
| QUEUE_GAP | 대기 작업량 (생성큐 - 완료큐) |
| 투표(vote_sum) | 6~8개 모델의 위험 판정 합계 |
| 앙상블예측 | XGB 회귀 모델 평균값 |
| XGB_타겟(MAX) | 대시보드에서 예측 상한 역할 |
| XGB_보조(MIN) | 대시보드에서 예측 하한 역할 |
| 예측상태 | TP/TN/FN/FP를 10분 전후로 세분화한 분류 |
| limit_value | 1700 (위험 임계값) |
| sequence_length | 280 (입력 시계열 길이, 분) |
| prediction_offset | 10 또는 30 (예측 시간 범위, 분) |

---

## 21. 코드 수정 시 주의사항

1. **Feature 생성 함수 동기화:** 학습/평가의 `create_sequence_features()` 함수가 반드시 동일해야 함 (현재 20개 Feature/컬럼)
2. **QUEUE_GAP 순서:** 반드시 Feature 그룹 필터링 전에 파생 변수를 먼저 생성
3. **스케일러 일치:** 평가 시 학습에서 저장한 StandardScaler를 그대로 사용 (그룹별 독립)
4. **투표 규칙 변경:** rule 추가/변경 시 학습 재학습 불필요 (후처리 로직)
5. **대시보드 컬럼명:** 평가 CSV의 컬럼명이 대시보드 코드의 `row.get()` 키와 일치해야 함
6. **인코딩:** CSV 저장은 `utf-8-sig`, 로드는 `utf-8` → `cp949` → `euc-kr` 순 시도

---

작성일: 2025-02-06
버전: V10_4 (XGBoost 회귀 + LightGBM 분류 + 투표 앙상블)