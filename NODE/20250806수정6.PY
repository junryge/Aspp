"""
ë°˜ë„ì²´ FAB ë¬¼ë¥˜ ì˜ˆì¸¡ì„ ìœ„í•œ í†µí•© í•˜ì´ë¸Œë¦¬ë“œ ë”¥ëŸ¬ë‹ ì‹œìŠ¤í…œ
================================================================
LSTM, RNN, GRU, ARIMA ëª¨ë¸ì„ í†µí•©í•œ í•˜ì´ë¸Œë¦¬ë“œ ì˜ˆì¸¡ ì‹œìŠ¤í…œìœ¼ë¡œ
ë°˜ë„ì²´ íŒ¹ ê°„ ë¬¼ë¥˜ ì´ë™ëŸ‰ê³¼ ë³‘ëª© êµ¬ê°„ì„ ì˜ˆì¸¡í•©ë‹ˆë‹¤.

ì£¼ìš” ê¸°ëŠ¥:
1. ë…¸ë“œ ê¸°ë°˜ íŒŒì´í”„ë¼ì¸ êµ¬ì„±
2. ì‹¤ì‹œê°„ ëª¨ë¸ í•™ìŠµ (ì¬ì‹œì‘ ê°€ëŠ¥)
3. ì•™ìƒë¸” ì˜ˆì¸¡ ë° ë³‘ëª© êµ¬ê°„ ê°ì§€
4. í¼ì„¼íŠ¸ ê¸°ë°˜ ì„±ëŠ¥ í‰ê°€
5. CPU ê¸°ë°˜ ì‹¤í–‰

ë²„ì „: 3.0 (í†µí•© ë²„ì „)
"""

import sys
import json
import os
import pickle
import traceback
import warnings
from typing import Dict, List, Optional, Tuple
from dataclasses import dataclass
from enum import Enum
from datetime import datetime, timedelta

import numpy as np
import pandas as pd
import tensorflow as tf
from sklearn.preprocessing import StandardScaler, MinMaxScaler, RobustScaler
from sklearn.metrics import mean_squared_error, mean_absolute_error, r2_score
from tensorflow.keras.models import Sequential, load_model, Model
from tensorflow.keras.layers import Input, LSTM, Dense, Dropout, BatchNormalization, Bidirectional, GRU, SimpleRNN
from tensorflow.keras.callbacks import EarlyStopping, ReduceLROnPlateau, ModelCheckpoint
from tensorflow.keras.optimizers import Adam
import joblib
import matplotlib.pyplot as plt
from matplotlib.backends.backend_qt5agg import FigureCanvasQTAgg as FigureCanvas
from matplotlib.figure import Figure
import seaborn as sns

from PyQt5.QtWidgets import *
from PyQt5.QtCore import *
from PyQt5.QtGui import *

# ê²½ê³  ë©”ì‹œì§€ ìˆ¨ê¸°ê¸°
warnings.filterwarnings('ignore')

# CPU ëª¨ë“œ ì„¤ì •
os.environ['CUDA_VISIBLE_DEVICES'] = '-1'
tf.config.set_visible_devices([], 'GPU')

# ëœë¤ ì‹œë“œ ê³ ì •
RANDOM_SEED = 2079936
tf.random.set_seed(RANDOM_SEED)
np.random.seed(RANDOM_SEED)


class NodeType(Enum):
    """ë…¸ë“œ íƒ€ì… ì •ì˜"""
    DATA_LOAD = "data_load"
    PREPROCESS = "preprocess"
    TRAIN = "train"
    PREDICT = "predict"
    EVALUATE = "evaluate"
    VISUALIZE = "visualize"


@dataclass
class NodeConfig:
    """ë…¸ë“œ ì„¤ì • ë°ì´í„° í´ë˜ìŠ¤"""
    node_type: NodeType
    name: str
    color: str
    inputs: int = 1
    outputs: int = 1


# ë…¸ë“œ íƒ€ì…ë³„ ì„¤ì •
NODE_CONFIGS = {
    NodeType.DATA_LOAD: NodeConfig(NodeType.DATA_LOAD, "ë°ì´í„° ë¡œë“œ", "#3498db", 0, 1),
    NodeType.PREPROCESS: NodeConfig(NodeType.PREPROCESS, "ì „ì²˜ë¦¬", "#e74c3c", 1, 1),
    NodeType.TRAIN: NodeConfig(NodeType.TRAIN, "í•™ìŠµ", "#27ae60", 1, 1),
    NodeType.PREDICT: NodeConfig(NodeType.PREDICT, "ì˜ˆì¸¡", "#f39c12", 1, 1),
    NodeType.EVALUATE: NodeConfig(NodeType.EVALUATE, "í‰ê°€", "#9b59b6", 1, 1),
    NodeType.VISUALIZE: NodeConfig(NodeType.VISUALIZE, "ì‹œê°í™”", "#1abc9c", 1, 0),
}


class CheckpointManager:
    """í•™ìŠµ ìƒíƒœë¥¼ ì €ì¥í•˜ê³  ë³µì›í•˜ëŠ” í´ë˜ìŠ¤"""
    
    def __init__(self, checkpoint_dir='checkpoints'):
        self.checkpoint_dir = checkpoint_dir
        os.makedirs(checkpoint_dir, exist_ok=True)
        self.state_file = os.path.join(checkpoint_dir, 'training_state.json')
        self.data_file = os.path.join(checkpoint_dir, 'preprocessed_data.pkl')
        
    def save_state(self, state_dict):
        """í˜„ì¬ í•™ìŠµ ìƒíƒœ ì €ì¥"""
        with open(self.state_file, 'w') as f:
            json.dump(state_dict, f, indent=4, default=str)
        
    def load_state(self):
        """ì €ì¥ëœ í•™ìŠµ ìƒíƒœ ë¡œë“œ"""
        if os.path.exists(self.state_file):
            with open(self.state_file, 'r') as f:
                return json.load(f)
        return None
        
    def save_data(self, data_dict):
        """ì „ì²˜ë¦¬ëœ ë°ì´í„° ì €ì¥"""
        with open(self.data_file, 'wb') as f:
            pickle.dump(data_dict, f)
        
    def load_data(self):
        """ì €ì¥ëœ ë°ì´í„° ë¡œë“œ"""
        if os.path.exists(self.data_file):
            with open(self.data_file, 'rb') as f:
                return pickle.load(f)
        return None
        
    def save_model_weights(self, model, model_name, epoch):
        """ëª¨ë¸ ê°€ì¤‘ì¹˜ ì €ì¥"""
        weights_path = os.path.join(self.checkpoint_dir, f'{model_name}_weights_epoch_{epoch}.h5')
        model.save_weights(weights_path)
        return weights_path
        
    def load_model_weights(self, model, weights_path):
        """ëª¨ë¸ ê°€ì¤‘ì¹˜ ë¡œë“œ"""
        if os.path.exists(weights_path):
            model.load_weights(weights_path)
            return True
        return False


class HybridModels:
    """LSTM, RNN, GRU ëª¨ë¸ì„ í¬í•¨í•œ í•˜ì´ë¸Œë¦¬ë“œ ì˜ˆì¸¡ ì‹œìŠ¤í…œ"""
    
    def __init__(self, input_shape):
        self.input_shape = input_shape
        self.models = {}
        self.histories = {}
        
    def build_lstm_model(self):
        """LSTM ëª¨ë¸ êµ¬ì¶•"""
        model = Sequential([
            Input(shape=self.input_shape),
            LSTM(units=100, return_sequences=True),
            Dropout(0.2),
            BatchNormalization(),
            LSTM(units=100, return_sequences=True),
            Dropout(0.2),
            BatchNormalization(),
            LSTM(units=100, return_sequences=False),
            Dropout(0.2),
            Dense(units=50, activation='relu'),
            Dense(units=1)
        ])
        return model
    
    def build_gru_model(self):
        """GRU ëª¨ë¸ êµ¬ì¶•"""
        model = Sequential([
            Input(shape=self.input_shape),
            GRU(units=100, return_sequences=True),
            Dropout(0.2),
            GRU(units=100, return_sequences=True),
            Dropout(0.2),
            GRU(units=50, return_sequences=False),
            Dropout(0.2),
            Dense(units=30, activation='relu'),
            Dense(units=1)
        ])
        return model
    
    def build_simple_rnn_model(self):
        """Simple RNN ëª¨ë¸ êµ¬ì¶•"""
        model = Sequential([
            Input(shape=self.input_shape),
            SimpleRNN(units=100, return_sequences=True),
            Dropout(0.2),
            SimpleRNN(units=50, return_sequences=False),
            Dropout(0.2),
            Dense(units=30, activation='relu'),
            Dense(units=1)
        ])
        return model
    
    def build_bidirectional_lstm_model(self):
        """ì–‘ë°©í–¥ LSTM ëª¨ë¸ êµ¬ì¶•"""
        model = Sequential([
            Input(shape=self.input_shape),
            Bidirectional(LSTM(units=50, return_sequences=True)),
            Dropout(0.2),
            Bidirectional(LSTM(units=50, return_sequences=False)),
            Dropout(0.2),
            Dense(units=30, activation='relu'),
            Dense(units=1)
        ])
        return model


class ModelPercentEvaluator:
    """ëª¨ë¸ ì„±ëŠ¥ì„ í¼ì„¼íŠ¸ë¡œ í‰ê°€í•˜ëŠ” í´ë˜ìŠ¤"""
    
    def __init__(self):
        self.models = {}
        self.scaler = None
        self.config = None
        
    def calculate_mape(self, y_true, y_pred):
        """MAPE (Mean Absolute Percentage Error) ê³„ì‚°"""
        mask = y_true != 0
        if not np.any(mask):
            return 0
        mape = np.mean(np.abs((y_true[mask] - y_pred[mask]) / y_true[mask])) * 100
        return mape
    
    def calculate_accuracy_within_threshold(self, y_true, y_pred, threshold_percent=10):
        """íŠ¹ì • ì˜¤ì°¨ ë²”ìœ„ ë‚´ ì˜ˆì¸¡ ì •í™•ë„ ê³„ì‚°"""
        threshold = np.mean(y_true) * (threshold_percent / 100)
        within_threshold = np.abs(y_true - y_pred) <= threshold
        accuracy = np.mean(within_threshold) * 100
        return accuracy
    
    def calculate_directional_accuracy(self, y_true, y_pred):
        """ë°©í–¥ì„± ì •í™•ë„ (ì¦ê°€/ê°ì†Œ ì˜ˆì¸¡ ì •í™•ë„)"""
        true_direction = np.diff(y_true) > 0
        pred_direction = np.diff(y_pred) > 0
        directional_accuracy = np.mean(true_direction == pred_direction) * 100
        return directional_accuracy
    
    def calculate_bottleneck_accuracy(self, y_true, y_pred, threshold):
        """ë³‘ëª© êµ¬ê°„ ì˜ˆì¸¡ ì •í™•ë„"""
        true_bottleneck = y_true > threshold
        pred_bottleneck = y_pred > threshold
        
        tp = np.sum((true_bottleneck == True) & (pred_bottleneck == True))
        tn = np.sum((true_bottleneck == False) & (pred_bottleneck == False))
        fp = np.sum((true_bottleneck == False) & (pred_bottleneck == True))
        fn = np.sum((true_bottleneck == True) & (pred_bottleneck == False))
        
        accuracy = (tp + tn) / (tp + tn + fp + fn) * 100 if (tp + tn + fp + fn) > 0 else 0
        precision = tp / (tp + fp) * 100 if (tp + fp) > 0 else 0
        recall = tp / (tp + fn) * 100 if (tp + fn) > 0 else 0
        f1 = 2 * (precision * recall) / (precision + recall) if (precision + recall) > 0 else 0
        
        return {
            'accuracy': accuracy,
            'precision': precision,
            'recall': recall,
            'f1_score': f1
        }


class TrainingThread(QThread):
    """í•™ìŠµì„ ë³„ë„ ìŠ¤ë ˆë“œì—ì„œ ì‹¤í–‰"""
    progress_update = pyqtSignal(str)
    training_complete = pyqtSignal(dict)
    error_occurred = pyqtSignal(str)
    
    def __init__(self, data, config):
        super().__init__()
        self.data = data
        self.config = config
        self.checkpoint_manager = CheckpointManager()
        self.is_running = True
        
    def run(self):
        """í•™ìŠµ ì‹¤í–‰"""
        try:
            self.progress_update.emit("í•™ìŠµ ì‹œì‘...")
            
            # ë°ì´í„° ì¤€ë¹„
            X_train = self.data['X_train']
            y_train = self.data['y_train']
            X_val = self.data['X_val']
            y_val = self.data['y_val']
            input_shape = (X_train.shape[1], X_train.shape[2])
            
            # í•˜ì´ë¸Œë¦¬ë“œ ëª¨ë¸ ì´ˆê¸°í™”
            hybrid_models = HybridModels(input_shape)
            
            # ëª¨ë¸ ë¦¬ìŠ¤íŠ¸
            model_configs = [
                ('lstm', hybrid_models.build_lstm_model),
                ('gru', hybrid_models.build_gru_model),
                ('rnn', hybrid_models.build_simple_rnn_model),
                ('bi_lstm', hybrid_models.build_bidirectional_lstm_model)
            ]
            
            results = {}
            
            # ê° ëª¨ë¸ í•™ìŠµ
            for model_name, build_func in model_configs:
                if not self.is_running:
                    break
                    
                self.progress_update.emit(f"{model_name.upper()} ëª¨ë¸ í•™ìŠµ ì¤‘...")
                
                # ëª¨ë¸ ë¹Œë“œ
                model = build_func()
                
                # ì»´íŒŒì¼
                optimizer = Adam(learning_rate=self.config.get('learning_rate', 0.0005))
                model.compile(optimizer=optimizer, loss='mse', metrics=['mae'])
                
                # ì½œë°±
                early_stop = EarlyStopping(monitor='val_loss', patience=20, restore_best_weights=True)
                reduce_lr = ReduceLROnPlateau(monitor='val_loss', factor=0.5, patience=5, verbose=0)
                
                # í•™ìŠµ
                history = model.fit(
                    X_train, y_train,
                    validation_data=(X_val, y_val),
                    epochs=self.config.get('epochs', 50),
                    batch_size=self.config.get('batch_size', 64),
                    callbacks=[early_stop, reduce_lr],
                    verbose=0
                )
                
                # ëª¨ë¸ ì €ì¥
                model_path = f'model/{model_name}_hybrid.keras'
                os.makedirs('model', exist_ok=True)
                model.save(model_path)
                
                results[model_name] = {
                    'model_path': model_path,
                    'history': history.history,
                    'final_loss': history.history['loss'][-1],
                    'final_val_loss': history.history['val_loss'][-1]
                }
                
                self.progress_update.emit(f"{model_name.upper()} ëª¨ë¸ í•™ìŠµ ì™„ë£Œ")
            
            self.progress_update.emit("ëª¨ë“  ëª¨ë¸ í•™ìŠµ ì™„ë£Œ!")
            self.training_complete.emit(results)
            
        except Exception as e:
            self.error_occurred.emit(str(e))
    
    def stop(self):
        """í•™ìŠµ ì¤‘ë‹¨"""
        self.is_running = False


class PredictionWidget(QWidget):
    """ì˜ˆì¸¡ ê²°ê³¼ í‘œì‹œ ìœ„ì ¯"""
    
    def __init__(self):
        super().__init__()
        self.init_ui()
        
    def init_ui(self):
        layout = QVBoxLayout()
        
        # ì˜ˆì¸¡ ê²°ê³¼ í…Œì´ë¸”
        self.result_table = QTableWidget()
        self.result_table.setColumnCount(5)
        self.result_table.setHorizontalHeaderLabels(['ì‹œê°„', 'í˜„ì¬ê°’', 'ì˜ˆì¸¡ê°’', 'ì˜¤ì°¨', 'ë³‘ëª©ì—¬ë¶€'])
        layout.addWidget(self.result_table)
        
        # ì°¨íŠ¸
        self.figure = Figure(figsize=(10, 6))
        self.canvas = FigureCanvas(self.figure)
        layout.addWidget(self.canvas)
        
        self.setLayout(layout)
        
    def update_predictions(self, predictions, actual_values, times):
        """ì˜ˆì¸¡ ê²°ê³¼ ì—…ë°ì´íŠ¸"""
        # í…Œì´ë¸” ì—…ë°ì´íŠ¸
        self.result_table.setRowCount(min(20, len(predictions)))
        
        for i in range(min(20, len(predictions))):
            self.result_table.setItem(i, 0, QTableWidgetItem(str(times[i])))
            self.result_table.setItem(i, 1, QTableWidgetItem(f"{actual_values[i]:.0f}"))
            self.result_table.setItem(i, 2, QTableWidgetItem(f"{predictions[i]:.0f}"))
            self.result_table.setItem(i, 3, QTableWidgetItem(f"{abs(predictions[i] - actual_values[i]):.1f}"))
            
            bottleneck = "ì˜ˆ" if predictions[i] > 2000 else "ì•„ë‹ˆì˜¤"
            self.result_table.setItem(i, 4, QTableWidgetItem(bottleneck))
        
        # ì°¨íŠ¸ ì—…ë°ì´íŠ¸
        self.figure.clear()
        ax = self.figure.add_subplot(111)
        
        sample_size = min(200, len(predictions))
        ax.plot(actual_values[:sample_size], label='ì‹¤ì œê°’', color='blue', linewidth=2)
        ax.plot(predictions[:sample_size], label='ì˜ˆì¸¡ê°’', color='red', linewidth=1.5)
        ax.axhline(y=2000, color='orange', linestyle='--', label='ë³‘ëª© ì„ê³„ê°’')
        
        ax.set_title('ë°˜ë„ì²´ ë¬¼ë¥˜ëŸ‰ ì˜ˆì¸¡ ê²°ê³¼', fontsize=14)
        ax.set_xlabel('ì‹œê°„', fontsize=12)
        ax.set_ylabel('ë¬¼ë¥˜ëŸ‰', fontsize=12)
        ax.legend()
        ax.grid(True, alpha=0.3)
        
        self.canvas.draw()


class MainWindow(QMainWindow):
    """ë©”ì¸ ìœˆë„ìš°"""
    
    def __init__(self):
        super().__init__()
        self.setWindowTitle("ë°˜ë„ì²´ FAB ë¬¼ë¥˜ ì˜ˆì¸¡ í•˜ì´ë¸Œë¦¬ë“œ ë”¥ëŸ¬ë‹ ì‹œìŠ¤í…œ")
        self.setGeometry(100, 100, 1400, 900)
        
        # ë‹¤í¬ í…Œë§ˆ ì ìš©
        self.setStyleSheet("""
            QMainWindow {
                background-color: #1e1e1e;
            }
            QTabWidget::pane {
                background-color: #2d2d2d;
                border: 1px solid #444444;
            }
            QTabBar::tab {
                background-color: #3c3c3c;
                color: #ffffff;
                padding: 8px 16px;
                margin-right: 2px;
            }
            QTabBar::tab:selected {
                background-color: #2d2d2d;
                border-bottom: 2px solid #3498db;
            }
            QPushButton {
                background-color: #3c3c3c;
                color: #ffffff;
                border: 1px solid #555555;
                padding: 8px 16px;
                border-radius: 4px;
                font-weight: bold;
            }
            QPushButton:hover {
                background-color: #484848;
                border: 1px solid #3498db;
            }
            QPushButton:pressed {
                background-color: #2d2d2d;
            }
            QLabel {
                color: #ffffff;
            }
            QGroupBox {
                color: #ffffff;
                border: 1px solid #555555;
                border-radius: 5px;
                margin-top: 10px;
                padding-top: 10px;
                font-weight: bold;
            }
            QGroupBox::title {
                subcontrol-origin: margin;
                left: 10px;
                padding: 0 5px 0 5px;
            }
            QTextEdit, QTableWidget {
                background-color: #2d2d2d;
                color: #ffffff;
                border: 1px solid #444444;
            }
            QHeaderView::section {
                background-color: #3c3c3c;
                color: #ffffff;
                padding: 5px;
                border: 1px solid #555555;
            }
            QProgressBar {
                border: 1px solid #555555;
                border-radius: 3px;
                text-align: center;
                background-color: #2d2d2d;
            }
            QProgressBar::chunk {
                background-color: #3498db;
                border-radius: 3px;
            }
        """)
        
        # ì¤‘ì•™ ìœ„ì ¯
        self.init_ui()
        
        # ë°ì´í„° ì €ì¥
        self.current_data = None
        self.models = {}
        self.scaler = None
        self.checkpoint_manager = CheckpointManager()
        self.training_thread = None
        
    def init_ui(self):
        """UI ì´ˆê¸°í™”"""
        # ë©”ì¸ ìœ„ì ¯
        main_widget = QWidget()
        self.setCentralWidget(main_widget)
        
        # ë©”ì¸ ë ˆì´ì•„ì›ƒ
        layout = QVBoxLayout()
        
        # íƒ­ ìœ„ì ¯
        self.tabs = QTabWidget()
        
        # ë°ì´í„° íƒ­
        self.data_tab = self.create_data_tab()
        self.tabs.addTab(self.data_tab, "ğŸ“Š ë°ì´í„°")
        
        # í•™ìŠµ íƒ­
        self.train_tab = self.create_train_tab()
        self.tabs.addTab(self.train_tab, "ğŸ“ í•™ìŠµ")
        
        # ì˜ˆì¸¡ íƒ­
        self.predict_tab = self.create_predict_tab()
        self.tabs.addTab(self.predict_tab, "ğŸ”® ì˜ˆì¸¡")
        
        # í‰ê°€ íƒ­
        self.evaluate_tab = self.create_evaluate_tab()
        self.tabs.addTab(self.evaluate_tab, "ğŸ“ˆ í‰ê°€")
        
        # ì‹œê°í™” íƒ­
        self.visualize_tab = self.create_visualize_tab()
        self.tabs.addTab(self.visualize_tab, "ğŸ“‰ ì‹œê°í™”")
        
        layout.addWidget(self.tabs)
        
        # ìƒíƒœë°”
        self.status_label = QLabel("ì¤€ë¹„ë¨")
        self.status_label.setStyleSheet("padding: 5px; color: #3498db;")
        layout.addWidget(self.status_label)
        
        main_widget.setLayout(layout)
        
        # ë©”ë‰´ë°”
        self.create_menu_bar()
        
    def create_menu_bar(self):
        """ë©”ë‰´ë°” ìƒì„±"""
        menubar = self.menuBar()
        
        # íŒŒì¼ ë©”ë‰´
        file_menu = menubar.addMenu("íŒŒì¼")
        
        load_action = QAction("ë°ì´í„° ë¶ˆëŸ¬ì˜¤ê¸°", self)
        load_action.setShortcut("Ctrl+O")
        load_action.triggered.connect(self.load_data)
        file_menu.addAction(load_action)
        
        save_action = QAction("ëª¨ë¸ ì €ì¥", self)
        save_action.setShortcut("Ctrl+S")
        save_action.triggered.connect(self.save_models)
        file_menu.addAction(save_action)
        
        file_menu.addSeparator()
        
        exit_action = QAction("ì¢…ë£Œ", self)
        exit_action.setShortcut("Ctrl+Q")
        exit_action.triggered.connect(self.close)
        file_menu.addAction(exit_action)
        
        # ë„êµ¬ ë©”ë‰´
        tools_menu = menubar.addMenu("ë„êµ¬")
        
        checkpoint_action = QAction("ì²´í¬í¬ì¸íŠ¸ ê´€ë¦¬", self)
        checkpoint_action.triggered.connect(self.manage_checkpoints)
        tools_menu.addAction(checkpoint_action)
        
        # ë„ì›€ë§ ë©”ë‰´
        help_menu = menubar.addMenu("ë„ì›€ë§")
        
        about_action = QAction("í”„ë¡œê·¸ë¨ ì •ë³´", self)
        about_action.triggered.connect(self.show_about)
        help_menu.addAction(about_action)
        
    def create_data_tab(self):
        """ë°ì´í„° íƒ­ ìƒì„±"""
        widget = QWidget()
        layout = QVBoxLayout()
        
        # ë°ì´í„° ë¡œë“œ ì„¹ì…˜
        load_group = QGroupBox("ë°ì´í„° ë¡œë“œ")
        load_layout = QVBoxLayout()
        
        # íŒŒì¼ ì„ íƒ
        file_layout = QHBoxLayout()
        self.data_path_edit = QLineEdit()
        self.data_path_edit.setPlaceholderText("ë°ì´í„° íŒŒì¼ ê²½ë¡œ...")
        browse_btn = QPushButton("ì°¾ì•„ë³´ê¸°")
        browse_btn.clicked.connect(self.browse_data_file)
        file_layout.addWidget(self.data_path_edit)
        file_layout.addWidget(browse_btn)
        load_layout.addLayout(file_layout)
        
        # ë¡œë“œ ë²„íŠ¼
        load_btn = QPushButton("ë°ì´í„° ë¡œë“œ")
        load_btn.clicked.connect(self.load_data)
        load_layout.addWidget(load_btn)
        
        load_group.setLayout(load_layout)
        layout.addWidget(load_group)
        
        # ë°ì´í„° ì •ë³´
        info_group = QGroupBox("ë°ì´í„° ì •ë³´")
        info_layout = QVBoxLayout()
        
        self.data_info_text = QTextEdit()
        self.data_info_text.setReadOnly(True)
        self.data_info_text.setMaximumHeight(200)
        info_layout.addWidget(self.data_info_text)
        
        info_group.setLayout(info_layout)
        layout.addWidget(info_group)
        
        # ì „ì²˜ë¦¬ ì˜µì…˜
        preprocess_group = QGroupBox("ì „ì²˜ë¦¬ ì˜µì…˜")
        preprocess_layout = QGridLayout()
        
        # ë‚ ì§œ ë²”ìœ„
        preprocess_layout.addWidget(QLabel("ì‹œì‘ ë‚ ì§œ:"), 0, 0)
        self.start_date_edit = QDateEdit()
        self.start_date_edit.setCalendarPopup(True)
        self.start_date_edit.setDate(QDate(2025, 1, 1))
        preprocess_layout.addWidget(self.start_date_edit, 0, 1)
        
        preprocess_layout.addWidget(QLabel("ì¢…ë£Œ ë‚ ì§œ:"), 0, 2)
        self.end_date_edit = QDateEdit()
        self.end_date_edit.setCalendarPopup(True)
        self.end_date_edit.setDate(QDate(2025, 7, 27))
        preprocess_layout.addWidget(self.end_date_edit, 0, 3)
        
        # ì´ìƒì¹˜ ì œê±°
        self.remove_outliers_check = QCheckBox("ì´ìƒì¹˜ ì œê±°")
        self.remove_outliers_check.setChecked(True)
        preprocess_layout.addWidget(self.remove_outliers_check, 1, 0)
        
        # ìŠ¤ì¼€ì¼ë§
        preprocess_layout.addWidget(QLabel("ìŠ¤ì¼€ì¼ë§:"), 1, 2)
        self.scaling_combo = QComboBox()
        self.scaling_combo.addItems(["StandardScaler", "MinMaxScaler", "RobustScaler"])
        preprocess_layout.addWidget(self.scaling_combo, 1, 3)
        
        # ì „ì²˜ë¦¬ ì‹¤í–‰ ë²„íŠ¼
        preprocess_btn = QPushButton("ì „ì²˜ë¦¬ ì‹¤í–‰")
        preprocess_btn.clicked.connect(self.preprocess_data)
        preprocess_layout.addWidget(preprocess_btn, 2, 0, 1, 4)
        
        preprocess_group.setLayout(preprocess_layout)
        layout.addWidget(preprocess_group)
        
        layout.addStretch()
        widget.setLayout(layout)
        return widget
        
    def create_train_tab(self):
        """í•™ìŠµ íƒ­ ìƒì„±"""
        widget = QWidget()
        layout = QVBoxLayout()
        
        # í•™ìŠµ ì„¤ì •
        config_group = QGroupBox("í•™ìŠµ ì„¤ì •")
        config_layout = QGridLayout()
        
        # ì—í­
        config_layout.addWidget(QLabel("ì—í­:"), 0, 0)
        self.epochs_spin = QSpinBox()
        self.epochs_spin.setRange(10, 500)
        self.epochs_spin.setValue(200)
        config_layout.addWidget(self.epochs_spin, 0, 1)
        
        # ë°°ì¹˜ í¬ê¸°
        config_layout.addWidget(QLabel("ë°°ì¹˜ í¬ê¸°:"), 0, 2)
        self.batch_size_spin = QSpinBox()
        self.batch_size_spin.setRange(16, 256)
        self.batch_size_spin.setValue(64)
        self.batch_size_spin.setSingleStep(16)
        config_layout.addWidget(self.batch_size_spin, 0, 3)
        
        # í•™ìŠµë¥ 
        config_layout.addWidget(QLabel("í•™ìŠµë¥ :"), 1, 0)
        self.learning_rate_spin = QDoubleSpinBox()
        self.learning_rate_spin.setRange(0.0001, 0.1)
        self.learning_rate_spin.setValue(0.0005)
        self.learning_rate_spin.setSingleStep(0.0001)
        self.learning_rate_spin.setDecimals(4)
        config_layout.addWidget(self.learning_rate_spin, 1, 1)
        
        # ê²€ì¦ ë¹„ìœ¨
        config_layout.addWidget(QLabel("ê²€ì¦ ë¹„ìœ¨:"), 1, 2)
        self.validation_split_spin = QDoubleSpinBox()
        self.validation_split_spin.setRange(0.1, 0.5)
        self.validation_split_spin.setValue(0.3)
        self.validation_split_spin.setSingleStep(0.05)
        config_layout.addWidget(self.validation_split_spin, 1, 3)
        
        config_group.setLayout(config_layout)
        layout.addWidget(config_group)
        
        # ëª¨ë¸ ì„ íƒ
        model_group = QGroupBox("ëª¨ë¸ ì„ íƒ")
        model_layout = QVBoxLayout()
        
        self.model_checks = {
            'lstm': QCheckBox("LSTM (Long Short-Term Memory)"),
            'gru': QCheckBox("GRU (Gated Recurrent Unit)"),
            'rnn': QCheckBox("RNN (Recurrent Neural Network)"),
            'bi_lstm': QCheckBox("Bidirectional LSTM")
        }
        
        for check in self.model_checks.values():
            check.setChecked(True)
            model_layout.addWidget(check)
        
        model_group.setLayout(model_layout)
        layout.addWidget(model_group)
        
        # í•™ìŠµ ì œì–´
        control_layout = QHBoxLayout()
        
        self.train_btn = QPushButton("í•™ìŠµ ì‹œì‘")
        self.train_btn.clicked.connect(self.start_training)
        control_layout.addWidget(self.train_btn)
        
        self.stop_btn = QPushButton("í•™ìŠµ ì¤‘ë‹¨")
        self.stop_btn.clicked.connect(self.stop_training)
        self.stop_btn.setEnabled(False)
        control_layout.addWidget(self.stop_btn)
        
        self.resume_btn = QPushButton("ì´ì–´ì„œ í•™ìŠµ")
        self.resume_btn.clicked.connect(self.resume_training)
        control_layout.addWidget(self.resume_btn)
        
        layout.addLayout(control_layout)
        
        # ì§„í–‰ ìƒí™©
        progress_group = QGroupBox("í•™ìŠµ ì§„í–‰ ìƒí™©")
        progress_layout = QVBoxLayout()
        
        self.progress_bar = QProgressBar()
        progress_layout.addWidget(self.progress_bar)
        
        self.training_log = QTextEdit()
        self.training_log.setReadOnly(True)
        self.training_log.setMaximumHeight(200)
        progress_layout.addWidget(self.training_log)
        
        progress_group.setLayout(progress_layout)
        layout.addWidget(progress_group)
        
        layout.addStretch()
        widget.setLayout(layout)
        return widget
        
    def create_predict_tab(self):
        """ì˜ˆì¸¡ íƒ­ ìƒì„±"""
        widget = QWidget()
        layout = QVBoxLayout()
        
        # ì˜ˆì¸¡ ì„¤ì •
        predict_group = QGroupBox("ì˜ˆì¸¡ ì„¤ì •")
        predict_layout = QVBoxLayout()
        
        # ëª¨ë¸ ì„ íƒ
        model_select_layout = QHBoxLayout()
        model_select_layout.addWidget(QLabel("ì˜ˆì¸¡ ëª¨ë¸:"))
        self.predict_model_combo = QComboBox()
        self.predict_model_combo.addItems(["ì•™ìƒë¸” (ì „ì²´)", "LSTM", "GRU", "RNN", "Bi-LSTM"])
        model_select_layout.addWidget(self.predict_model_combo)
        predict_layout.addLayout(model_select_layout)
        
        # ì˜ˆì¸¡ ì‹¤í–‰
        predict_btn = QPushButton("ì˜ˆì¸¡ ì‹¤í–‰")
        predict_btn.clicked.connect(self.run_prediction)
        predict_layout.addWidget(predict_btn)
        
        predict_group.setLayout(predict_layout)
        layout.addWidget(predict_group)
        
        # ì˜ˆì¸¡ ê²°ê³¼
        self.prediction_widget = PredictionWidget()
        layout.addWidget(self.prediction_widget)
        
        widget.setLayout(layout)
        return widget
        
    def create_evaluate_tab(self):
        """í‰ê°€ íƒ­ ìƒì„±"""
        widget = QWidget()
        layout = QVBoxLayout()
        
        # í‰ê°€ ì‹¤í–‰
        eval_btn = QPushButton("ëª¨ë¸ í‰ê°€ ì‹¤í–‰")
        eval_btn.clicked.connect(self.evaluate_models)
        layout.addWidget(eval_btn)
        
        # í‰ê°€ ê²°ê³¼
        self.eval_table = QTableWidget()
        self.eval_table.setColumnCount(8)
        self.eval_table.setHorizontalHeaderLabels([
            'ëª¨ë¸', 'MAPE(%)', 'ì •í™•ë„(10%)', 'RÂ² Score', 
            'ë°©í–¥ì„± ì •í™•ë„', 'ë³‘ëª© ì •í™•ë„', 'ì¢…í•© ì ìˆ˜', 'ë“±ê¸‰'
        ])
        layout.addWidget(self.eval_table)
        
        # ìƒì„¸ ê²°ê³¼
        self.eval_detail_text = QTextEdit()
        self.eval_detail_text.setReadOnly(True)
        self.eval_detail_text.setMaximumHeight(200)
        layout.addWidget(self.eval_detail_text)
        
        widget.setLayout(layout)
        return widget
        
    def create_visualize_tab(self):
        """ì‹œê°í™” íƒ­ ìƒì„±"""
        widget = QWidget()
        layout = QVBoxLayout()
        
        # ì‹œê°í™” ì˜µì…˜
        viz_options = QHBoxLayout()
        
        self.viz_type_combo = QComboBox()
        self.viz_type_combo.addItems([
            "í•™ìŠµ ê³¡ì„ ", "ì˜ˆì¸¡ vs ì‹¤ì œ", "ì˜¤ì°¨ ë¶„í¬", 
            "ë³‘ëª© êµ¬ê°„ íˆíŠ¸ë§µ", "ì‹œê³„ì—´ ë¶„í•´"
        ])
        viz_options.addWidget(QLabel("ì°¨íŠ¸ ìœ í˜•:"))
        viz_options.addWidget(self.viz_type_combo)
        
        viz_btn = QPushButton("ì‹œê°í™” ìƒì„±")
        viz_btn.clicked.connect(self.create_visualization)
        viz_options.addWidget(viz_btn)
        
        layout.addLayout(viz_options)
        
        # ì°¨íŠ¸ ì˜ì—­
        self.viz_figure = Figure(figsize=(12, 8))
        self.viz_canvas = FigureCanvas(self.viz_figure)
        layout.addWidget(self.viz_canvas)
        
        widget.setLayout(layout)
        return widget
        
    def browse_data_file(self):
        """ë°ì´í„° íŒŒì¼ ì°¾ì•„ë³´ê¸°"""
        filename, _ = QFileDialog.getOpenFileName(
            self, "ë°ì´í„° íŒŒì¼ ì„ íƒ", "",
            "CSV Files (*.csv);;Excel Files (*.xlsx);;All Files (*.*)"
        )
        if filename:
            self.data_path_edit.setText(filename)
            
    def load_data(self):
        """ë°ì´í„° ë¡œë“œ"""
        try:
            file_path = self.data_path_edit.text()
            if not file_path:
                QMessageBox.warning(self, "ê²½ê³ ", "ë°ì´í„° íŒŒì¼ì„ ì„ íƒí•˜ì„¸ìš”")
                return
                
            self.update_status("ë°ì´í„° ë¡œë”© ì¤‘...")
            
            # ë°ì´í„° ë¡œë“œ
            if file_path.endswith('.csv'):
                df = pd.read_csv(file_path)
            elif file_path.endswith('.xlsx'):
                df = pd.read_excel(file_path)
            else:
                raise ValueError("ì§€ì›í•˜ì§€ ì•ŠëŠ” íŒŒì¼ í˜•ì‹ì…ë‹ˆë‹¤")
            
            # ë°ì´í„° ì •ë³´ í‘œì‹œ
            info = f"ë°ì´í„° ë¡œë“œ ì™„ë£Œ\n"
            info += f"íŒŒì¼: {os.path.basename(file_path)}\n"
            info += f"í¬ê¸°: {len(df)} Ã— {len(df.columns)}\n"
            info += f"ì»¬ëŸ¼: {', '.join(df.columns[:10])}"
            if len(df.columns) > 10:
                info += f" ... ì™¸ {len(df.columns)-10}ê°œ"
            
            self.data_info_text.setText(info)
            self.current_data = df
            
            self.update_status("ë°ì´í„° ë¡œë“œ ì™„ë£Œ")
            
        except Exception as e:
            QMessageBox.critical(self, "ì˜¤ë¥˜", f"ë°ì´í„° ë¡œë“œ ì‹¤íŒ¨: {str(e)}")
            self.update_status("ë°ì´í„° ë¡œë“œ ì‹¤íŒ¨")
            
    def preprocess_data(self):
        """ë°ì´í„° ì „ì²˜ë¦¬"""
        if self.current_data is None:
            QMessageBox.warning(self, "ê²½ê³ ", "ë¨¼ì € ë°ì´í„°ë¥¼ ë¡œë“œí•˜ì„¸ìš”")
            return
            
        try:
            self.update_status("ì „ì²˜ë¦¬ ì‹œì‘...")
            
            df = self.current_data.copy()
            
            # ì‹œê°„ ì»¬ëŸ¼ ë³€í™˜
            if 'CURRTIME' in df.columns:
                df['CURRTIME'] = pd.to_datetime(df['CURRTIME'], format='%Y%m%d%H%M')
                df.set_index('CURRTIME', inplace=True)
            if 'TIME' in df.columns:
                df['TIME'] = pd.to_datetime(df['TIME'], format='%Y%m%d%H%M')
            
            # ë‚ ì§œ ë²”ìœ„ í•„í„°ë§
            start_date = self.start_date_edit.date().toPyDate()
            end_date = self.end_date_edit.date().toPyDate()
            
            if 'TIME' in df.columns:
                df = df[(df['TIME'] >= pd.Timestamp(start_date)) & 
                       (df['TIME'] <= pd.Timestamp(end_date))]
            
            # SUM ì»¬ëŸ¼ ì œê±°
            columns_to_drop = [col for col in df.columns if 'SUM' in col]
            df = df.drop(columns=columns_to_drop, errors='ignore')
            
            # TOTALCNTë§Œ ì„ íƒ
            if 'TOTALCNT' in df.columns:
                df = df[['TOTALCNT', 'TIME'] if 'TIME' in df.columns else ['TOTALCNT']]
            
            # ì´ìƒì¹˜ ì œê±°
            if self.remove_outliers_check.isChecked() and 'TOTALCNT' in df.columns:
                # PM ê¸°ê°„ ì„¤ì •
                PM_start = pd.to_datetime('2024-10-23')
                PM_end = pd.to_datetime('2024-10-23 23:59:59')
                
                if 'TIME' in df.columns:
                    within_PM = df[(df['TIME'] >= PM_start) & (df['TIME'] <= PM_end)]
                    outside_PM = df[(df['TIME'] < PM_start) | (df['TIME'] > PM_end)]
                    outside_PM_filtered = outside_PM[
                        (outside_PM['TOTALCNT'] >= 800) & 
                        (outside_PM['TOTALCNT'] <= 2500)
                    ]
                    df = pd.concat([within_PM, outside_PM_filtered]).sort_index()
            
            # FUTURE ì»¬ëŸ¼ ìƒì„±
            df['FUTURE'] = pd.NA
            future_minutes = 10
            
            for i in df.index:
                future_time = i + pd.Timedelta(minutes=future_minutes)
                if future_time in df.index:
                    df.loc[i, 'FUTURE'] = df.loc[future_time, 'TOTALCNT']
            
            df.dropna(subset=['FUTURE'], inplace=True)
            
            # íŠ¹ì§• ì—”ì§€ë‹ˆì–´ë§
            df['hour'] = df.index.hour
            df['dayofweek'] = df.index.dayofweek
            df['is_weekend'] = (df.index.dayofweek >= 5).astype(int)
            df['MA_5'] = df['TOTALCNT'].rolling(window=5, min_periods=1).mean()
            df['MA_10'] = df['TOTALCNT'].rolling(window=10, min_periods=1).mean()
            df['MA_30'] = df['TOTALCNT'].rolling(window=30, min_periods=1).mean()
            df['STD_5'] = df['TOTALCNT'].rolling(window=5, min_periods=1).std()
            df['STD_10'] = df['TOTALCNT'].rolling(window=10, min_periods=1).std()
            df['change_rate'] = df['TOTALCNT'].pct_change()
            df = df.fillna(method='ffill').fillna(0)
            
            # ìŠ¤ì¼€ì¼ë§
            scaling_method = self.scaling_combo.currentText()
            if scaling_method == "StandardScaler":
                self.scaler = StandardScaler()
            elif scaling_method == "MinMaxScaler":
                self.scaler = MinMaxScaler()
            else:
                self.scaler = RobustScaler()
            
            scale_columns = ['TOTALCNT', 'FUTURE', 'MA_5', 'MA_10', 'MA_30', 'STD_5', 'STD_10']
            scale_columns = [col for col in scale_columns if col in df.columns]
            
            scaled_data = self.scaler.fit_transform(df[scale_columns])
            scaled_df = pd.DataFrame(
                scaled_data, 
                columns=[f'scaled_{col}' for col in scale_columns],
                index=df.index
            )
            
            df = pd.merge(df, scaled_df, left_index=True, right_index=True)
            
            # ì‹œí€€ìŠ¤ ìƒì„±
            self.create_sequences(df)
            
            info = self.data_info_text.toPlainText()
            info += f"\n\nì „ì²˜ë¦¬ ì™„ë£Œ:\n"
            info += f"ìµœì¢… ë°ì´í„°: {len(df)} ë ˆì½”ë“œ\n"
            info += f"íŠ¹ì§• ìˆ˜: {len(df.columns)}"
            self.data_info_text.setText(info)
            
            self.update_status("ì „ì²˜ë¦¬ ì™„ë£Œ")
            
        except Exception as e:
            QMessageBox.critical(self, "ì˜¤ë¥˜", f"ì „ì²˜ë¦¬ ì‹¤íŒ¨: {str(e)}")
            self.update_status("ì „ì²˜ë¦¬ ì‹¤íŒ¨")
            
    def create_sequences(self, df):
        """ì‹œí€€ìŠ¤ ë°ì´í„° ìƒì„±"""
        seq_length = 30
        
        # ì—°ì†ì„± í™•ì¸
        time_diff = df.index.to_series().diff()
        split_points = time_diff > pd.Timedelta(minutes=1)
        segment_ids = split_points.cumsum()
        
        # ì…ë ¥ íŠ¹ì§•
        input_features = [col for col in df.columns if col.startswith('scaled_') and col != 'scaled_FUTURE']
        
        X, y = [], []
        
        for segment_id in segment_ids.unique():
            segment = df[segment_ids == segment_id]
            
            if len(segment) > seq_length:
                X_data = segment[input_features].values
                y_data = segment['scaled_FUTURE'].values
                
                for i in range(len(segment) - seq_length):
                    X.append(X_data[i:i+seq_length])
                    y.append(y_data[i+seq_length])
        
        X = np.array(X)
        y = np.array(y)
        
        # ë°ì´í„° ë¶„í• 
        train_size = int(0.7 * len(X))
        val_size = int(0.15 * len(X))
        
        self.current_data = {
            'X_train': X[:train_size],
            'y_train': y[:train_size],
            'X_val': X[train_size:train_size+val_size],
            'y_val': y[train_size:train_size+val_size],
            'X_test': X[train_size+val_size:],
            'y_test': y[train_size+val_size:],
            'input_features': input_features,
            'processed_df': df
        }
        
    def start_training(self):
        """í•™ìŠµ ì‹œì‘"""
        if self.current_data is None or 'X_train' not in self.current_data:
            QMessageBox.warning(self, "ê²½ê³ ", "ë¨¼ì € ë°ì´í„°ë¥¼ ì „ì²˜ë¦¬í•˜ì„¸ìš”")
            return
            
        # í•™ìŠµ ì„¤ì •
        config = {
            'epochs': self.epochs_spin.value(),
            'batch_size': self.batch_size_spin.value(),
            'learning_rate': self.learning_rate_spin.value(),
            'validation_split': self.validation_split_spin.value()
        }
        
        # ì„ íƒëœ ëª¨ë¸
        selected_models = [name for name, check in self.model_checks.items() if check.isChecked()]
        if not selected_models:
            QMessageBox.warning(self, "ê²½ê³ ", "ìµœì†Œ í•˜ë‚˜ì˜ ëª¨ë¸ì„ ì„ íƒí•˜ì„¸ìš”")
            return
        
        config['models'] = selected_models
        
        # UI ì—…ë°ì´íŠ¸
        self.train_btn.setEnabled(False)
        self.stop_btn.setEnabled(True)
        self.training_log.clear()
        self.progress_bar.setValue(0)
        
        # í•™ìŠµ ìŠ¤ë ˆë“œ ì‹œì‘
        self.training_thread = TrainingThread(self.current_data, config)
        self.training_thread.progress_update.connect(self.update_training_progress)
        self.training_thread.training_complete.connect(self.on_training_complete)
        self.training_thread.error_occurred.connect(self.on_training_error)
        self.training_thread.start()
        
    def stop_training(self):
        """í•™ìŠµ ì¤‘ë‹¨"""
        if self.training_thread:
            self.training_thread.stop()
            self.train_btn.setEnabled(True)
            self.stop_btn.setEnabled(False)
            self.update_status("í•™ìŠµì´ ì¤‘ë‹¨ë˜ì—ˆìŠµë‹ˆë‹¤")
            
    def resume_training(self):
        """í•™ìŠµ ì¬ê°œ"""
        state = self.checkpoint_manager.load_state()
        if state:
            QMessageBox.information(self, "ì •ë³´", "ì²´í¬í¬ì¸íŠ¸ì—ì„œ í•™ìŠµì„ ì¬ê°œí•©ë‹ˆë‹¤")
            # ì¬ê°œ ë¡œì§ êµ¬í˜„
        else:
            QMessageBox.warning(self, "ê²½ê³ ", "ì €ì¥ëœ ì²´í¬í¬ì¸íŠ¸ê°€ ì—†ìŠµë‹ˆë‹¤")
            
    def update_training_progress(self, message):
        """í•™ìŠµ ì§„í–‰ ìƒí™© ì—…ë°ì´íŠ¸"""
        self.training_log.append(message)
        self.update_status(message)
        
        # í”„ë¡œê·¸ë ˆìŠ¤ë°” ì—…ë°ì´íŠ¸
        if "ì™„ë£Œ" in message:
            current = self.progress_bar.value()
            self.progress_bar.setValue(min(current + 25, 100))
            
    def on_training_complete(self, results):
        """í•™ìŠµ ì™„ë£Œ"""
        self.train_btn.setEnabled(True)
        self.stop_btn.setEnabled(False)
        self.progress_bar.setValue(100)
        
        self.models = results
        self.update_status("ëª¨ë“  ëª¨ë¸ í•™ìŠµ ì™„ë£Œ!")
        
        # ê²°ê³¼ ìš”ì•½
        summary = "\ní•™ìŠµ ê²°ê³¼ ìš”ì•½:\n"
        for model_name, info in results.items():
            summary += f"{model_name.upper()}: Loss={info['final_loss']:.4f}, Val Loss={info['final_val_loss']:.4f}\n"
        
        self.training_log.append(summary)
        
    def on_training_error(self, error_msg):
        """í•™ìŠµ ì˜¤ë¥˜"""
        self.train_btn.setEnabled(True)
        self.stop_btn.setEnabled(False)
        QMessageBox.critical(self, "í•™ìŠµ ì˜¤ë¥˜", error_msg)
        self.update_status("í•™ìŠµ ì‹¤íŒ¨")
        
    def run_prediction(self):
        """ì˜ˆì¸¡ ì‹¤í–‰"""
        if not self.models:
            QMessageBox.warning(self, "ê²½ê³ ", "ë¨¼ì € ëª¨ë¸ì„ í•™ìŠµí•˜ì„¸ìš”")
            return
            
        try:
            self.update_status("ì˜ˆì¸¡ ì‹¤í–‰ ì¤‘...")
            
            # í…ŒìŠ¤íŠ¸ ë°ì´í„°
            X_test = self.current_data['X_test']
            y_test = self.current_data['y_test']
            
            # ì„ íƒëœ ëª¨ë¸
            model_type = self.predict_model_combo.currentText()
            
            if "ì•™ìƒë¸”" in model_type:
                # ì•™ìƒë¸” ì˜ˆì¸¡
                predictions = []
                for model_name in self.models:
                    model_path = self.models[model_name]['model_path']
                    model = load_model(model_path, compile=False)
                    pred = model.predict(X_test, verbose=0)
                    predictions.append(pred.flatten())
                
                # í‰ê·  ì•™ìƒë¸”
                ensemble_pred = np.mean(predictions, axis=0)
            else:
                # ê°œë³„ ëª¨ë¸ ì˜ˆì¸¡
                model_name = model_type.lower().replace('-', '_')
                model_path = self.models[model_name]['model_path']
                model = load_model(model_path, compile=False)
                ensemble_pred = model.predict(X_test, verbose=0).flatten()
            
            # ì—­ìŠ¤ì¼€ì¼ë§
            n_features = self.scaler.n_features_in_
            dummy = np.zeros((len(ensemble_pred), n_features))
            dummy[:, 0] = ensemble_pred
            pred_original = self.scaler.inverse_transform(dummy)[:, 0]
            
            dummy_y = np.zeros((len(y_test), n_features))
            dummy_y[:, 0] = y_test
            y_original = self.scaler.inverse_transform(dummy_y)[:, 0]
            
            # ì‹œê°„ ìƒì„± (ì„ì‹œ)
            times = pd.date_range(start='2025-07-01', periods=len(pred_original), freq='T')
            
            # ì˜ˆì¸¡ ê²°ê³¼ ì—…ë°ì´íŠ¸
            self.prediction_widget.update_predictions(pred_original, y_original, times)
            
            # ì„±ëŠ¥ ë©”íŠ¸ë¦­
            mae = mean_absolute_error(y_original, pred_original)
            mse = mean_squared_error(y_original, pred_original)
            r2 = r2_score(y_original, pred_original)
            
            self.update_status(f"ì˜ˆì¸¡ ì™„ë£Œ - MAE: {mae:.2f}, MSE: {mse:.2f}, RÂ²: {r2:.4f}")
            
        except Exception as e:
            QMessageBox.critical(self, "ì˜¤ë¥˜", f"ì˜ˆì¸¡ ì‹¤íŒ¨: {str(e)}")
            self.update_status("ì˜ˆì¸¡ ì‹¤íŒ¨")
            
    def evaluate_models(self):
        """ëª¨ë¸ í‰ê°€"""
        if not self.models or 'X_test' not in self.current_data:
            QMessageBox.warning(self, "ê²½ê³ ", "ë¨¼ì € ëª¨ë¸ì„ í•™ìŠµí•˜ê³  ë°ì´í„°ë¥¼ ì¤€ë¹„í•˜ì„¸ìš”")
            return
            
        try:
            self.update_status("ëª¨ë¸ í‰ê°€ ì¤‘...")
            
            evaluator = ModelPercentEvaluator()
            evaluator.scaler = self.scaler
            
            X_test = self.current_data['X_test']
            y_test = self.current_data['y_test']
            
            # ì—­ìŠ¤ì¼€ì¼ë§
            n_features = self.scaler.n_features_in_
            dummy_y = np.zeros((len(y_test), n_features))
            dummy_y[:, 0] = y_test
            y_original = self.scaler.inverse_transform(dummy_y)[:, 0]
            
            # í‰ê°€ ê²°ê³¼ ì €ì¥
            results = []
            
            for model_name in self.models:
                model_path = self.models[model_name]['model_path']
                model = load_model(model_path, compile=False)
                
                # ì˜ˆì¸¡
                pred = model.predict(X_test, verbose=0).flatten()
                dummy_pred = np.zeros((len(pred), n_features))
                dummy_pred[:, 0] = pred
                pred_original = self.scaler.inverse_transform(dummy_pred)[:, 0]
                
                # í‰ê°€ ë©”íŠ¸ë¦­
                mape = evaluator.calculate_mape(y_original, pred_original)
                acc_10 = evaluator.calculate_accuracy_within_threshold(y_original, pred_original, 10)
                r2 = r2_score(y_original, pred_original) * 100
                dir_acc = evaluator.calculate_directional_accuracy(y_original, pred_original)
                
                bottleneck_metrics = evaluator.calculate_bottleneck_accuracy(
                    y_original, pred_original, 2000
                )
                
                # ì¢…í•© ì ìˆ˜
                overall_score = (
                    (100 - min(mape, 100)) * 0.2 +
                    acc_10 * 0.3 +
                    r2 * 0.2 +
                    dir_acc * 0.15 +
                    bottleneck_metrics['accuracy'] * 0.15
                )
                
                # ë“±ê¸‰
                if overall_score >= 90:
                    grade = "A+"
                elif overall_score >= 85:
                    grade = "A"
                elif overall_score >= 80:
                    grade = "B+"
                elif overall_score >= 75:
                    grade = "B"
                elif overall_score >= 70:
                    grade = "C+"
                else:
                    grade = "C"
                
                results.append({
                    'model': model_name.upper(),
                    'mape': mape,
                    'acc_10': acc_10,
                    'r2': r2,
                    'dir_acc': dir_acc,
                    'bottleneck_acc': bottleneck_metrics['accuracy'],
                    'overall_score': overall_score,
                    'grade': grade
                })
            
            # í…Œì´ë¸” ì—…ë°ì´íŠ¸
            self.eval_table.setRowCount(len(results))
            for i, res in enumerate(results):
                self.eval_table.setItem(i, 0, QTableWidgetItem(res['model']))
                self.eval_table.setItem(i, 1, QTableWidgetItem(f"{res['mape']:.2f}"))
                self.eval_table.setItem(i, 2, QTableWidgetItem(f"{res['acc_10']:.1f}"))
                self.eval_table.setItem(i, 3, QTableWidgetItem(f"{res['r2']:.1f}"))
                self.eval_table.setItem(i, 4, QTableWidgetItem(f"{res['dir_acc']:.1f}"))
                self.eval_table.setItem(i, 5, QTableWidgetItem(f"{res['bottleneck_acc']:.1f}"))
                self.eval_table.setItem(i, 6, QTableWidgetItem(f"{res['overall_score']:.1f}"))
                self.eval_table.setItem(i, 7, QTableWidgetItem(res['grade']))
            
            # ìµœê³  ì„±ëŠ¥ ëª¨ë¸
            best_model = max(results, key=lambda x: x['overall_score'])
            detail = f"ìµœê³  ì„±ëŠ¥ ëª¨ë¸: {best_model['model']}\n"
            detail += f"ì¢…í•© ì ìˆ˜: {best_model['overall_score']:.1f}%\n"
            detail += f"ì„±ëŠ¥ ë“±ê¸‰: {best_model['grade']}"
            
            self.eval_detail_text.setText(detail)
            self.update_status("ëª¨ë¸ í‰ê°€ ì™„ë£Œ")
            
        except Exception as e:
            QMessageBox.critical(self, "ì˜¤ë¥˜", f"í‰ê°€ ì‹¤íŒ¨: {str(e)}")
            self.update_status("í‰ê°€ ì‹¤íŒ¨")
            
    def create_visualization(self):
        """ì‹œê°í™” ìƒì„±"""
        viz_type = self.viz_type_combo.currentText()
        
        self.viz_figure.clear()
        
        if viz_type == "í•™ìŠµ ê³¡ì„ " and self.models:
            # í•™ìŠµ ê³¡ì„ 
            axes = self.viz_figure.subplots(2, 2)
            axes = axes.ravel()
            
            for idx, (model_name, info) in enumerate(self.models.items()):
                if idx < 4:
                    ax = axes[idx]
                    history = info.get('history', {})
                    
                    if 'loss' in history:
                        ax.plot(history['loss'], label='Training Loss')
                    if 'val_loss' in history:
                        ax.plot(history['val_loss'], label='Validation Loss')
                    
                    ax.set_title(f'{model_name.upper()}')
                    ax.set_xlabel('Epoch')
                    ax.set_ylabel('Loss')
                    ax.legend()
                    ax.grid(True, alpha=0.3)
        
        elif viz_type == "ì˜ˆì¸¡ vs ì‹¤ì œ" and 'X_test' in self.current_data:
            # ì˜ˆì¸¡ vs ì‹¤ì œ
            ax = self.viz_figure.add_subplot(111)
            
            # ê°„ë‹¨í•œ ì‹œê°í™”ë¥¼ ìœ„í•´ ì²« ë²ˆì§¸ ëª¨ë¸ë§Œ ì‚¬ìš©
            if self.models:
                model_name = list(self.models.keys())[0]
                model_path = self.models[model_name]['model_path']
                model = load_model(model_path, compile=False)
                
                X_test = self.current_data['X_test'][:100]  # ìƒ˜í”Œ
                y_test = self.current_data['y_test'][:100]
                
                pred = model.predict(X_test, verbose=0).flatten()
                
                ax.scatter(y_test, pred, alpha=0.5)
                ax.plot([y_test.min(), y_test.max()], [y_test.min(), y_test.max()], 'r--')
                ax.set_xlabel('Actual')
                ax.set_ylabel('Predicted')
                ax.set_title('Predictions vs Actual')
                ax.grid(True, alpha=0.3)
        
        self.viz_canvas.draw()
        
    def save_models(self):
        """ëª¨ë¸ ì €ì¥"""
        if not self.models:
            QMessageBox.warning(self, "ê²½ê³ ", "ì €ì¥í•  ëª¨ë¸ì´ ì—†ìŠµë‹ˆë‹¤")
            return
            
        folder = QFileDialog.getExistingDirectory(self, "ëª¨ë¸ ì €ì¥ í´ë” ì„ íƒ")
        if folder:
            for model_name, info in self.models.items():
                src = info['model_path']
                dst = os.path.join(folder, f"{model_name}_hybrid.keras")
                
                import shutil
                shutil.copy2(src, dst)
            
            # ìŠ¤ì¼€ì¼ëŸ¬ ì €ì¥
            if self.scaler:
                scaler_path = os.path.join(folder, "scaler.pkl")
                joblib.dump(self.scaler, scaler_path)
            
            QMessageBox.information(self, "ì™„ë£Œ", "ëª¨ë¸ì´ ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤")
            
    def manage_checkpoints(self):
        """ì²´í¬í¬ì¸íŠ¸ ê´€ë¦¬"""
        dialog = QDialog(self)
        dialog.setWindowTitle("ì²´í¬í¬ì¸íŠ¸ ê´€ë¦¬")
        dialog.setModal(True)
        
        layout = QVBoxLayout()
        
        # ì²´í¬í¬ì¸íŠ¸ ëª©ë¡
        checkpoint_list = QListWidget()
        checkpoint_dir = self.checkpoint_manager.checkpoint_dir
        
        if os.path.exists(checkpoint_dir):
            files = os.listdir(checkpoint_dir)
            for file in files:
                checkpoint_list.addItem(file)
        
        layout.addWidget(QLabel("ì €ì¥ëœ ì²´í¬í¬ì¸íŠ¸:"))
        layout.addWidget(checkpoint_list)
        
        # ë²„íŠ¼
        btn_layout = QHBoxLayout()
        
        load_btn = QPushButton("ë¶ˆëŸ¬ì˜¤ê¸°")
        load_btn.clicked.connect(lambda: self.load_checkpoint(checkpoint_list.currentItem()))
        btn_layout.addWidget(load_btn)
        
        delete_btn = QPushButton("ì‚­ì œ")
        delete_btn.clicked.connect(lambda: self.delete_checkpoint(checkpoint_list.currentItem()))
        btn_layout.addWidget(delete_btn)
        
        close_btn = QPushButton("ë‹«ê¸°")
        close_btn.clicked.connect(dialog.accept)
        btn_layout.addWidget(close_btn)
        
        layout.addLayout(btn_layout)
        dialog.setLayout(layout)
        dialog.exec_()
        
    def load_checkpoint(self, item):
        """ì²´í¬í¬ì¸íŠ¸ ë¶ˆëŸ¬ì˜¤ê¸°"""
        if item:
            # ì²´í¬í¬ì¸íŠ¸ ë¡œë“œ ë¡œì§
            pass
            
    def delete_checkpoint(self, item):
        """ì²´í¬í¬ì¸íŠ¸ ì‚­ì œ"""
        if item:
            reply = QMessageBox.question(self, "í™•ì¸", "ì´ ì²´í¬í¬ì¸íŠ¸ë¥¼ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?")
            if reply == QMessageBox.Yes:
                # ì‚­ì œ ë¡œì§
                pass
                
    def show_about(self):
        """í”„ë¡œê·¸ë¨ ì •ë³´"""
        about_text = """
ë°˜ë„ì²´ FAB ë¬¼ë¥˜ ì˜ˆì¸¡ í•˜ì´ë¸Œë¦¬ë“œ ë”¥ëŸ¬ë‹ ì‹œìŠ¤í…œ

ë²„ì „: 3.0
ê°œë°œ: 2024

íŠ¹ì§•:
- LSTM, RNN, GRU, Bi-LSTM í†µí•© í•˜ì´ë¸Œë¦¬ë“œ ëª¨ë¸
- CPU ê¸°ë°˜ ì‹¤í–‰ ì§€ì›
- ì‹¤ì‹œê°„ ë³‘ëª© êµ¬ê°„ ì˜ˆì¸¡
- 10ë¶„ í›„ ë¬¼ë¥˜ëŸ‰ ì˜ˆì¸¡
- í¼ì„¼íŠ¸ ê¸°ë°˜ ì„±ëŠ¥ í‰ê°€
- í•™ìŠµ ì¬ì‹œì‘ ê¸°ëŠ¥

ë³¸ ì‹œìŠ¤í…œì€ ë°˜ë„ì²´ ì œì¡° ê³µì •ì˜ ë¬¼ë¥˜ íë¦„ì„
ë”¥ëŸ¬ë‹ìœ¼ë¡œ ì˜ˆì¸¡í•˜ì—¬ ìƒì‚°ì„±ì„ í–¥ìƒì‹œí‚µë‹ˆë‹¤.
        """
        QMessageBox.about(self, "í”„ë¡œê·¸ë¨ ì •ë³´", about_text)
        
    def update_status(self, message):
        """ìƒíƒœ ì—…ë°ì´íŠ¸"""
        self.status_label.setText(f"ìƒíƒœ: {message}")
        QApplication.processEvents()


def main():
    app = QApplication(sys.argv)
    
    # ì• í”Œë¦¬ì¼€ì´ì…˜ ìŠ¤íƒ€ì¼ ì„¤ì •
    app.setStyle("Fusion")
    
    # ë‹¤í¬ íŒ”ë ˆíŠ¸
    palette = QPalette()
    palette.setColor(QPalette.Window, QColor(30, 30, 30))
    palette.setColor(QPalette.WindowText, Qt.white)
    palette.setColor(QPalette.Base, QColor(45, 45, 45))
    palette.setColor(QPalette.AlternateBase, QColor(60, 60, 60))
    palette.setColor(QPalette.ToolTipBase, Qt.black)
    palette.setColor(QPalette.ToolTipText, Qt.white)
    palette.setColor(QPalette.Text, Qt.white)
    palette.setColor(QPalette.Button, QColor(45, 45, 45))
    palette.setColor(QPalette.ButtonText, Qt.white)
    palette.setColor(QPalette.BrightText, Qt.red)
    palette.setColor(QPalette.Link, QColor(42, 130, 218))
    palette.setColor(QPalette.Highlight, QColor(42, 130, 218))
    palette.setColor(QPalette.HighlightedText, Qt.black)
    app.setPalette(palette)
    
    # ë©”ì¸ ìœˆë„ìš° ì‹¤í–‰
    window = MainWindow()
    window.show()
    
    sys.exit(app.exec_())


if __name__ == "__main__":
    main()