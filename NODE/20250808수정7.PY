"""
ë°˜ë„ì²´ FAB ë¬¼ë¥˜ ì˜ˆì¸¡ì„ ìœ„í•œ í†µí•© í•˜ì´ë¸Œë¦¬ë“œ ë”¥ëŸ¬ë‹ ì‹œìŠ¤í…œ
================================================================
LSTM, RNN, GRU, ARIMA ëª¨ë¸ì„ í†µí•©í•œ í•˜ì´ë¸Œë¦¬ë“œ ì˜ˆì¸¡ ì‹œìŠ¤í…œìœ¼ë¡œ
ë°˜ë„ì²´ íŒ¹ ê°„ ë¬¼ë¥˜ ì´ë™ëŸ‰ê³¼ ë³‘ëª© êµ¬ê°„ì„ ì˜ˆì¸¡í•©ë‹ˆë‹¤.

ì£¼ìš” ê¸°ëŠ¥:
1. ê¸°ì¡´ í•™ìŠµëœ ëª¨ë¸ ë¶ˆëŸ¬ì˜¤ê¸° ë° ì„ íƒ
2. ì‹¤ì‹œê°„ ëª¨ë¸ í•™ìŠµ (ì¬ì‹œì‘ ê°€ëŠ¥)
3. ì•™ìƒë¸” ì˜ˆì¸¡ ë° ë³‘ëª© êµ¬ê°„ ê°ì§€
4. í¼ì„¼íŠ¸ ê¸°ë°˜ ì„±ëŠ¥ í‰ê°€
5. CPU ê¸°ë°˜ ì‹¤í–‰
6. í•œê¸€ í°íŠ¸ ì§€ì›

ë²„ì „: 3.2 (í•œê¸€ í°íŠ¸ ìˆ˜ì •)
"""

import sys
import json
import os
import pickle
import traceback
import warnings
from typing import Dict, List, Optional, Tuple
from dataclasses import dataclass
from enum import Enum
from datetime import datetime, timedelta
import glob
import platform

import numpy as np
import pandas as pd
import tensorflow as tf
from sklearn.preprocessing import StandardScaler, MinMaxScaler, RobustScaler
from sklearn.metrics import mean_squared_error, mean_absolute_error, r2_score
from tensorflow.keras.models import Sequential, load_model, Model
from tensorflow.keras.layers import Input, LSTM, Dense, Dropout, BatchNormalization, Bidirectional, GRU, SimpleRNN
from tensorflow.keras.callbacks import EarlyStopping, ReduceLROnPlateau, ModelCheckpoint
from tensorflow.keras.optimizers import Adam
import joblib

# Matplotlib í•œê¸€ í°íŠ¸ ì„¤ì •
import matplotlib
import matplotlib.pyplot as plt
import matplotlib.font_manager as fm
from matplotlib.backends.backend_qt5agg import FigureCanvasQTAgg as FigureCanvas
from matplotlib.figure import Figure
import seaborn as sns

# PyQt5
from PyQt5.QtWidgets import *
from PyQt5.QtCore import *
from PyQt5.QtGui import *

# ê²½ê³  ë©”ì‹œì§€ ìˆ¨ê¸°ê¸°
warnings.filterwarnings('ignore')

# CPU ëª¨ë“œ ì„¤ì •
os.environ['CUDA_VISIBLE_DEVICES'] = '-1'
tf.config.set_visible_devices([], 'GPU')

# ëœë¤ ì‹œë“œ ê³ ì •
RANDOM_SEED = 2079936
tf.random.set_seed(RANDOM_SEED)
np.random.seed(RANDOM_SEED)


def setup_korean_font():
    """ìš´ì˜ì²´ì œë³„ í•œê¸€ í°íŠ¸ ìë™ ì„¤ì •"""
    system = platform.system()
    
    # í°íŠ¸ ê²½ë¡œ ì„¤ì •
    if system == 'Windows':
        font_paths = [
            'C:/Windows/Fonts/malgun.ttf',      # ë§‘ì€ ê³ ë”•
            'C:/Windows/Fonts/malgunbd.ttf',    # ë§‘ì€ ê³ ë”• Bold
            'C:/Windows/Fonts/ngulim.ttf',      # ë‚˜ëˆ”ê³ ë”•
            'C:/Windows/Fonts/NanumGothic.ttf',
            'C:/Windows/Fonts/gulim.ttc',       # êµ´ë¦¼
        ]
        font_family = 'Malgun Gothic'
        
    elif system == 'Darwin':  # macOS
        font_paths = [
            '/System/Library/Fonts/Supplemental/AppleGothic.ttf',
            '/Library/Fonts/AppleGothic.ttf',
            '/System/Library/Fonts/AppleSDGothicNeo.ttc',
            '/Library/Fonts/NanumGothic.ttf',
            '/Users/*/Library/Fonts/NanumGothic.ttf',
        ]
        font_family = 'AppleGothic'
        
    else:  # Linux
        font_paths = [
            '/usr/share/fonts/truetype/nanum/NanumGothic.ttf',
            '/usr/share/fonts/truetype/nanum/NanumGothicBold.ttf',
            '/usr/share/fonts/truetype/liberation/LiberationSans-Regular.ttf',
            '/usr/share/fonts/opentype/noto/NotoSansCJK-Regular.ttc',
            '/usr/share/fonts/truetype/dejavu/DejaVuSans.ttf',
        ]
        font_family = 'NanumGothic'
    
    # ì‚¬ìš© ê°€ëŠ¥í•œ í°íŠ¸ ì°¾ê¸°
    font_set = False
    for font_path in font_paths:
        # ì™€ì¼ë“œì¹´ë“œ ì²˜ë¦¬
        if '*' in font_path:
            import glob
            expanded_paths = glob.glob(os.path.expanduser(font_path))
            if expanded_paths:
                font_path = expanded_paths[0]
        
        if os.path.exists(font_path):
            try:
                # í°íŠ¸ ë§¤ë‹ˆì €ì— ì¶”ê°€
                font_prop = fm.FontProperties(fname=font_path)
                
                # matplotlib ì„¤ì •
                plt.rcParams['font.family'] = font_prop.get_name()
                plt.rcParams['font.sans-serif'] = [font_prop.get_name()]
                
                font_set = True
                print(f"âœ“ í•œê¸€ í°íŠ¸ ì„¤ì • ì™„ë£Œ: {font_prop.get_name()}")
                break
            except:
                continue
    
    # í°íŠ¸ë¥¼ ì°¾ì§€ ëª»í•œ ê²½ìš° ì‹œìŠ¤í…œ ê¸°ë³¸ í°íŠ¸ ì‹œë„
    if not font_set:
        try:
            # ì‹œìŠ¤í…œì— ì„¤ì¹˜ëœ í•œê¸€ í°íŠ¸ ê²€ìƒ‰
            font_list = fm.findSystemFonts(fontpaths=None, fontext='ttf')
            
            # í•œê¸€ í°íŠ¸ í‚¤ì›Œë“œ
            korean_fonts = ['Malgun', 'malgun', 'ë§‘ì€', 'Nanum', 'nanum', 'ë‚˜ëˆ”', 
                          'Gulim', 'gulim', 'êµ´ë¦¼', 'Dotum', 'dotum', 'ë‹ì›€',
                          'Gothic', 'gothic', 'ê³ ë”•', 'Batang', 'batang', 'ë°”íƒ•']
            
            for font in font_list:
                font_name = os.path.basename(font).lower()
                if any(kf.lower() in font_name for kf in korean_fonts):
                    try:
                        font_prop = fm.FontProperties(fname=font)
                        plt.rcParams['font.family'] = font_prop.get_name()
                        plt.rcParams['font.sans-serif'] = [font_prop.get_name()]
                        font_set = True
                        print(f"âœ“ í•œê¸€ í°íŠ¸ ìë™ ê°ì§€: {font_prop.get_name()}")
                        break
                    except:
                        continue
        except:
            pass
    
    # ìµœì¢… í´ë°±: ì‹œìŠ¤í…œ ê¸°ë³¸ í°íŠ¸ ì‚¬ìš©
    if not font_set:
        if system == 'Windows':
            plt.rcParams['font.family'] = 'Malgun Gothic'
        elif system == 'Darwin':
            plt.rcParams['font.family'] = 'AppleGothic'
        else:
            # Linuxì—ì„œ í°íŠ¸ë¥¼ ì°¾ì§€ ëª»í•œ ê²½ìš°
            print("âš  í•œê¸€ í°íŠ¸ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤. ì˜ë¬¸ìœ¼ë¡œ í‘œì‹œë©ë‹ˆë‹¤.")
            print("  NanumGothic í°íŠ¸ ì„¤ì¹˜ë¥¼ ê¶Œì¥í•©ë‹ˆë‹¤:")
            print("  Ubuntu/Debian: sudo apt-get install fonts-nanum")
            print("  CentOS/RHEL: sudo yum install nhn-nanum-fonts")
            return False
    
    # ë§ˆì´ë„ˆìŠ¤ ê¸°í˜¸ ê¹¨ì§ ë°©ì§€
    plt.rcParams['axes.unicode_minus'] = False
    
    # ê¸°ë³¸ ìŠ¤íƒ€ì¼ ì„¤ì •
    plt.rcParams['figure.figsize'] = (12, 6)
    plt.rcParams['axes.grid'] = True
    plt.rcParams['grid.alpha'] = 0.3
    plt.rcParams['axes.labelsize'] = 12
    plt.rcParams['axes.titlesize'] = 14
    plt.rcParams['xtick.labelsize'] = 10
    plt.rcParams['ytick.labelsize'] = 10
    plt.rcParams['legend.fontsize'] = 10
    
    return True


# í”„ë¡œê·¸ë¨ ì‹œì‘ ì‹œ í•œê¸€ í°íŠ¸ ì„¤ì • ì‹¤í–‰
KOREAN_FONT_AVAILABLE = setup_korean_font()


class ModelManager:
    """ëª¨ë¸ ê´€ë¦¬ í´ë˜ìŠ¤ - ê¸°ì¡´ ëª¨ë¸ ë¶ˆëŸ¬ì˜¤ê¸° ë° ê´€ë¦¬"""
    
    def __init__(self):
        self.loaded_models = {}
        self.model_info = {}
        self.scaler = None
        self.config = None
        
    def scan_model_directory(self, directory='model'):
        """ëª¨ë¸ ë””ë ‰í† ë¦¬ ìŠ¤ìº”"""
        models_found = {}
        
        if os.path.exists(directory):
            # .keras íŒŒì¼ ê²€ìƒ‰
            keras_files = glob.glob(os.path.join(directory, '*.keras'))
            
            for file_path in keras_files:
                filename = os.path.basename(file_path)
                model_name = filename.replace('.keras', '')
                
                # ëª¨ë¸ íƒ€ì… ì¶”ë¡ 
                if 'lstm' in model_name.lower():
                    model_type = 'LSTM'
                elif 'gru' in model_name.lower():
                    model_type = 'GRU'
                elif 'rnn' in model_name.lower():
                    model_type = 'RNN'
                elif 'bi' in model_name.lower():
                    model_type = 'Bi-LSTM'
                else:
                    model_type = 'Unknown'
                
                # íŒŒì¼ ì •ë³´
                file_stat = os.stat(file_path)
                models_found[model_name] = {
                    'path': file_path,
                    'type': model_type,
                    'size': file_stat.st_size / (1024 * 1024),  # MB
                    'modified': datetime.fromtimestamp(file_stat.st_mtime),
                    'loaded': False
                }
        
        return models_found
    
    def load_model(self, model_path):
        """ëª¨ë¸ ë¡œë“œ"""
        try:
            model = load_model(model_path, compile=False)
            # ì¬ì»´íŒŒì¼
            model.compile(optimizer='adam', loss='mse', metrics=['mae'])
            return model
        except Exception as e:
            raise Exception(f"ëª¨ë¸ ë¡œë“œ ì‹¤íŒ¨: {str(e)}")
    
    def load_scaler(self, scaler_path=None):
        """ìŠ¤ì¼€ì¼ëŸ¬ ë¡œë“œ"""
        if scaler_path and os.path.exists(scaler_path):
            self.scaler = joblib.load(scaler_path)
            return True
        
        # ê¸°ë³¸ ê²½ë¡œì—ì„œ ì°¾ê¸°
        default_paths = [
            'scaler/standard_scaler_hybrid.pkl',
            'scaler/StdScaler_s30f10_0731_2079936.save',
            'scaler/scaler.pkl'
        ]
        
        for path in default_paths:
            if os.path.exists(path):
                self.scaler = joblib.load(path)
                return True
        
        return False
    
    def load_config(self, config_path=None):
        """ì„¤ì • íŒŒì¼ ë¡œë“œ"""
        if config_path and os.path.exists(config_path):
            with open(config_path, 'r') as f:
                self.config = json.load(f)
            return True
        
        # ê¸°ë³¸ ê²½ë¡œì—ì„œ ì°¾ê¸°
        default_path = 'results/training_config.json'
        if os.path.exists(default_path):
            with open(default_path, 'r') as f:
                self.config = json.load(f)
            return True
        
        # ê¸°ë³¸ ì„¤ì •
        self.config = {
            'seq_length': 30,
            'future_minutes': 10,
            'bottleneck_threshold': 2000
        }
        return False


class ModelPercentEvaluator:
    """ëª¨ë¸ ì„±ëŠ¥ì„ í¼ì„¼íŠ¸ë¡œ í‰ê°€í•˜ëŠ” í´ë˜ìŠ¤"""
    
    def __init__(self):
        self.models = {}
        self.scaler = None
        self.config = None
        
    def calculate_mape(self, y_true, y_pred):
        """MAPE (Mean Absolute Percentage Error) ê³„ì‚°"""
        mask = y_true != 0
        if not np.any(mask):
            return 0
        mape = np.mean(np.abs((y_true[mask] - y_pred[mask]) / y_true[mask])) * 100
        return mape
    
    def calculate_accuracy_within_threshold(self, y_true, y_pred, threshold_percent=10):
        """íŠ¹ì • ì˜¤ì°¨ ë²”ìœ„ ë‚´ ì˜ˆì¸¡ ì •í™•ë„ ê³„ì‚°"""
        threshold = np.mean(y_true) * (threshold_percent / 100)
        within_threshold = np.abs(y_true - y_pred) <= threshold
        accuracy = np.mean(within_threshold) * 100
        return accuracy
    
    def calculate_directional_accuracy(self, y_true, y_pred):
        """ë°©í–¥ì„± ì •í™•ë„ (ì¦ê°€/ê°ì†Œ ì˜ˆì¸¡ ì •í™•ë„)"""
        true_direction = np.diff(y_true) > 0
        pred_direction = np.diff(y_pred) > 0
        directional_accuracy = np.mean(true_direction == pred_direction) * 100
        return directional_accuracy
    
    def calculate_bottleneck_accuracy(self, y_true, y_pred, threshold):
        """ë³‘ëª© êµ¬ê°„ ì˜ˆì¸¡ ì •í™•ë„"""
        true_bottleneck = y_true > threshold
        pred_bottleneck = y_pred > threshold
        
        tp = np.sum((true_bottleneck == True) & (pred_bottleneck == True))
        tn = np.sum((true_bottleneck == False) & (pred_bottleneck == False))
        fp = np.sum((true_bottleneck == False) & (pred_bottleneck == True))
        fn = np.sum((true_bottleneck == True) & (pred_bottleneck == False))
        
        total = tp + tn + fp + fn
        
        accuracy = (tp + tn) / total * 100 if total > 0 else 0
        precision = tp / (tp + fp) * 100 if (tp + fp) > 0 else 0
        recall = tp / (tp + fn) * 100 if (tp + fn) > 0 else 0
        f1 = 2 * (precision * recall) / (precision + recall) if (precision + recall) > 0 else 0
        
        return {
            'accuracy': accuracy,
            'precision': precision,
            'recall': recall,
            'f1_score': f1
        }


class ModelSelectionDialog(QDialog):
    """ëª¨ë¸ ì„ íƒ ëŒ€í™”ìƒì"""
    
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setWindowTitle("ëª¨ë¸ ì„ íƒ")
        self.setModal(True)
        self.setMinimumWidth(800)
        self.setMinimumHeight(500)
        
        self.model_manager = ModelManager()
        self.selected_models = []
        self.selected_scaler = None
        
        self.init_ui()
        self.refresh_models()
        
    def init_ui(self):
        layout = QVBoxLayout()
        
        # ëª¨ë¸ ë””ë ‰í† ë¦¬ ì„ íƒ
        dir_layout = QHBoxLayout()
        dir_layout.addWidget(QLabel("ëª¨ë¸ ë””ë ‰í† ë¦¬:"))
        self.dir_edit = QLineEdit("model")
        dir_layout.addWidget(self.dir_edit)
        
        browse_btn = QPushButton("ì°¾ì•„ë³´ê¸°")
        browse_btn.clicked.connect(self.browse_directory)
        dir_layout.addWidget(browse_btn)
        
        refresh_btn = QPushButton("ìƒˆë¡œê³ ì¹¨")
        refresh_btn.clicked.connect(self.refresh_models)
        dir_layout.addWidget(refresh_btn)
        
        layout.addLayout(dir_layout)
        
        # ëª¨ë¸ ëª©ë¡ í…Œì´ë¸”
        self.model_table = QTableWidget()
        self.model_table.setColumnCount(6)
        self.model_table.setHorizontalHeaderLabels(['ì„ íƒ', 'ëª¨ë¸ëª…', 'íƒ€ì…', 'í¬ê¸°(MB)', 'ìˆ˜ì •ì¼', 'ê²½ë¡œ'])
        self.model_table.horizontalHeader().setStretchLastSection(True)
        layout.addWidget(self.model_table)
        
        # ìŠ¤ì¼€ì¼ëŸ¬ ì„ íƒ
        scaler_group = QGroupBox("ìŠ¤ì¼€ì¼ëŸ¬ ì„ íƒ")
        scaler_layout = QHBoxLayout()
        
        self.scaler_edit = QLineEdit()
        self.scaler_edit.setPlaceholderText("ìŠ¤ì¼€ì¼ëŸ¬ íŒŒì¼ ê²½ë¡œ...")
        scaler_layout.addWidget(self.scaler_edit)
        
        scaler_browse_btn = QPushButton("ì°¾ì•„ë³´ê¸°")
        scaler_browse_btn.clicked.connect(self.browse_scaler)
        scaler_layout.addWidget(scaler_browse_btn)
        
        auto_find_btn = QPushButton("ìë™ ì°¾ê¸°")
        auto_find_btn.clicked.connect(self.auto_find_scaler)
        scaler_layout.addWidget(auto_find_btn)
        
        scaler_group.setLayout(scaler_layout)
        layout.addWidget(scaler_group)
        
        # ë²„íŠ¼
        button_layout = QHBoxLayout()
        
        load_btn = QPushButton("ì„ íƒí•œ ëª¨ë¸ ë¶ˆëŸ¬ì˜¤ê¸°")
        load_btn.clicked.connect(self.load_selected_models)
        button_layout.addWidget(load_btn)
        
        cancel_btn = QPushButton("ì·¨ì†Œ")
        cancel_btn.clicked.connect(self.reject)
        button_layout.addWidget(cancel_btn)
        
        layout.addLayout(button_layout)
        
        self.setLayout(layout)
        
    def browse_directory(self):
        """ë””ë ‰í† ë¦¬ ì„ íƒ"""
        directory = QFileDialog.getExistingDirectory(self, "ëª¨ë¸ ë””ë ‰í† ë¦¬ ì„ íƒ")
        if directory:
            self.dir_edit.setText(directory)
            self.refresh_models()
            
    def refresh_models(self):
        """ëª¨ë¸ ëª©ë¡ ìƒˆë¡œê³ ì¹¨"""
        directory = self.dir_edit.text()
        models = self.model_manager.scan_model_directory(directory)
        
        self.model_table.setRowCount(len(models))
        
        for i, (name, info) in enumerate(models.items()):
            # ì²´í¬ë°•ìŠ¤
            checkbox = QCheckBox()
            checkbox_widget = QWidget()
            checkbox_layout = QHBoxLayout(checkbox_widget)
            checkbox_layout.addWidget(checkbox)
            checkbox_layout.setAlignment(Qt.AlignCenter)
            checkbox_layout.setContentsMargins(0, 0, 0, 0)
            self.model_table.setCellWidget(i, 0, checkbox_widget)
            
            # ëª¨ë¸ ì •ë³´
            self.model_table.setItem(i, 1, QTableWidgetItem(name))
            self.model_table.setItem(i, 2, QTableWidgetItem(info['type']))
            self.model_table.setItem(i, 3, QTableWidgetItem(f"{info['size']:.2f}"))
            self.model_table.setItem(i, 4, QTableWidgetItem(info['modified'].strftime('%Y-%m-%d %H:%M')))
            self.model_table.setItem(i, 5, QTableWidgetItem(info['path']))
            
    def browse_scaler(self):
        """ìŠ¤ì¼€ì¼ëŸ¬ íŒŒì¼ ì„ íƒ"""
        filename, _ = QFileDialog.getOpenFileName(
            self, "ìŠ¤ì¼€ì¼ëŸ¬ íŒŒì¼ ì„ íƒ", "",
            "Pickle Files (*.pkl *.save);;All Files (*.*)"
        )
        if filename:
            self.scaler_edit.setText(filename)
            
    def auto_find_scaler(self):
        """ìŠ¤ì¼€ì¼ëŸ¬ ìë™ ì°¾ê¸°"""
        if self.model_manager.load_scaler():
            QMessageBox.information(self, "ì„±ê³µ", "ìŠ¤ì¼€ì¼ëŸ¬ë¥¼ ìë™ìœ¼ë¡œ ì°¾ì•˜ìŠµë‹ˆë‹¤")
            # ì°¾ì€ ê²½ë¡œ í‘œì‹œ
            if os.path.exists('scaler/standard_scaler_hybrid.pkl'):
                self.scaler_edit.setText('scaler/standard_scaler_hybrid.pkl')
            elif os.path.exists('scaler/StdScaler_s30f10_0731_2079936.save'):
                self.scaler_edit.setText('scaler/StdScaler_s30f10_0731_2079936.save')
        else:
            QMessageBox.warning(self, "ì‹¤íŒ¨", "ìŠ¤ì¼€ì¼ëŸ¬ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤")
            
    def load_selected_models(self):
        """ì„ íƒí•œ ëª¨ë¸ ë¶ˆëŸ¬ì˜¤ê¸°"""
        self.selected_models = []
        
        for i in range(self.model_table.rowCount()):
            checkbox_widget = self.model_table.cellWidget(i, 0)
            checkbox = checkbox_widget.findChild(QCheckBox)
            
            if checkbox.isChecked():
                model_name = self.model_table.item(i, 1).text()
                model_path = self.model_table.item(i, 5).text()
                model_type = self.model_table.item(i, 2).text()
                
                self.selected_models.append({
                    'name': model_name,
                    'path': model_path,
                    'type': model_type
                })
        
        if not self.selected_models:
            QMessageBox.warning(self, "ê²½ê³ ", "ëª¨ë¸ì„ ì„ íƒí•˜ì„¸ìš”")
            return
        
        # ìŠ¤ì¼€ì¼ëŸ¬ ë¡œë“œ
        scaler_path = self.scaler_edit.text()
        if scaler_path:
            self.model_manager.load_scaler(scaler_path)
        else:
            self.model_manager.load_scaler()
        
        self.selected_scaler = self.model_manager.scaler
        
        if self.selected_scaler is None:
            reply = QMessageBox.question(
                self, "í™•ì¸",
                "ìŠ¤ì¼€ì¼ëŸ¬ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤. ê³„ì†í•˜ì‹œê² ìŠµë‹ˆê¹Œ?",
                QMessageBox.Yes | QMessageBox.No
            )
            if reply == QMessageBox.No:
                return
        
        self.accept()


class PredictionWidget(QWidget):
    """ì˜ˆì¸¡ ê²°ê³¼ í‘œì‹œ ìœ„ì ¯"""
    
    def __init__(self):
        super().__init__()
        self.init_ui()
        
    def init_ui(self):
        layout = QVBoxLayout()
        
        # ì˜ˆì¸¡ ê²°ê³¼ í…Œì´ë¸”
        self.result_table = QTableWidget()
        self.result_table.setColumnCount(6)
        self.result_table.setHorizontalHeaderLabels(['ì‹œê°„', 'í˜„ì¬ê°’', 'ì˜ˆì¸¡ê°’', 'ì˜¤ì°¨', 'ì˜¤ì°¨ìœ¨(%)', 'ë³‘ëª©ì—¬ë¶€'])
        layout.addWidget(self.result_table)
        
        # ì°¨íŠ¸
        self.figure = Figure(figsize=(12, 6))
        self.canvas = FigureCanvas(self.figure)
        layout.addWidget(self.canvas)
        
        self.setLayout(layout)
        
    def update_predictions(self, predictions, actual_values, times, threshold=2000):
        """ì˜ˆì¸¡ ê²°ê³¼ ì—…ë°ì´íŠ¸"""
        # í…Œì´ë¸” ì—…ë°ì´íŠ¸
        n_rows = min(50, len(predictions))
        self.result_table.setRowCount(n_rows)
        
        for i in range(n_rows):
            # ì‹œê°„
            if isinstance(times[i], pd.Timestamp):
                time_str = times[i].strftime('%Y-%m-%d %H:%M')
            else:
                time_str = str(times[i])
            self.result_table.setItem(i, 0, QTableWidgetItem(time_str))
            
            # í˜„ì¬ê°’
            self.result_table.setItem(i, 1, QTableWidgetItem(f"{actual_values[i]:.0f}"))
            
            # ì˜ˆì¸¡ê°’
            self.result_table.setItem(i, 2, QTableWidgetItem(f"{predictions[i]:.0f}"))
            
            # ì˜¤ì°¨
            error = abs(predictions[i] - actual_values[i])
            self.result_table.setItem(i, 3, QTableWidgetItem(f"{error:.1f}"))
            
            # ì˜¤ì°¨ìœ¨
            error_rate = (error / actual_values[i] * 100) if actual_values[i] != 0 else 0
            self.result_table.setItem(i, 4, QTableWidgetItem(f"{error_rate:.1f}%"))
            
            # ë³‘ëª©ì—¬ë¶€
            bottleneck = "âš ï¸ ë³‘ëª©" if predictions[i] > threshold else "ì •ìƒ"
            item = QTableWidgetItem(bottleneck)
            if predictions[i] > threshold:
                item.setForeground(QColor('red'))
            self.result_table.setItem(i, 5, item)
        
        # ì°¨íŠ¸ ì—…ë°ì´íŠ¸
        self.figure.clear()
        
        # ì„œë¸Œí”Œë¡¯ ìƒì„±
        ax1 = self.figure.add_subplot(211)
        ax2 = self.figure.add_subplot(212)
        
        # ìƒë‹¨: ì˜ˆì¸¡ vs ì‹¤ì œ
        sample_size = min(200, len(predictions))
        x_range = range(sample_size)
        
        ax1.plot(x_range, actual_values[:sample_size], label='ì‹¤ì œê°’', color='blue', linewidth=2, alpha=0.7)
        ax1.plot(x_range, predictions[:sample_size], label='ì˜ˆì¸¡ê°’', color='red', linewidth=1.5, alpha=0.7)
        ax1.axhline(y=threshold, color='orange', linestyle='--', label=f'ë³‘ëª© ì„ê³„ê°’ ({threshold})', alpha=0.5)
        
        # ë³‘ëª© êµ¬ê°„ í•˜ì´ë¼ì´íŠ¸
        bottleneck_indices = np.where(predictions[:sample_size] > threshold)[0]
        if len(bottleneck_indices) > 0:
            ax1.scatter(bottleneck_indices, predictions[bottleneck_indices], 
                       color='red', s=30, marker='o', label='ë³‘ëª© ì˜ˆì¸¡', zorder=5)
        
        ax1.set_title('ë°˜ë„ì²´ ë¬¼ë¥˜ëŸ‰ ì˜ˆì¸¡ ê²°ê³¼ (10ë¶„ í›„)', fontsize=14)
        ax1.set_xlabel('ì‹œê°„ ì¸ë±ìŠ¤', fontsize=12)
        ax1.set_ylabel('ë¬¼ë¥˜ëŸ‰ (TOTALCNT)', fontsize=12)
        ax1.legend(loc='upper right')
        ax1.grid(True, alpha=0.3)
        
        # í•˜ë‹¨: ì˜¤ì°¨ ë¶„í¬
        errors = np.abs(predictions[:sample_size] - actual_values[:sample_size])
        ax2.bar(x_range, errors, color='green', alpha=0.5)
        ax2.axhline(y=np.mean(errors), color='red', linestyle='--', 
                   label=f'í‰ê·  ì˜¤ì°¨: {np.mean(errors):.1f}')
        
        ax2.set_title('ì˜ˆì¸¡ ì˜¤ì°¨ ë¶„í¬', fontsize=14)
        ax2.set_xlabel('ì‹œê°„ ì¸ë±ìŠ¤', fontsize=12)
        ax2.set_ylabel('ì ˆëŒ€ ì˜¤ì°¨', fontsize=12)
        ax2.legend(loc='upper right')
        ax2.grid(True, alpha=0.3)
        
        self.figure.tight_layout()
        self.canvas.draw()


class MainWindow(QMainWindow):
    """ë©”ì¸ ìœˆë„ìš°"""
    
    def __init__(self):
        super().__init__()
        self.setWindowTitle("ë°˜ë„ì²´ FAB ë¬¼ë¥˜ ì˜ˆì¸¡ í•˜ì´ë¸Œë¦¬ë“œ ë”¥ëŸ¬ë‹ ì‹œìŠ¤í…œ v3.2")
        self.setGeometry(100, 100, 1400, 900)
        
        # ë‹¤í¬ í…Œë§ˆ ì ìš©
        self.setStyleSheet("""
            QMainWindow {
                background-color: #1e1e1e;
            }
            QTabWidget::pane {
                background-color: #2d2d2d;
                border: 1px solid #444444;
            }
            QTabBar::tab {
                background-color: #3c3c3c;
                color: #ffffff;
                padding: 8px 16px;
                margin-right: 2px;
            }
            QTabBar::tab:selected {
                background-color: #2d2d2d;
                border-bottom: 2px solid #3498db;
            }
            QPushButton {
                background-color: #3c3c3c;
                color: #ffffff;
                border: 1px solid #555555;
                padding: 8px 16px;
                border-radius: 4px;
                font-weight: bold;
            }
            QPushButton:hover {
                background-color: #484848;
                border: 1px solid #3498db;
            }
            QPushButton:pressed {
                background-color: #2d2d2d;
            }
            QLabel {
                color: #ffffff;
            }
            QGroupBox {
                color: #ffffff;
                border: 1px solid #555555;
                border-radius: 5px;
                margin-top: 10px;
                padding-top: 10px;
                font-weight: bold;
            }
            QGroupBox::title {
                subcontrol-origin: margin;
                left: 10px;
                padding: 0 5px 0 5px;
            }
            QTextEdit, QTableWidget {
                background-color: #2d2d2d;
                color: #ffffff;
                border: 1px solid #444444;
            }
            QHeaderView::section {
                background-color: #3c3c3c;
                color: #ffffff;
                padding: 5px;
                border: 1px solid #555555;
            }
            QProgressBar {
                border: 1px solid #555555;
                border-radius: 3px;
                text-align: center;
                background-color: #2d2d2d;
            }
            QProgressBar::chunk {
                background-color: #3498db;
                border-radius: 3px;
            }
        """)
        
        # í•œê¸€ í°íŠ¸ ìƒíƒœ í‘œì‹œ
        if not KOREAN_FONT_AVAILABLE:
            QMessageBox.warning(self, "í°íŠ¸ ê²½ê³ ", 
                              "í•œê¸€ í°íŠ¸ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.\n"
                              "ì°¨íŠ¸ì—ì„œ í•œê¸€ì´ ê¹¨ì§ˆ ìˆ˜ ìˆìŠµë‹ˆë‹¤.\n"
                              "NanumGothic í°íŠ¸ ì„¤ì¹˜ë¥¼ ê¶Œì¥í•©ë‹ˆë‹¤.")
        
        # ì¤‘ì•™ ìœ„ì ¯
        self.init_ui()
        
        # ë°ì´í„° ë° ëª¨ë¸ ì €ì¥
        self.current_data = None
        self.loaded_models = {}  # ë¶ˆëŸ¬ì˜¨ ëª¨ë¸ë“¤
        self.trained_models = {}  # í•™ìŠµí•œ ëª¨ë¸ë“¤
        self.scaler = None
        self.model_manager = ModelManager()
        
    def init_ui(self):
        """UI ì´ˆê¸°í™”"""
        # ë©”ì¸ ìœ„ì ¯
        main_widget = QWidget()
        self.setCentralWidget(main_widget)
        
        # ë©”ì¸ ë ˆì´ì•„ì›ƒ
        layout = QVBoxLayout()
        
        # íƒ­ ìœ„ì ¯
        self.tabs = QTabWidget()
        
        # ëª¨ë¸ ê´€ë¦¬ íƒ­ (ìƒˆë¡œ ì¶”ê°€)
        self.model_tab = self.create_model_management_tab()
        self.tabs.addTab(self.model_tab, "ğŸ—‚ï¸ ëª¨ë¸ ê´€ë¦¬")
        
        # ë°ì´í„° íƒ­
        self.data_tab = self.create_data_tab()
        self.tabs.addTab(self.data_tab, "ğŸ“Š ë°ì´í„°")
        
        # ì˜ˆì¸¡ íƒ­
        self.predict_tab = self.create_predict_tab()
        self.tabs.addTab(self.predict_tab, "ğŸ”® ì˜ˆì¸¡")
        
        # í‰ê°€ íƒ­
        self.evaluate_tab = self.create_evaluate_tab()
        self.tabs.addTab(self.evaluate_tab, "ğŸ“ˆ í‰ê°€")
        
        # ì‹œê°í™” íƒ­
        self.visualize_tab = self.create_visualize_tab()
        self.tabs.addTab(self.visualize_tab, "ğŸ“‰ ì‹œê°í™”")
        
        layout.addWidget(self.tabs)
        
        # ìƒíƒœë°”
        self.status_label = QLabel("ì¤€ë¹„ë¨")
        self.status_label.setStyleSheet("padding: 5px; color: #3498db;")
        layout.addWidget(self.status_label)
        
        main_widget.setLayout(layout)
        
        # ë©”ë‰´ë°”
        self.create_menu_bar()
        
    def create_menu_bar(self):
        """ë©”ë‰´ë°” ìƒì„±"""
        menubar = self.menuBar()
        
        # íŒŒì¼ ë©”ë‰´
        file_menu = menubar.addMenu("íŒŒì¼")
        
        load_models_action = QAction("ëª¨ë¸ ë¶ˆëŸ¬ì˜¤ê¸°", self)
        load_models_action.setShortcut("Ctrl+L")
        load_models_action.triggered.connect(self.load_existing_models)
        file_menu.addAction(load_models_action)
        
        load_data_action = QAction("ë°ì´í„° ë¶ˆëŸ¬ì˜¤ê¸°", self)
        load_data_action.setShortcut("Ctrl+O")
        load_data_action.triggered.connect(self.load_data)
        file_menu.addAction(load_data_action)
        
        file_menu.addSeparator()
        
        exit_action = QAction("ì¢…ë£Œ", self)
        exit_action.setShortcut("Ctrl+Q")
        exit_action.triggered.connect(self.close)
        file_menu.addAction(exit_action)
        
        # ë„ì›€ë§ ë©”ë‰´
        help_menu = menubar.addMenu("ë„ì›€ë§")
        
        about_action = QAction("í”„ë¡œê·¸ë¨ ì •ë³´", self)
        about_action.triggered.connect(self.show_about)
        help_menu.addAction(about_action)
        
        font_info_action = QAction("í°íŠ¸ ì •ë³´", self)
        font_info_action.triggered.connect(self.show_font_info)
        help_menu.addAction(font_info_action)
        
    def create_model_management_tab(self):
        """ëª¨ë¸ ê´€ë¦¬ íƒ­ ìƒì„±"""
        widget = QWidget()
        layout = QVBoxLayout()
        
        # ëª¨ë¸ ë¶ˆëŸ¬ì˜¤ê¸° ì„¹ì…˜
        load_group = QGroupBox("ê¸°ì¡´ ëª¨ë¸ ë¶ˆëŸ¬ì˜¤ê¸°")
        load_layout = QVBoxLayout()
        
        load_btn = QPushButton("ğŸ“ ëª¨ë¸ ì„ íƒ ë° ë¶ˆëŸ¬ì˜¤ê¸°")
        load_btn.clicked.connect(self.load_existing_models)
        load_layout.addWidget(load_btn)
        
        load_group.setLayout(load_layout)
        layout.addWidget(load_group)
        
        # ë¶ˆëŸ¬ì˜¨ ëª¨ë¸ ëª©ë¡
        models_group = QGroupBox("ë¶ˆëŸ¬ì˜¨ ëª¨ë¸ ëª©ë¡")
        models_layout = QVBoxLayout()
        
        self.loaded_models_table = QTableWidget()
        self.loaded_models_table.setColumnCount(5)
        self.loaded_models_table.setHorizontalHeaderLabels(['ëª¨ë¸ëª…', 'íƒ€ì…', 'ìƒíƒœ', 'ê²½ë¡œ', 'ì‘ì—…'])
        self.loaded_models_table.horizontalHeader().setStretchLastSection(True)
        models_layout.addWidget(self.loaded_models_table)
        
        models_group.setLayout(models_layout)
        layout.addWidget(models_group)
        
        # ëª¨ë¸ ì •ë³´
        info_group = QGroupBox("ëª¨ë¸ ì •ë³´")
        info_layout = QVBoxLayout()
        
        self.model_info_text = QTextEdit()
        self.model_info_text.setReadOnly(True)
        self.model_info_text.setMaximumHeight(150)
        info_layout.addWidget(self.model_info_text)
        
        info_group.setLayout(info_layout)
        layout.addWidget(info_group)
        
        layout.addStretch()
        widget.setLayout(layout)
        return widget
        
    def create_data_tab(self):
        """ë°ì´í„° íƒ­ ìƒì„±"""
        widget = QWidget()
        layout = QVBoxLayout()
        
        # ë°ì´í„° ë¡œë“œ ì„¹ì…˜
        load_group = QGroupBox("ë°ì´í„° ë¡œë“œ")
        load_layout = QVBoxLayout()
        
        # íŒŒì¼ ì„ íƒ
        file_layout = QHBoxLayout()
        self.data_path_edit = QLineEdit()
        self.data_path_edit.setPlaceholderText("ë°ì´í„° íŒŒì¼ ê²½ë¡œ...")
        browse_btn = QPushButton("ì°¾ì•„ë³´ê¸°")
        browse_btn.clicked.connect(self.browse_data_file)
        file_layout.addWidget(self.data_path_edit)
        file_layout.addWidget(browse_btn)
        load_layout.addLayout(file_layout)
        
        # ë¡œë“œ ë²„íŠ¼
        load_btn = QPushButton("ë°ì´í„° ë¡œë“œ")
        load_btn.clicked.connect(self.load_data)
        load_layout.addWidget(load_btn)
        
        load_group.setLayout(load_layout)
        layout.addWidget(load_group)
        
        # ë°ì´í„° ì •ë³´
        info_group = QGroupBox("ë°ì´í„° ì •ë³´")
        info_layout = QVBoxLayout()
        
        self.data_info_text = QTextEdit()
        self.data_info_text.setReadOnly(True)
        self.data_info_text.setMaximumHeight(200)
        info_layout.addWidget(self.data_info_text)
        
        info_group.setLayout(info_layout)
        layout.addWidget(info_group)
        
        # ì „ì²˜ë¦¬ ì˜µì…˜
        preprocess_group = QGroupBox("ì „ì²˜ë¦¬ ì˜µì…˜")
        preprocess_layout = QGridLayout()
        
        # ë‚ ì§œ ë²”ìœ„
        preprocess_layout.addWidget(QLabel("ì‹œì‘ ë‚ ì§œ:"), 0, 0)
        self.start_date_edit = QDateEdit()
        self.start_date_edit.setCalendarPopup(True)
        self.start_date_edit.setDate(QDate(2025, 1, 1))
        preprocess_layout.addWidget(self.start_date_edit, 0, 1)
        
        preprocess_layout.addWidget(QLabel("ì¢…ë£Œ ë‚ ì§œ:"), 0, 2)
        self.end_date_edit = QDateEdit()
        self.end_date_edit.setCalendarPopup(True)
        self.end_date_edit.setDate(QDate(2025, 7, 27))
        preprocess_layout.addWidget(self.end_date_edit, 0, 3)
        
        # ì „ì²˜ë¦¬ ì‹¤í–‰ ë²„íŠ¼
        preprocess_btn = QPushButton("ì „ì²˜ë¦¬ ì‹¤í–‰")
        preprocess_btn.clicked.connect(self.preprocess_data)
        preprocess_layout.addWidget(preprocess_btn, 1, 0, 1, 4)
        
        preprocess_group.setLayout(preprocess_layout)
        layout.addWidget(preprocess_group)
        
        layout.addStretch()
        widget.setLayout(layout)
        return widget
        
    def create_predict_tab(self):
        """ì˜ˆì¸¡ íƒ­ ìƒì„±"""
        widget = QWidget()
        layout = QVBoxLayout()
        
        # ì˜ˆì¸¡ ì„¤ì •
        predict_group = QGroupBox("ì˜ˆì¸¡ ì„¤ì •")
        predict_layout = QVBoxLayout()
        
        # ëª¨ë¸ ì„ íƒ
        model_select_layout = QHBoxLayout()
        model_select_layout.addWidget(QLabel("ì˜ˆì¸¡ ëª¨ë¸:"))
        self.predict_model_combo = QComboBox()
        self.predict_model_combo.addItems(["ì•™ìƒë¸” (ì „ì²´)", "ê°œë³„ ëª¨ë¸ ì„ íƒ"])
        model_select_layout.addWidget(self.predict_model_combo)
        predict_layout.addLayout(model_select_layout)
        
        # ê°œë³„ ëª¨ë¸ ì„ íƒ ë¦¬ìŠ¤íŠ¸
        self.model_list_widget = QListWidget()
        self.model_list_widget.setSelectionMode(QAbstractItemView.MultiSelection)
        self.model_list_widget.setMaximumHeight(100)
        predict_layout.addWidget(self.model_list_widget)
        
        # ì˜ˆì¸¡ ì‹¤í–‰
        predict_btn = QPushButton("ğŸš€ ì˜ˆì¸¡ ì‹¤í–‰")
        predict_btn.clicked.connect(self.run_prediction)
        predict_layout.addWidget(predict_btn)
        
        predict_group.setLayout(predict_layout)
        layout.addWidget(predict_group)
        
        # ì˜ˆì¸¡ ê²°ê³¼
        self.prediction_widget = PredictionWidget()
        layout.addWidget(self.prediction_widget)
        
        widget.setLayout(layout)
        return widget
        
    def create_evaluate_tab(self):
        """í‰ê°€ íƒ­ ìƒì„±"""
        widget = QWidget()
        layout = QVBoxLayout()
        
        # í‰ê°€ ì‹¤í–‰
        eval_btn = QPushButton("ğŸ“Š ëª¨ë¸ í‰ê°€ ì‹¤í–‰")
        eval_btn.clicked.connect(self.evaluate_models)
        layout.addWidget(eval_btn)
        
        # í‰ê°€ ê²°ê³¼
        self.eval_table = QTableWidget()
        self.eval_table.setColumnCount(9)
        self.eval_table.setHorizontalHeaderLabels([
            'ëª¨ë¸', 'MAPE(%)', 'ì •í™•ë„(10%)', 'RÂ² Score', 
            'ë°©í–¥ì„± ì •í™•ë„', 'ë³‘ëª© ì •í™•ë„', 'ë³‘ëª© F1', 'ì¢…í•© ì ìˆ˜', 'ë“±ê¸‰'
        ])
        layout.addWidget(self.eval_table)
        
        # ìƒì„¸ ê²°ê³¼
        self.eval_detail_text = QTextEdit()
        self.eval_detail_text.setReadOnly(True)
        self.eval_detail_text.setMaximumHeight(200)
        layout.addWidget(self.eval_detail_text)
        
        # ê²°ê³¼ ë‚´ë³´ë‚´ê¸°
        export_btn = QPushButton("ğŸ“¥ í‰ê°€ ê²°ê³¼ ë‚´ë³´ë‚´ê¸°")
        export_btn.clicked.connect(self.export_evaluation_results)
        layout.addWidget(export_btn)
        
        widget.setLayout(layout)
        return widget
        
    def create_visualize_tab(self):
        """ì‹œê°í™” íƒ­ ìƒì„±"""
        widget = QWidget()
        layout = QVBoxLayout()
        
        # ì‹œê°í™” ì˜µì…˜
        viz_options = QHBoxLayout()
        
        self.viz_type_combo = QComboBox()
        self.viz_type_combo.addItems([
            "ì˜ˆì¸¡ vs ì‹¤ì œ", "ì˜¤ì°¨ ë¶„í¬", "ë³‘ëª© êµ¬ê°„ íˆíŠ¸ë§µ", 
            "ëª¨ë¸ë³„ ì„±ëŠ¥ ë¹„êµ", "ì‹œê³„ì—´ ë¶„í•´"
        ])
        viz_options.addWidget(QLabel("ì°¨íŠ¸ ìœ í˜•:"))
        viz_options.addWidget(self.viz_type_combo)
        
        viz_btn = QPushButton("ğŸ“Š ì‹œê°í™” ìƒì„±")
        viz_btn.clicked.connect(self.create_visualization)
        viz_options.addWidget(viz_btn)
        
        save_btn = QPushButton("ğŸ’¾ ì°¨íŠ¸ ì €ì¥")
        save_btn.clicked.connect(self.save_visualization)
        viz_options.addWidget(save_btn)
        
        layout.addLayout(viz_options)
        
        # ì°¨íŠ¸ ì˜ì—­
        self.viz_figure = Figure(figsize=(12, 8))
        self.viz_canvas = FigureCanvas(self.viz_figure)
        layout.addWidget(self.viz_canvas)
        
        widget.setLayout(layout)
        return widget
        
    def load_existing_models(self):
        """ê¸°ì¡´ ëª¨ë¸ ë¶ˆëŸ¬ì˜¤ê¸°"""
        dialog = ModelSelectionDialog(self)
        
        if dialog.exec_() == QDialog.Accepted:
            selected = dialog.selected_models
            
            if selected:
                self.update_status(f"{len(selected)}ê°œ ëª¨ë¸ ë¡œë”© ì¤‘...")
                
                # ìŠ¤ì¼€ì¼ëŸ¬ ì €ì¥
                if dialog.selected_scaler is not None:
                    self.scaler = dialog.selected_scaler
                    self.model_manager.scaler = self.scaler
                
                # ëª¨ë¸ ë¡œë“œ
                for model_info in selected:
                    try:
                        model = dialog.model_manager.load_model(model_info['path'])
                        
                        # ëª¨ë¸ ì €ì¥
                        self.loaded_models[model_info['name']] = {
                            'model': model,
                            'path': model_info['path'],
                            'type': model_info['type'],
                            'loaded_time': datetime.now()
                        }
                        
                    except Exception as e:
                        QMessageBox.warning(self, "ê²½ê³ ", f"ëª¨ë¸ ë¡œë“œ ì‹¤íŒ¨ ({model_info['name']}): {str(e)}")
                
                # UI ì—…ë°ì´íŠ¸
                self.update_loaded_models_table()
                self.update_model_list()
                
                self.update_status(f"{len(self.loaded_models)}ê°œ ëª¨ë¸ ë¡œë“œ ì™„ë£Œ")
                
                # ëª¨ë¸ ì •ë³´ í‘œì‹œ
                info = f"ë¶ˆëŸ¬ì˜¨ ëª¨ë¸: {len(self.loaded_models)}ê°œ\n"
                info += f"ìŠ¤ì¼€ì¼ëŸ¬: {'ë¡œë“œë¨' if self.scaler else 'ì—†ìŒ'}\n\n"
                
                for name, details in self.loaded_models.items():
                    info += f"â€¢ {name} ({details['type']})\n"
                
                self.model_info_text.setText(info)
                
    def update_loaded_models_table(self):
        """ë¶ˆëŸ¬ì˜¨ ëª¨ë¸ í…Œì´ë¸” ì—…ë°ì´íŠ¸"""
        self.loaded_models_table.setRowCount(len(self.loaded_models))
        
        for i, (name, details) in enumerate(self.loaded_models.items()):
            self.loaded_models_table.setItem(i, 0, QTableWidgetItem(name))
            self.loaded_models_table.setItem(i, 1, QTableWidgetItem(details['type']))
            self.loaded_models_table.setItem(i, 2, QTableWidgetItem("ë¡œë“œë¨"))
            self.loaded_models_table.setItem(i, 3, QTableWidgetItem(details['path']))
            
            # ì œê±° ë²„íŠ¼
            remove_btn = QPushButton("ì œê±°")
            remove_btn.clicked.connect(lambda checked, n=name: self.remove_model(n))
            self.loaded_models_table.setCellWidget(i, 4, remove_btn)
            
    def update_model_list(self):
        """ì˜ˆì¸¡ íƒ­ì˜ ëª¨ë¸ ë¦¬ìŠ¤íŠ¸ ì—…ë°ì´íŠ¸"""
        self.model_list_widget.clear()
        
        for name in self.loaded_models.keys():
            self.model_list_widget.addItem(name)
            
    def remove_model(self, model_name):
        """ëª¨ë¸ ì œê±°"""
        if model_name in self.loaded_models:
            del self.loaded_models[model_name]
            self.update_loaded_models_table()
            self.update_model_list()
            self.update_status(f"{model_name} ëª¨ë¸ì´ ì œê±°ë˜ì—ˆìŠµë‹ˆë‹¤")
            
    def browse_data_file(self):
        """ë°ì´í„° íŒŒì¼ ì°¾ì•„ë³´ê¸°"""
        filename, _ = QFileDialog.getOpenFileName(
            self, "ë°ì´í„° íŒŒì¼ ì„ íƒ", "",
            "CSV Files (*.csv);;Excel Files (*.xlsx);;All Files (*.*)"
        )
        if filename:
            self.data_path_edit.setText(filename)
            
    def load_data(self):
        """ë°ì´í„° ë¡œë“œ"""
        try:
            file_path = self.data_path_edit.text()
            if not file_path:
                # íŒŒì¼ ì„ íƒ ëŒ€í™”ìƒì
                file_path, _ = QFileDialog.getOpenFileName(
                    self, "ë°ì´í„° íŒŒì¼ ì„ íƒ", "",
                    "CSV Files (*.csv);;Excel Files (*.xlsx);;All Files (*.*)"
                )
                if not file_path:
                    return
                self.data_path_edit.setText(file_path)
            
            self.update_status("ë°ì´í„° ë¡œë”© ì¤‘...")
            
            # ë°ì´í„° ë¡œë“œ
            if file_path.endswith('.csv'):
                df = pd.read_csv(file_path)
            elif file_path.endswith('.xlsx'):
                df = pd.read_excel(file_path)
            else:
                raise ValueError("ì§€ì›í•˜ì§€ ì•ŠëŠ” íŒŒì¼ í˜•ì‹ì…ë‹ˆë‹¤")
            
            # ë°ì´í„° ì •ë³´ í‘œì‹œ
            info = f"ë°ì´í„° ë¡œë“œ ì™„ë£Œ\n"
            info += f"íŒŒì¼: {os.path.basename(file_path)}\n"
            info += f"í¬ê¸°: {len(df)} Ã— {len(df.columns)}\n"
            info += f"ì»¬ëŸ¼: {', '.join(df.columns[:10])}"
            if len(df.columns) > 10:
                info += f" ... ì™¸ {len(df.columns)-10}ê°œ"
            
            self.data_info_text.setText(info)
            self.current_data = df
            
            self.update_status("ë°ì´í„° ë¡œë“œ ì™„ë£Œ")
            
        except Exception as e:
            QMessageBox.critical(self, "ì˜¤ë¥˜", f"ë°ì´í„° ë¡œë“œ ì‹¤íŒ¨: {str(e)}")
            self.update_status("ë°ì´í„° ë¡œë“œ ì‹¤íŒ¨")
            
    def preprocess_data(self):
        """ë°ì´í„° ì „ì²˜ë¦¬"""
        if self.current_data is None:
            QMessageBox.warning(self, "ê²½ê³ ", "ë¨¼ì € ë°ì´í„°ë¥¼ ë¡œë“œí•˜ì„¸ìš”")
            return
            
        try:
            self.update_status("ì „ì²˜ë¦¬ ì‹œì‘...")
            
            df = self.current_data.copy()
            
            # ì‹œê°„ ì»¬ëŸ¼ ë³€í™˜
            if 'CURRTIME' in df.columns:
                df['CURRTIME'] = pd.to_datetime(df['CURRTIME'], format='%Y%m%d%H%M')
                df.set_index('CURRTIME', inplace=True)
            if 'TIME' in df.columns:
                df['TIME'] = pd.to_datetime(df['TIME'], format='%Y%m%d%H%M')
            
            # ë‚ ì§œ ë²”ìœ„ í•„í„°ë§
            start_date = self.start_date_edit.date().toPyDate()
            end_date = self.end_date_edit.date().toPyDate()
            
            if 'TIME' in df.columns:
                df = df[(df['TIME'] >= pd.Timestamp(start_date)) & 
                       (df['TIME'] <= pd.Timestamp(end_date))]
            
            # SUM ì»¬ëŸ¼ ì œê±°
            columns_to_drop = [col for col in df.columns if 'SUM' in col]
            df = df.drop(columns=columns_to_drop, errors='ignore')
            
            # TOTALCNTë§Œ ì„ íƒ
            if 'TOTALCNT' in df.columns:
                df = df[['TOTALCNT', 'TIME'] if 'TIME' in df.columns else ['TOTALCNT']]
            
            # FUTURE ì»¬ëŸ¼ ìƒì„±
            df['FUTURE'] = pd.NA
            future_minutes = 10
            
            for i in df.index:
                future_time = i + pd.Timedelta(minutes=future_minutes)
                if future_time in df.index:
                    df.loc[i, 'FUTURE'] = df.loc[future_time, 'TOTALCNT']
            
            df.dropna(subset=['FUTURE'], inplace=True)
            
            # íŠ¹ì§• ì—”ì§€ë‹ˆì–´ë§
            df['hour'] = df.index.hour
            df['dayofweek'] = df.index.dayofweek
            df['is_weekend'] = (df.index.dayofweek >= 5).astype(int)
            df['MA_5'] = df['TOTALCNT'].rolling(window=5, min_periods=1).mean()
            df['MA_10'] = df['TOTALCNT'].rolling(window=10, min_periods=1).mean()
            df['MA_30'] = df['TOTALCNT'].rolling(window=30, min_periods=1).mean()
            df['STD_5'] = df['TOTALCNT'].rolling(window=5, min_periods=1).std()
            df['STD_10'] = df['TOTALCNT'].rolling(window=10, min_periods=1).std()
            df['change_rate'] = df['TOTALCNT'].pct_change()
            df = df.ffill().fillna(0)
            
            # ìŠ¤ì¼€ì¼ë§
            if self.scaler is None:
                self.scaler = StandardScaler()
                
            scale_columns = ['TOTALCNT', 'FUTURE', 'MA_5', 'MA_10', 'MA_30', 'STD_5', 'STD_10']
            scale_columns = [col for col in scale_columns if col in df.columns]
            
            scaled_data = self.scaler.fit_transform(df[scale_columns])
            scaled_df = pd.DataFrame(
                scaled_data, 
                columns=[f'scaled_{col}' for col in scale_columns],
                index=df.index
            )
            
            df = pd.merge(df, scaled_df, left_index=True, right_index=True)
            
            # ì‹œí€€ìŠ¤ ìƒì„±
            self.create_sequences(df)
            
            info = self.data_info_text.toPlainText()
            info += f"\n\nì „ì²˜ë¦¬ ì™„ë£Œ:\n"
            info += f"ìµœì¢… ë°ì´í„°: {len(df)} ë ˆì½”ë“œ\n"
            info += f"íŠ¹ì§• ìˆ˜: {len(df.columns)}"
            self.data_info_text.setText(info)
            
            self.update_status("ì „ì²˜ë¦¬ ì™„ë£Œ")
            
        except Exception as e:
            QMessageBox.critical(self, "ì˜¤ë¥˜", f"ì „ì²˜ë¦¬ ì‹¤íŒ¨: {str(e)}")
            self.update_status("ì „ì²˜ë¦¬ ì‹¤íŒ¨")
            
    def create_sequences(self, df):
        """ì‹œí€€ìŠ¤ ë°ì´í„° ìƒì„±"""
        seq_length = 30
        
        # ì—°ì†ì„± í™•ì¸
        time_diff = df.index.to_series().diff()
        split_points = time_diff > pd.Timedelta(minutes=1)
        segment_ids = split_points.cumsum()
        
        # ì…ë ¥ íŠ¹ì§•
        input_features = [col for col in df.columns if col.startswith('scaled_') and col != 'scaled_FUTURE']
        
        X, y = [], []
        
        for segment_id in segment_ids.unique():
            segment = df[segment_ids == segment_id]
            
            if len(segment) > seq_length:
                X_data = segment[input_features].values
                y_data = segment['scaled_FUTURE'].values
                
                for i in range(len(segment) - seq_length):
                    X.append(X_data[i:i+seq_length])
                    y.append(y_data[i+seq_length])
        
        X = np.array(X)
        y = np.array(y)
        
        # ë°ì´í„° ë¶„í• 
        train_size = int(0.7 * len(X))
        val_size = int(0.15 * len(X))
        
        self.current_data = {
            'X_train': X[:train_size],
            'y_train': y[:train_size],
            'X_val': X[train_size:train_size+val_size],
            'y_val': y[train_size:train_size+val_size],
            'X_test': X[train_size+val_size:],
            'y_test': y[train_size+val_size:],
            'input_features': input_features,
            'processed_df': df
        }
        
    def run_prediction(self):
        """ì˜ˆì¸¡ ì‹¤í–‰"""
        if not self.loaded_models:
            QMessageBox.warning(self, "ê²½ê³ ", "ë¨¼ì € ëª¨ë¸ì„ ë¶ˆëŸ¬ì˜¤ì„¸ìš”")
            return
            
        if self.current_data is None or 'X_test' not in self.current_data:
            QMessageBox.warning(self, "ê²½ê³ ", "ë¨¼ì € ë°ì´í„°ë¥¼ ì „ì²˜ë¦¬í•˜ì„¸ìš”")
            return
            
        try:
            self.update_status("ì˜ˆì¸¡ ì‹¤í–‰ ì¤‘...")
            
            # í…ŒìŠ¤íŠ¸ ë°ì´í„°
            X_test = self.current_data['X_test']
            y_test = self.current_data['y_test']
            
            # ì„ íƒëœ ëª¨ë¸
            if self.predict_model_combo.currentText() == "ì•™ìƒë¸” (ì „ì²´)":
                # ëª¨ë“  ëª¨ë¸ ì‚¬ìš©
                selected_models = list(self.loaded_models.keys())
            else:
                # ì„ íƒëœ ëª¨ë¸ë§Œ ì‚¬ìš©
                selected_items = self.model_list_widget.selectedItems()
                selected_models = [item.text() for item in selected_items]
                
                if not selected_models:
                    QMessageBox.warning(self, "ê²½ê³ ", "ì˜ˆì¸¡í•  ëª¨ë¸ì„ ì„ íƒí•˜ì„¸ìš”")
                    return
            
            # ì˜ˆì¸¡ ìˆ˜í–‰
            predictions = []
            
            for model_name in selected_models:
                if model_name in self.loaded_models:
                    model = self.loaded_models[model_name]['model']
                    pred = model.predict(X_test, verbose=0)
                    predictions.append(pred.flatten())
                    self.update_status(f"{model_name} ì˜ˆì¸¡ ì™„ë£Œ")
            
            # ì•™ìƒë¸” (í‰ê· )
            if len(predictions) > 1:
                ensemble_pred = np.mean(predictions, axis=0)
                self.update_status(f"ì•™ìƒë¸” ì˜ˆì¸¡ ì™„ë£Œ ({len(predictions)}ê°œ ëª¨ë¸)")
            else:
                ensemble_pred = predictions[0]
            
            # ì—­ìŠ¤ì¼€ì¼ë§
            if self.scaler:
                n_features = self.scaler.n_features_in_
                dummy = np.zeros((len(ensemble_pred), n_features))
                dummy[:, 0] = ensemble_pred
                pred_original = self.scaler.inverse_transform(dummy)[:, 0]
                
                dummy_y = np.zeros((len(y_test), n_features))
                dummy_y[:, 0] = y_test
                y_original = self.scaler.inverse_transform(dummy_y)[:, 0]
            else:
                pred_original = ensemble_pred
                y_original = y_test
            
            # ì‹œê°„ ìƒì„±
            if 'processed_df' in self.current_data:
                df = self.current_data['processed_df']
                times = df.index[-len(pred_original):]
            else:
                times = pd.date_range(start='2025-07-01', periods=len(pred_original), freq='T')
            
            # ì˜ˆì¸¡ ê²°ê³¼ ì—…ë°ì´íŠ¸
            self.prediction_widget.update_predictions(pred_original, y_original, times)
            
            # ì„±ëŠ¥ ë©”íŠ¸ë¦­
            mae = mean_absolute_error(y_original, pred_original)
            mse = mean_squared_error(y_original, pred_original)
            r2 = r2_score(y_original, pred_original)
            
            # ë³‘ëª© ì˜ˆì¸¡ ì •í™•ë„
            bottleneck_threshold = 2000
            bottleneck_accuracy = np.mean((pred_original > bottleneck_threshold) == (y_original > bottleneck_threshold))
            
            self.update_status(f"ì˜ˆì¸¡ ì™„ë£Œ - MAE: {mae:.2f}, RÂ²: {r2:.4f}, ë³‘ëª©ì •í™•ë„: {bottleneck_accuracy:.1%}")
            
        except Exception as e:
            QMessageBox.critical(self, "ì˜¤ë¥˜", f"ì˜ˆì¸¡ ì‹¤íŒ¨: {str(e)}")
            self.update_status("ì˜ˆì¸¡ ì‹¤íŒ¨")
            
    def evaluate_models(self):
        """ëª¨ë¸ í‰ê°€"""
        if not self.loaded_models:
            QMessageBox.warning(self, "ê²½ê³ ", "ë¨¼ì € ëª¨ë¸ì„ ë¶ˆëŸ¬ì˜¤ì„¸ìš”")
            return
            
        if self.current_data is None or 'X_test' not in self.current_data:
            QMessageBox.warning(self, "ê²½ê³ ", "ë¨¼ì € ë°ì´í„°ë¥¼ ì „ì²˜ë¦¬í•˜ì„¸ìš”")
            return
            
        try:
            self.update_status("ëª¨ë¸ í‰ê°€ ì¤‘...")
            
            evaluator = ModelPercentEvaluator()
            evaluator.scaler = self.scaler
            
            X_test = self.current_data['X_test']
            y_test = self.current_data['y_test']
            
            # ì—­ìŠ¤ì¼€ì¼ë§
            if self.scaler:
                n_features = self.scaler.n_features_in_
                dummy_y = np.zeros((len(y_test), n_features))
                dummy_y[:, 0] = y_test
                y_original = self.scaler.inverse_transform(dummy_y)[:, 0]
            else:
                y_original = y_test
            
            # í‰ê°€ ê²°ê³¼ ì €ì¥
            results = []
            
            for model_name, model_info in self.loaded_models.items():
                model = model_info['model']
                
                # ì˜ˆì¸¡
                pred = model.predict(X_test, verbose=0).flatten()
                
                if self.scaler:
                    dummy_pred = np.zeros((len(pred), n_features))
                    dummy_pred[:, 0] = pred
                    pred_original = self.scaler.inverse_transform(dummy_pred)[:, 0]
                else:
                    pred_original = pred
                
                # í‰ê°€ ë©”íŠ¸ë¦­
                mape = evaluator.calculate_mape(y_original, pred_original)
                acc_10 = evaluator.calculate_accuracy_within_threshold(y_original, pred_original, 10)
                r2 = r2_score(y_original, pred_original) * 100
                dir_acc = evaluator.calculate_directional_accuracy(y_original, pred_original)
                
                bottleneck_metrics = evaluator.calculate_bottleneck_accuracy(
                    y_original, pred_original, 2000
                )
                
                # ì¢…í•© ì ìˆ˜
                overall_score = (
                    (100 - min(mape, 100)) * 0.2 +
                    acc_10 * 0.3 +
                    r2 * 0.2 +
                    dir_acc * 0.15 +
                    bottleneck_metrics['accuracy'] * 0.15
                )
                
                # ë“±ê¸‰
                if overall_score >= 90:
                    grade = "A+"
                elif overall_score >= 85:
                    grade = "A"
                elif overall_score >= 80:
                    grade = "B+"
                elif overall_score >= 75:
                    grade = "B"
                elif overall_score >= 70:
                    grade = "C+"
                else:
                    grade = "C"
                
                results.append({
                    'model': model_name,
                    'mape': mape,
                    'acc_10': acc_10,
                    'r2': r2,
                    'dir_acc': dir_acc,
                    'bottleneck_acc': bottleneck_metrics['accuracy'],
                    'bottleneck_f1': bottleneck_metrics['f1_score'],
                    'overall_score': overall_score,
                    'grade': grade
                })
                
                self.update_status(f"{model_name} í‰ê°€ ì™„ë£Œ")
            
            # í…Œì´ë¸” ì—…ë°ì´íŠ¸
            self.eval_table.setRowCount(len(results))
            for i, res in enumerate(results):
                self.eval_table.setItem(i, 0, QTableWidgetItem(res['model']))
                self.eval_table.setItem(i, 1, QTableWidgetItem(f"{res['mape']:.2f}"))
                self.eval_table.setItem(i, 2, QTableWidgetItem(f"{res['acc_10']:.1f}"))
                self.eval_table.setItem(i, 3, QTableWidgetItem(f"{res['r2']:.1f}"))
                self.eval_table.setItem(i, 4, QTableWidgetItem(f"{res['dir_acc']:.1f}"))
                self.eval_table.setItem(i, 5, QTableWidgetItem(f"{res['bottleneck_acc']:.1f}"))
                self.eval_table.setItem(i, 6, QTableWidgetItem(f"{res['bottleneck_f1']:.1f}"))
                self.eval_table.setItem(i, 7, QTableWidgetItem(f"{res['overall_score']:.1f}"))
                self.eval_table.setItem(i, 8, QTableWidgetItem(res['grade']))
            
            # ìµœê³  ì„±ëŠ¥ ëª¨ë¸
            best_model = max(results, key=lambda x: x['overall_score'])
            detail = f"ğŸ“Š í‰ê°€ ì™„ë£Œ - {len(results)}ê°œ ëª¨ë¸\n\n"
            detail += f"ğŸ† ìµœê³  ì„±ëŠ¥ ëª¨ë¸: {best_model['model']}\n"
            detail += f"   ì¢…í•© ì ìˆ˜: {best_model['overall_score']:.1f}%\n"
            detail += f"   ì„±ëŠ¥ ë“±ê¸‰: {best_model['grade']}\n"
            detail += f"   MAPE: {best_model['mape']:.2f}%\n"
            detail += f"   ë³‘ëª© ì •í™•ë„: {best_model['bottleneck_acc']:.1f}%"
            
            self.eval_detail_text.setText(detail)
            self.update_status("ëª¨ë¸ í‰ê°€ ì™„ë£Œ")
            
        except Exception as e:
            QMessageBox.critical(self, "ì˜¤ë¥˜", f"í‰ê°€ ì‹¤íŒ¨: {str(e)}")
            self.update_status("í‰ê°€ ì‹¤íŒ¨")
            
    def create_visualization(self):
        """ì‹œê°í™” ìƒì„±"""
        viz_type = self.viz_type_combo.currentText()
        
        self.viz_figure.clear()
        
        if viz_type == "ì˜ˆì¸¡ vs ì‹¤ì œ" and self.current_data and 'X_test' in self.current_data:
            self.create_prediction_plot()
        elif viz_type == "ì˜¤ì°¨ ë¶„í¬" and self.current_data and 'X_test' in self.current_data:
            self.create_error_distribution_plot()
        elif viz_type == "ë³‘ëª© êµ¬ê°„ íˆíŠ¸ë§µ" and self.current_data and 'X_test' in self.current_data:
            self.create_bottleneck_heatmap()
        elif viz_type == "ëª¨ë¸ë³„ ì„±ëŠ¥ ë¹„êµ" and self.loaded_models:
            self.create_performance_comparison()
        elif viz_type == "ì‹œê³„ì—´ ë¶„í•´":
            self.create_time_series_decomposition()
        else:
            ax = self.viz_figure.add_subplot(111)
            ax.text(0.5, 0.5, 'ë°ì´í„°ê°€ ì—†ê±°ë‚˜ ëª¨ë¸ì´ ë¡œë“œë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤', 
                   ha='center', va='center', fontsize=12)
        
        self.viz_canvas.draw()
        
    def create_prediction_plot(self):
        """ì˜ˆì¸¡ vs ì‹¤ì œ í”Œë¡¯"""
        if not self.loaded_models:
            return
            
        # ì²« ë²ˆì§¸ ëª¨ë¸ ì‚¬ìš©
        model_name = list(self.loaded_models.keys())[0]
        model = self.loaded_models[model_name]['model']
        
        X_test = self.current_data['X_test'][:200]  # ìƒ˜í”Œ
        y_test = self.current_data['y_test'][:200]
        
        pred = model.predict(X_test, verbose=0).flatten()
        
        # ì—­ìŠ¤ì¼€ì¼ë§
        if self.scaler:
            n_features = self.scaler.n_features_in_
            
            dummy_pred = np.zeros((len(pred), n_features))
            dummy_pred[:, 0] = pred
            pred_original = self.scaler.inverse_transform(dummy_pred)[:, 0]
            
            dummy_y = np.zeros((len(y_test), n_features))
            dummy_y[:, 0] = y_test
            y_original = self.scaler.inverse_transform(dummy_y)[:, 0]
        else:
            pred_original = pred
            y_original = y_test
        
        ax = self.viz_figure.add_subplot(111)
        
        x_range = range(len(y_original))
        ax.plot(x_range, y_original, label='ì‹¤ì œê°’', color='blue', linewidth=2, alpha=0.7)
        ax.plot(x_range, pred_original, label=f'ì˜ˆì¸¡ê°’ ({model_name})', color='red', linewidth=1.5, alpha=0.7)
        ax.axhline(y=2000, color='orange', linestyle='--', label='ë³‘ëª© ì„ê³„ê°’', alpha=0.5)
        
        ax.set_title('ì˜ˆì¸¡ vs ì‹¤ì œ ë¹„êµ', fontsize=14)
        ax.set_xlabel('ì‹œê°„ ì¸ë±ìŠ¤', fontsize=12)
        ax.set_ylabel('ë¬¼ë¥˜ëŸ‰', fontsize=12)
        ax.legend()
        ax.grid(True, alpha=0.3)
        
    def create_error_distribution_plot(self):
        """ì˜¤ì°¨ ë¶„í¬ í”Œë¡¯"""
        if not self.loaded_models:
            return
            
        ax = self.viz_figure.add_subplot(111)
        
        for model_name, model_info in self.loaded_models.items():
            model = model_info['model']
            
            X_test = self.current_data['X_test']
            y_test = self.current_data['y_test']
            
            pred = model.predict(X_test, verbose=0).flatten()
            
            # ì—­ìŠ¤ì¼€ì¼ë§
            if self.scaler:
                n_features = self.scaler.n_features_in_
                
                dummy_pred = np.zeros((len(pred), n_features))
                dummy_pred[:, 0] = pred
                pred_original = self.scaler.inverse_transform(dummy_pred)[:, 0]
                
                dummy_y = np.zeros((len(y_test), n_features))
                dummy_y[:, 0] = y_test
                y_original = self.scaler.inverse_transform(dummy_y)[:, 0]
            else:
                pred_original = pred
                y_original = y_test
            
            errors = pred_original - y_original
            ax.hist(errors, bins=50, alpha=0.5, label=model_name)
        
        ax.set_title('ëª¨ë¸ë³„ ì˜¤ì°¨ ë¶„í¬', fontsize=14)
        ax.set_xlabel('ì˜¤ì°¨', fontsize=12)
        ax.set_ylabel('ë¹ˆë„', fontsize=12)
        ax.legend()
        ax.grid(True, alpha=0.3)
        
    def create_bottleneck_heatmap(self):
        """ë³‘ëª© êµ¬ê°„ íˆíŠ¸ë§µ"""
        # êµ¬í˜„ ì˜ˆì •
        ax = self.viz_figure.add_subplot(111)
        ax.text(0.5, 0.5, 'ë³‘ëª© êµ¬ê°„ íˆíŠ¸ë§µ (êµ¬í˜„ ì˜ˆì •)', ha='center', va='center')
        
    def create_performance_comparison(self):
        """ëª¨ë¸ë³„ ì„±ëŠ¥ ë¹„êµ"""
        # êµ¬í˜„ ì˜ˆì •
        ax = self.viz_figure.add_subplot(111)
        ax.text(0.5, 0.5, 'ëª¨ë¸ë³„ ì„±ëŠ¥ ë¹„êµ (êµ¬í˜„ ì˜ˆì •)', ha='center', va='center')
        
    def create_time_series_decomposition(self):
        """ì‹œê³„ì—´ ë¶„í•´"""
        # êµ¬í˜„ ì˜ˆì •
        ax = self.viz_figure.add_subplot(111)
        ax.text(0.5, 0.5, 'ì‹œê³„ì—´ ë¶„í•´ (êµ¬í˜„ ì˜ˆì •)', ha='center', va='center')
        
    def save_visualization(self):
        """ì‹œê°í™” ì €ì¥"""
        filename, _ = QFileDialog.getSaveFileName(
            self, "ì°¨íŠ¸ ì €ì¥", "",
            "PNG Files (*.png);;JPG Files (*.jpg);;PDF Files (*.pdf)"
        )
        if filename:
            self.viz_figure.savefig(filename, dpi=300, bbox_inches='tight')
            self.update_status(f"ì°¨íŠ¸ ì €ì¥ ì™„ë£Œ: {filename}")
            
    def export_evaluation_results(self):
        """í‰ê°€ ê²°ê³¼ ë‚´ë³´ë‚´ê¸°"""
        filename, _ = QFileDialog.getSaveFileName(
            self, "í‰ê°€ ê²°ê³¼ ë‚´ë³´ë‚´ê¸°", "",
            "CSV Files (*.csv);;Excel Files (*.xlsx)"
        )
        
        if filename:
            # í…Œì´ë¸” ë°ì´í„°ë¥¼ DataFrameìœ¼ë¡œ ë³€í™˜
            data = []
            for row in range(self.eval_table.rowCount()):
                row_data = []
                for col in range(self.eval_table.columnCount()):
                    item = self.eval_table.item(row, col)
                    row_data.append(item.text() if item else "")
                data.append(row_data)
            
            df = pd.DataFrame(data, columns=[
                'ëª¨ë¸', 'MAPE(%)', 'ì •í™•ë„(10%)', 'RÂ² Score', 
                'ë°©í–¥ì„± ì •í™•ë„', 'ë³‘ëª© ì •í™•ë„', 'ë³‘ëª© F1', 'ì¢…í•© ì ìˆ˜', 'ë“±ê¸‰'
            ])
            
            if filename.endswith('.csv'):
                df.to_csv(filename, index=False)
            else:
                df.to_excel(filename, index=False)
            
            self.update_status(f"í‰ê°€ ê²°ê³¼ ë‚´ë³´ë‚´ê¸° ì™„ë£Œ: {filename}")
            
    def show_about(self):
        """í”„ë¡œê·¸ë¨ ì •ë³´"""
        about_text = """
ë°˜ë„ì²´ FAB ë¬¼ë¥˜ ì˜ˆì¸¡ í•˜ì´ë¸Œë¦¬ë“œ ë”¥ëŸ¬ë‹ ì‹œìŠ¤í…œ

ë²„ì „: 3.2 (í•œê¸€ í°íŠ¸ ì§€ì›)
ê°œë°œ: 2024

íŠ¹ì§•:
- ê¸°ì¡´ í•™ìŠµëœ ëª¨ë¸ ë¶ˆëŸ¬ì˜¤ê¸° ë° í™œìš©
- LSTM, RNN, GRU, Bi-LSTM í†µí•© í•˜ì´ë¸Œë¦¬ë“œ ëª¨ë¸
- CPU ê¸°ë°˜ ì‹¤í–‰ ì§€ì›
- ì‹¤ì‹œê°„ ë³‘ëª© êµ¬ê°„ ì˜ˆì¸¡
- 10ë¶„ í›„ ë¬¼ë¥˜ëŸ‰ ì˜ˆì¸¡
- í¼ì„¼íŠ¸ ê¸°ë°˜ ì„±ëŠ¥ í‰ê°€
- í•œê¸€ í°íŠ¸ ìë™ ê°ì§€ ë° ì„¤ì •

ë³¸ ì‹œìŠ¤í…œì€ ë°˜ë„ì²´ ì œì¡° ê³µì •ì˜ ë¬¼ë¥˜ íë¦„ì„
ë”¥ëŸ¬ë‹ìœ¼ë¡œ ì˜ˆì¸¡í•˜ì—¬ ìƒì‚°ì„±ì„ í–¥ìƒì‹œí‚µë‹ˆë‹¤.
        """
        QMessageBox.about(self, "í”„ë¡œê·¸ë¨ ì •ë³´", about_text)
        
    def show_font_info(self):
        """í°íŠ¸ ì •ë³´ í‘œì‹œ"""
        font_info = "í˜„ì¬ Matplotlib í°íŠ¸ ì„¤ì •:\n\n"
        font_info += f"Font Family: {plt.rcParams['font.family']}\n"
        font_info += f"Sans-serif: {plt.rcParams['font.sans-serif']}\n"
        font_info += f"Unicode Minus: {plt.rcParams['axes.unicode_minus']}\n\n"
        
        if KOREAN_FONT_AVAILABLE:
            font_info += "âœ“ í•œê¸€ í°íŠ¸ê°€ ì •ìƒì ìœ¼ë¡œ ì„¤ì •ë˜ì—ˆìŠµë‹ˆë‹¤."
        else:
            font_info += "âš  í•œê¸€ í°íŠ¸ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.\n"
            font_info += "NanumGothic í°íŠ¸ ì„¤ì¹˜ë¥¼ ê¶Œì¥í•©ë‹ˆë‹¤."
        
        QMessageBox.information(self, "í°íŠ¸ ì •ë³´", font_info)
        
    def update_status(self, message):
        """ìƒíƒœ ì—…ë°ì´íŠ¸"""
        self.status_label.setText(f"ìƒíƒœ: {message}")
        QApplication.processEvents()


def main():
    app = QApplication(sys.argv)
    
    # ì• í”Œë¦¬ì¼€ì´ì…˜ ìŠ¤íƒ€ì¼ ì„¤ì •
    app.setStyle("Fusion")
    
    # ë‹¤í¬ íŒ”ë ˆíŠ¸
    palette = QPalette()
    palette.setColor(QPalette.Window, QColor(30, 30, 30))
    palette.setColor(QPalette.WindowText, Qt.white)
    palette.setColor(QPalette.Base, QColor(45, 45, 45))
    palette.setColor(QPalette.AlternateBase, QColor(60, 60, 60))
    palette.setColor(QPalette.ToolTipBase, Qt.black)
    palette.setColor(QPalette.ToolTipText, Qt.white)
    palette.setColor(QPalette.Text, Qt.white)
    palette.setColor(QPalette.Button, QColor(45, 45, 45))
    palette.setColor(QPalette.ButtonText, Qt.white)
    palette.setColor(QPalette.BrightText, Qt.red)
    palette.setColor(QPalette.Link, QColor(42, 130, 218))
    palette.setColor(QPalette.Highlight, QColor(42, 130, 218))
    palette.setColor(QPalette.HighlightedText, Qt.black)
    app.setPalette(palette)
    
    # ë©”ì¸ ìœˆë„ìš° ì‹¤í–‰
    window = MainWindow()
    window.show()
    
    sys.exit(app.exec_())


if __name__ == "__main__":
    main()