import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
from datetime import datetime, timedelta
import tensorflow as tf
from sklearn.preprocessing import StandardScaler
from sklearn.metrics import mean_absolute_error, mean_squared_error, r2_score
import pickle
import os
import warnings
warnings.filterwarnings('ignore')

# í•œê¸€ í°íŠ¸ ì„¤ì •
plt.rcParams['font.family'] = 'Malgun Gothic'
plt.rcParams['axes.unicode_minus'] = False

class HUBROOMEvaluator:
    """HUBROOM ì˜ˆì¸¡ ëª¨ë¸ í‰ê°€ í´ë˜ìŠ¤"""
    
    def __init__(self, data_path='202509.csv'):
        self.data_path = data_path
        self.seq_len = 20
        self.pred_len = 10
        self.target_col = 'CURRENT_M16A_3F_JOB_2'
        self.critical_threshold = 300
        
        # ëª¨ë¸ ê²½ë¡œ
        self.patchtst_path = './checkpoints/PatchTST_best.h5'
        self.pinn_path = './checkpoints/PatchTST_PINN_best.h5'
        
        # ìŠ¤ì¼€ì¼ëŸ¬ ë¡œë“œ
        self.scaler_X = self.load_scaler('scaler_X.pkl')
        self.scaler_y = self.load_scaler('scaler_y.pkl')
        self.scaler_physics = self.load_scaler('scaler_physics.pkl')
        
        # ë¬¼ë¦¬ ì»¬ëŸ¼
        self.inflow_cols = [
            'M16A_6F_TO_HUB_JOB', 'M16A_2F_TO_HUB_JOB2',
            'M14A_3F_TO_HUB_JOB2', 'M14B_7F_TO_HUB_JOB2'
        ]
        self.outflow_cols = [
            'M16A_3F_TO_M16A_6F_JOB', 'M16A_3F_TO_M16A_2F_JOB',
            'M16A_3F_TO_M14A_3F_JOB', 'M16A_3F_TO_M14B_7F_JOB'
        ]
    
    def load_scaler(self, filename):
        """ìŠ¤ì¼€ì¼ëŸ¬ ë¡œë“œ"""
        filepath = f'./checkpoints/{filename}'
        if os.path.exists(filepath):
            with open(filepath, 'rb') as f:
                print(f"âœ… {filename} ë¡œë“œ ì™„ë£Œ")
                return pickle.load(f)
        else:
            print(f"âš ï¸ {filename}ì´ ì—†ìŠµë‹ˆë‹¤. save_scalers.pyë¥¼ ë¨¼ì € ì‹¤í–‰í•˜ì„¸ìš”!")
            return None
    
    def prepare_data(self):
        """2025ë…„ 9ì›” ë°ì´í„° ì¤€ë¹„"""
        print("ğŸ“‚ 2025ë…„ 9ì›” ë°ì´í„° ë¡œë“œ ì¤‘...")
        df = pd.read_csv(self.data_path)
        
        # ì‹œê°„ ì»¬ëŸ¼ ì²˜ë¦¬
        time_col = df.columns[0]
        df['timestamp'] = pd.to_datetime(df[time_col], format='%Y%m%d%H%M', errors='coerce')
        df = df.sort_values('timestamp').reset_index(drop=True)
        
        # ê²°ì¸¡ì¹˜ ì²˜ë¦¬
        df = df.fillna(method='ffill').fillna(0)
        
        # ìˆ«ìí˜• ì»¬ëŸ¼ë§Œ ì„ íƒ
        numeric_cols = df.select_dtypes(include=[np.number]).columns.tolist()
        
        print(f"âœ… ë°ì´í„° ë¡œë“œ ì™„ë£Œ: {len(df)} í–‰")
        print(f"ğŸ“… ê¸°ê°„: {df['timestamp'].min()} ~ {df['timestamp'].max()}")
        
        return df, numeric_cols
    
    def create_evaluation_sequences(self, df, numeric_cols):
        """í‰ê°€ìš© ì‹œí€€ìŠ¤ ìƒì„±"""
        X_list = []
        y_actual_list = []
        y_time_list = []
        physics_list = []
        timestamps = []
        
        data = df[numeric_cols].values
        target_idx = numeric_cols.index(self.target_col)
        
        # ì‚¬ìš© ê°€ëŠ¥í•œ ì»¬ëŸ¼ í™•ì¸
        available_inflow = [col for col in self.inflow_cols if col in numeric_cols]
        available_outflow = [col for col in self.outflow_cols if col in numeric_cols]
        
        print(f"\nğŸ“Š ì‹œí€€ìŠ¤ ìƒì„± ì¤‘...")
        total_sequences = len(data) - self.seq_len - self.pred_len + 1
        
        # ì‹œí€€ìŠ¤ ìƒì„±
        for i in range(total_sequences):
            # ì…ë ¥ ì‹œí€€ìŠ¤ (ê³¼ê±° 20ë¶„)
            X_seq = data[i:i+self.seq_len]
            
            # ì‹¤ì œ ê°’ (ë¯¸ë˜ 10ë¶„)
            y_actual = data[i+self.seq_len:i+self.seq_len+self.pred_len, target_idx]
            
            # íƒ€ì„ìŠ¤íƒ¬í”„
            start_time = df['timestamp'].iloc[i+self.seq_len-1]
            pred_times = [start_time + timedelta(minutes=j+1) for j in range(self.pred_len)]
            
            # ë¬¼ë¦¬ ë°ì´í„° (í˜„ì¬ ìƒíƒœ)
            current_state = data[i+self.seq_len-1]
            current_hubroom = current_state[target_idx]
            
            inflow_sum = sum([current_state[numeric_cols.index(col)] 
                            for col in available_inflow])
            outflow_sum = sum([current_state[numeric_cols.index(col)] 
                             for col in available_outflow])
            
            physics = np.array([current_hubroom, inflow_sum, outflow_sum])
            
            X_list.append(X_seq)
            y_actual_list.append(y_actual)
            y_time_list.append(pred_times)
            physics_list.append(physics)
            timestamps.append(start_time)
        
        print(f"âœ… ì‹œí€€ìŠ¤ ìƒì„± ì™„ë£Œ: {len(X_list)}ê°œ")
        
        return (np.array(X_list), np.array(y_actual_list), 
                np.array(physics_list), timestamps, y_time_list)
    
    def load_models(self):
        """í•™ìŠµëœ ëª¨ë¸ ë¡œë“œ"""
        print("\nğŸ¤– ëª¨ë¸ ë¡œë“œ ì¤‘...")
        
        models = {}
        
        # PatchTST ëª¨ë¸ ë¡œë“œ
        if os.path.exists(self.patchtst_path):
            try:
                models['PatchTST'] = tf.keras.models.load_model(
                    self.patchtst_path,
                    compile=False
                )
                print("âœ… PatchTST ëª¨ë¸ ë¡œë“œ ì™„ë£Œ")
            except:
                # ê°€ì¤‘ì¹˜ë§Œ ë¡œë“œí•˜ëŠ” ë°©ì‹ ì‹œë„
                print("âš ï¸ ì „ì²´ ëª¨ë¸ ë¡œë“œ ì‹¤íŒ¨, ê°€ì¤‘ì¹˜ë§Œ ë¡œë“œ ì‹œë„...")
        else:
            print("âŒ PatchTST ëª¨ë¸ íŒŒì¼ì´ ì—†ìŠµë‹ˆë‹¤.")
        
        # PatchTST+PINN ëª¨ë¸ ë¡œë“œ
        if os.path.exists(self.pinn_path):
            try:
                models['PatchTST_PINN'] = tf.keras.models.load_model(
                    self.pinn_path,
                    compile=False
                )
                print("âœ… PatchTST+PINN ëª¨ë¸ ë¡œë“œ ì™„ë£Œ")
            except:
                print("âš ï¸ ì „ì²´ ëª¨ë¸ ë¡œë“œ ì‹¤íŒ¨, ê°€ì¤‘ì¹˜ë§Œ ë¡œë“œ ì‹œë„...")
        else:
            print("âŒ PatchTST+PINN ëª¨ë¸ íŒŒì¼ì´ ì—†ìŠµë‹ˆë‹¤.")
        
        return models
    
    def predict_and_evaluate(self, models, X, y_actual, physics_data, timestamps):
        """ëª¨ë¸ë³„ ì˜ˆì¸¡ ë° í‰ê°€"""
        results = {}
        
        # ë°ì´í„° ì •ê·œí™”
        n_samples, seq_len, n_features = X.shape
        
        # ìŠ¤ì¼€ì¼ëŸ¬ í™•ì¸
        if self.scaler_X is None or self.scaler_y is None:
            print("âŒ ìŠ¤ì¼€ì¼ëŸ¬ê°€ ë¡œë“œë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤!")
            return results
        
        X_scaled = self.scaler_X.transform(X.reshape(-1, n_features)).reshape(n_samples, seq_len, n_features)
        physics_scaled = self.scaler_physics.transform(physics_data) if self.scaler_physics else physics_data
        
        for model_name, model in models.items():
            print(f"\n{'='*60}")
            print(f"ğŸ“Š {model_name} ëª¨ë¸ í‰ê°€")
            print(f"{'='*60}")
            
            try:
                # ì˜ˆì¸¡
                if model_name == 'PatchTST_PINN':
                    # PINN ëª¨ë¸ì€ ë¬¼ë¦¬ ë°ì´í„°ë„ í•„ìš”
                    y_pred_scaled = model.predict([X_scaled, physics_scaled], verbose=0)
                else:
                    # PatchTSTëŠ” ì‹œí€€ìŠ¤ ë°ì´í„°ë§Œ
                    y_pred_scaled = model.predict(X_scaled, verbose=0)
                
                # ì—­ì •ê·œí™” (10ë¶„ í›„ ì˜ˆì¸¡ê°’)
                y_pred_10min = self.scaler_y.inverse_transform(
                    y_pred_scaled.reshape(-1, 1)
                ).flatten()
                
                # ì‹¤ì œê°’ì€ 10ë¶„ í›„ ê°’ë§Œ ì¶”ì¶œ
                y_true_10min = y_actual[:, -1]  # ë§ˆì§€ë§‰ ì‹œì  (10ë¶„ í›„)
                
                # ë©”íŠ¸ë¦­ ê³„ì‚°
                mae = mean_absolute_error(y_true_10min, y_pred_10min)
                mse = mean_squared_error(y_true_10min, y_pred_10min)
                rmse = np.sqrt(mse)
                r2 = r2_score(y_true_10min, y_pred_10min)
                
                # 300 ì´ìƒ ì˜ˆì¸¡ ë¶„ì„
                over_300_pred = np.sum(y_pred_10min >= 300)
                over_300_true = np.sum(y_true_10min >= 300)
                
                # 300 ì´ìƒì¼ ë•Œì˜ ì •í™•ë„
                mask_300 = y_true_10min >= 300
                if np.sum(mask_300) > 0:
                    mae_300 = mean_absolute_error(y_true_10min[mask_300], y_pred_10min[mask_300])
                    acc_300 = np.sum((y_pred_10min >= 300) & (y_true_10min >= 300)) / np.sum(mask_300)
                else:
                    mae_300 = 0
                    acc_300 = 0
                
                # ê²°ê³¼ ì €ì¥
                results[model_name] = {
                    'y_true': y_true_10min,
                    'y_pred': y_pred_10min,
                    'timestamps': timestamps,
                    'mae': mae,
                    'mse': mse,
                    'rmse': rmse,
                    'r2': r2,
                    'over_300_pred': over_300_pred,
                    'over_300_true': over_300_true,
                    'mae_300': mae_300,
                    'acc_300': acc_300
                }
                
                # ì„±ëŠ¥ ì¶œë ¥
                print(f"\nğŸ“ˆ ì „ì²´ ì„±ëŠ¥:")
                print(f"  - MAE: {mae:.4f}")
                print(f"  - RMSE: {rmse:.4f}")
                print(f"  - RÂ²: {r2:.4f}")
                
                print(f"\nğŸš¨ 300 ì´ìƒ ì˜ˆì¸¡ ë¶„ì„:")
                print(f"  - ì‹¤ì œ 300 ì´ìƒ: {over_300_true}ê°œ")
                print(f"  - ì˜ˆì¸¡ 300 ì´ìƒ: {over_300_pred}ê°œ")
                print(f"  - 300 ì´ìƒì¼ ë•Œ MAE: {mae_300:.4f}")
                print(f"  - 300 ê°ì§€ ì •í™•ë„: {acc_300:.2%}")
                
                # ìƒ˜í”Œ ì¶œë ¥
                print(f"\nğŸ“ ì˜ˆì¸¡ ìƒ˜í”Œ (ì²˜ìŒ 10ê°œ):")
                for i in range(min(10, len(y_pred_10min))):
                    status = "âš ï¸ ê²½ê³ " if y_pred_10min[i] >= 300 else "âœ… ì •ìƒ"
                    print(f"  [{i+1}] ì‹¤ì œ: {y_true_10min[i]:.1f}, ì˜ˆì¸¡: {y_pred_10min[i]:.1f} {status}")
                
            except Exception as e:
                print(f"âŒ {model_name} ì˜ˆì¸¡ ì¤‘ ì˜¤ë¥˜ ë°œìƒ: {e}")
                continue
        
        return results
    
    def visualize_results(self, results):
        """ê²°ê³¼ ì‹œê°í™”"""
        if not results:
            print("ì‹œê°í™”í•  ê²°ê³¼ê°€ ì—†ìŠµë‹ˆë‹¤.")
            return
        
        # ëª¨ë¸ë³„ ë¹„êµ ê·¸ë˜í”„
        fig, axes = plt.subplots(2, 2, figsize=(15, 10))
        fig.suptitle('HUBROOM ë°˜ì†¡ëŸ‰ ì˜ˆì¸¡ ëª¨ë¸ ë¹„êµ (2025ë…„ 9ì›”)', fontsize=16)
        
        # 1. ì‹œê³„ì—´ ì˜ˆì¸¡ ë¹„êµ (ì²˜ìŒ 100ê°œ)
        ax1 = axes[0, 0]
        for model_name, result in results.items():
            ax1.plot(result['y_true'][:100], label=f'ì‹¤ì œê°’', alpha=0.7, linewidth=2)
            ax1.plot(result['y_pred'][:100], label=f'{model_name} ì˜ˆì¸¡', alpha=0.7, linestyle='--')
        ax1.axhline(y=300, color='red', linestyle=':', label='ìœ„í—˜ ì„ê³„ê°’ (300)')
        ax1.set_title('ì‹œê³„ì—´ ì˜ˆì¸¡ ë¹„êµ (ì²˜ìŒ 100ê°œ)')
        ax1.set_xlabel('ì‹œê°„ ì¸ë±ìŠ¤')
        ax1.set_ylabel('HUBROOM ë°˜ì†¡ëŸ‰')
        ax1.legend()
        ax1.grid(True, alpha=0.3)
        
        # 2. ì‚°ì ë„
        ax2 = axes[0, 1]
        colors = ['blue', 'green', 'orange']
        for idx, (model_name, result) in enumerate(results.items()):
            ax2.scatter(result['y_true'], result['y_pred'], 
                       alpha=0.5, label=model_name, color=colors[idx % len(colors)])
        ax2.plot([0, 600], [0, 600], 'r--', alpha=0.5, label='Perfect Prediction')
        ax2.axvline(x=300, color='red', linestyle=':', alpha=0.5)
        ax2.axhline(y=300, color='red', linestyle=':', alpha=0.5)
        ax2.set_title('ì˜ˆì¸¡ê°’ vs ì‹¤ì œê°’')
        ax2.set_xlabel('ì‹¤ì œê°’')
        ax2.set_ylabel('ì˜ˆì¸¡ê°’')
        ax2.legend()
        ax2.grid(True, alpha=0.3)
        
        # 3. ì˜¤ì°¨ ë¶„í¬
        ax3 = axes[1, 0]
        for model_name, result in results.items():
            errors = result['y_pred'] - result['y_true']
            ax3.hist(errors, bins=50, alpha=0.5, label=f'{model_name} (MAE: {result["mae"]:.2f})')
        ax3.set_title('ì˜ˆì¸¡ ì˜¤ì°¨ ë¶„í¬')
        ax3.set_xlabel('ì˜ˆì¸¡ ì˜¤ì°¨')
        ax3.set_ylabel('ë¹ˆë„')
        ax3.legend()
        ax3.grid(True, alpha=0.3)
        
        # 4. ì„±ëŠ¥ ë©”íŠ¸ë¦­ ë¹„êµ
        ax4 = axes[1, 1]
        metrics = ['MAE', 'RMSE', 'RÂ²', 'MAE@300+']
        model_names = list(results.keys())
        
        x = np.arange(len(metrics))
        width = 0.35
        
        for idx, model_name in enumerate(model_names):
            values = [
                results[model_name]['mae'],
                results[model_name]['rmse'],
                results[model_name]['r2'] * 100,  # RÂ²ë¥¼ ë°±ë¶„ìœ¨ë¡œ
                results[model_name]['mae_300']
            ]
            ax4.bar(x + idx * width, values, width, label=model_name)
        
        ax4.set_title('ëª¨ë¸ ì„±ëŠ¥ ë©”íŠ¸ë¦­ ë¹„êµ')
        ax4.set_xlabel('ë©”íŠ¸ë¦­')
        ax4.set_ylabel('ê°’')
        ax4.set_xticks(x + width / 2)
        ax4.set_xticklabels(metrics)
        ax4.legend()
        ax4.grid(True, alpha=0.3)
        
        plt.tight_layout()
        plt.savefig('hubroom_evaluation_202509.png', dpi=300, bbox_inches='tight')
        plt.show()
        
        # 300 ì´ìƒ ì˜ˆì¸¡ ìƒì„¸ ë¶„ì„
        self.analyze_critical_predictions(results)
    
    def analyze_critical_predictions(self, results):
        """300 ì´ìƒ ì˜ˆì¸¡ ìƒì„¸ ë¶„ì„"""
        print("\n" + "="*60)
        print("ğŸš¨ 300 ì´ìƒ ì˜ˆì¸¡ ìƒì„¸ ë¶„ì„")
        print("="*60)
        
        for model_name, result in results.items():
            print(f"\nğŸ“Š {model_name} ëª¨ë¸:")
            
            y_true = result['y_true']
            y_pred = result['y_pred']
            
            # 300 ì´ìƒ ì¼€ì´ìŠ¤ ë¶„ì„
            true_over_300 = y_true >= 300
            pred_over_300 = y_pred >= 300
            
            # í˜¼ë™ í–‰ë ¬
            tp = np.sum(true_over_300 & pred_over_300)  # True Positive
            fp = np.sum(~true_over_300 & pred_over_300)  # False Positive
            tn = np.sum(~true_over_300 & ~pred_over_300)  # True Negative
            fn = np.sum(true_over_300 & ~pred_over_300)  # False Negative
            
            # ë©”íŠ¸ë¦­ ê³„ì‚°
            if tp + fp > 0:
                precision = tp / (tp + fp)
            else:
                precision = 0
                
            if tp + fn > 0:
                recall = tp / (tp + fn)
            else:
                recall = 0
                
            if precision + recall > 0:
                f1 = 2 * (precision * recall) / (precision + recall)
            else:
                f1 = 0
            
            print(f"  - True Positive (ì •í™•íˆ ì˜ˆì¸¡í•œ ìœ„í—˜): {tp}ê°œ")
            print(f"  - False Positive (ì˜ëª»ëœ ê²½ë³´): {fp}ê°œ")
            print(f"  - True Negative (ì •í™•íˆ ì˜ˆì¸¡í•œ ì •ìƒ): {tn}ê°œ")
            print(f"  - False Negative (ë†“ì¹œ ìœ„í—˜): {fn}ê°œ")
            print(f"  - Precision (ì •ë°€ë„): {precision:.2%}")
            print(f"  - Recall (ì¬í˜„ìœ¨): {recall:.2%}")
            print(f"  - F1-Score: {f1:.2%}")
            
            # ê·¹ë‹¨ê°’ ë¶„ì„
            extreme_cases = y_true > 400
            if np.sum(extreme_cases) > 0:
                extreme_mae = mean_absolute_error(y_true[extreme_cases], y_pred[extreme_cases])
                print(f"  - 400 ì´ˆê³¼ ê·¹ë‹¨ê°’ MAE: {extreme_mae:.2f}")
    
    def save_predictions(self, results, output_path='predictions_202509.csv'):
        """ì˜ˆì¸¡ ê²°ê³¼ë¥¼ CSVë¡œ ì €ì¥"""
        print(f"\nğŸ’¾ ì˜ˆì¸¡ ê²°ê³¼ ì €ì¥ ì¤‘...")
        
        # ì²« ë²ˆì§¸ ëª¨ë¸ì˜ íƒ€ì„ìŠ¤íƒ¬í”„ ì‚¬ìš©
        first_model = list(results.keys())[0]
        timestamps = results[first_model]['timestamps']
        
        # ë°ì´í„°í”„ë ˆì„ ìƒì„±
        df_results = pd.DataFrame({
            'timestamp': timestamps,
            'actual': results[first_model]['y_true']
        })
        
        # ê° ëª¨ë¸ì˜ ì˜ˆì¸¡ê°’ ì¶”ê°€
        for model_name, result in results.items():
            df_results[f'pred_{model_name}'] = result['y_pred']
            df_results[f'error_{model_name}'] = result['y_pred'] - result['y_true']
        
        # 300 ì´ìƒ í”Œë˜ê·¸
        df_results['is_critical'] = df_results['actual'] >= 300
        
        # ì €ì¥
        df_results.to_csv(output_path, index=False)
        print(f"âœ… ì˜ˆì¸¡ ê²°ê³¼ ì €ì¥ ì™„ë£Œ: {output_path}")
        
        # ìš”ì•½ í†µê³„
        print(f"\nğŸ“Š ì €ì¥ëœ ë°ì´í„° ìš”ì•½:")
        print(f"  - ì „ì²´ ì˜ˆì¸¡ ìˆ˜: {len(df_results)}ê°œ")
        print(f"  - 300 ì´ìƒ ì‹¤ì œê°’: {df_results['is_critical'].sum()}ê°œ")
        print(f"  - ê¸°ê°„: {df_results['timestamp'].min()} ~ {df_results['timestamp'].max()}")

def main():
    """ë©”ì¸ ì‹¤í–‰ í•¨ìˆ˜"""
    print("="*80)
    print("ğŸ­ HUBROOM ë°˜ì†¡ëŸ‰ ì˜ˆì¸¡ í‰ê°€ ì‹œìŠ¤í…œ")
    print("ğŸ“… ëŒ€ìƒ: 2025ë…„ 9ì›” ë°ì´í„°")
    print("="*80)
    
    # í‰ê°€ê¸° ìƒì„±
    evaluator = HUBROOMEvaluator()
    
    # ìŠ¤ì¼€ì¼ëŸ¬ í™•ì¸
    if evaluator.scaler_X is None:
        print("\nâŒ ìŠ¤ì¼€ì¼ëŸ¬ê°€ ì—†ìŠµë‹ˆë‹¤. save_scalers.pyë¥¼ ë¨¼ì € ì‹¤í–‰í•˜ì„¸ìš”!")
        return
    
    try:
        # 1. ë°ì´í„° ì¤€ë¹„
        df, numeric_cols = evaluator.prepare_data()
        
        # 2. ì‹œí€€ìŠ¤ ìƒì„±
        X, y_actual, physics_data, timestamps, y_times = evaluator.create_evaluation_sequences(df, numeric_cols)
        
        # 3. ëª¨ë¸ ë¡œë“œ
        models = evaluator.load_models()
        
        if not models:
            print("\nâŒ ë¡œë“œëœ ëª¨ë¸ì´ ì—†ìŠµë‹ˆë‹¤!")
            return
        
        # 4. ì˜ˆì¸¡ ë° í‰ê°€
        results = evaluator.predict_and_evaluate(models, X, y_actual, physics_data, timestamps)
        
        # 5. ê²°ê³¼ ì‹œê°í™”
        evaluator.visualize_results(results)
        
        # 6. ì˜ˆì¸¡ ê²°ê³¼ ì €ì¥
        evaluator.save_predictions(results)
        
        # 7. ìµœì¢… ìš”ì•½
        print("\n" + "="*80)
        print("ğŸ“Š ìµœì¢… ëª¨ë¸ ë¹„êµ ìš”ì•½")
        print("="*80)
        
        print(f"\n{'ëª¨ë¸':<20} {'MAE':<10} {'RMSE':<10} {'RÂ²':<10} {'300+ ì •í™•ë„':<15}")
        print("-"*65)
        
        for model_name, result in results.items():
            print(f"{model_name:<20} {result['mae']:<10.2f} {result['rmse']:<10.2f} "
                  f"{result['r2']:<10.2f} {result['acc_300']:<15.2%}")
        
        print("\nâœ… í‰ê°€ ì™„ë£Œ!")
        
    except Exception as e:
        print(f"\nâŒ ì˜¤ë¥˜ ë°œìƒ: {e}")
        import traceback
        traceback.print_exc()

if __name__ == "__main__":
    main()