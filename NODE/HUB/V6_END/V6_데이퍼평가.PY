import numpy as np
import pandas as pd
import pickle
from datetime import datetime, timedelta
from sklearn.metrics import mean_absolute_error, mean_squared_error, r2_score

def evaluate_and_save_csv(test_file='BBB.CSV'):
    """
    ì „ì²´ ì‹¤ì œê°’ + 10ë¶„ í›„ ì˜ˆì¸¡ í‰ê°€
    """
    # ëª¨ë¸ ë¡œë“œ
    try:
        with open('xgboost_model_30min_10min.pkl', 'rb') as f:
            model = pickle.load(f)
    except:
        print("âŒ ëª¨ë¸ íŒŒì¼ ì—†ìŒ")
        return
    
    # í…ŒìŠ¤íŠ¸ ë°ì´í„° ë¡œë“œ
    df_test = pd.read_csv(test_file, on_bad_lines='skip')
    TARGET_COL = 'CURRENT_M16A_3F_JOB_2'
    
    # STAT_DT ì²˜ë¦¬
    if 'STAT_DT' in df_test.columns:
        try:
            df_test['STAT_DT'] = pd.to_datetime(df_test['STAT_DT'].astype(str), format='%Y%m%d%H%M')
        except:
            base_date = datetime(2024, 1, 1)
            df_test['STAT_DT'] = [base_date + timedelta(minutes=i) for i in range(len(df_test))]
    
    results = []
    
    # 30ë¶„ ì‹œí€€ìŠ¤ë¡œ ì˜ˆì¸¡
    for i in range(30, len(df_test) - 10):
        # ì‹œí€€ìŠ¤ (i-30 ~ i-1)
        seq = df_test[TARGET_COL].iloc[i-30:i].values
        
        # ì‹œê°„ ì •ë³´
        seq_start_time = df_test['STAT_DT'].iloc[i-30]
        seq_end_time = df_test['STAT_DT'].iloc[i-1]
        current_time = df_test['STAT_DT'].iloc[i]
        
        # 10ë¶„ í›„ ì‹¤ì œê°’ë“¤ (i ~ i+9 ê°ê°ì˜ ê°’)
        future_10_values = df_test[TARGET_COL].iloc[i:i+10].values
        future_10_max = np.max(future_10_values)
        
        # ê° ì‹œì ì˜ ì‹œê°„ê³¼ ì‹¤ì œê°’
        for j in range(10):
            future_time = df_test['STAT_DT'].iloc[i+j]
            actual_value = df_test[TARGET_COL].iloc[i+j]
            
            # ì˜ˆì¸¡ì€ 10ë¶„ í›„ ìµœëŒ€ê°’ (ì²« ë²ˆì§¸ë§Œ)
            if j == 0:
                features = pd.DataFrame([{
                    'target_mean': np.mean(seq),
                    'target_std': np.std(seq),
                    'target_last_5_mean': np.mean(seq[-5:]),
                    'target_max': np.max(seq),
                    'target_min': np.min(seq),
                    'target_slope': np.polyfit(np.arange(30), seq, 1)[0],
                    'target_last_10_mean': np.mean(seq[-10:]),
                    'target_first_10_mean': np.mean(seq[:10])
                }])
                pred_value = model.predict(features)[0]
            
            results.append({
                'ì‹œì ': future_time.strftime('%Y-%m-%d %H:%M'),
                'ë¶„í›„': f'+{j+1}ë¶„',
                'ì‹¤ì œê°’': round(actual_value, 2),
                '10ë¶„MAXì‹¤ì œ': round(future_10_max, 2),
                '10ë¶„MAXì˜ˆì¸¡': round(pred_value, 2) if j == 0 else '-',
                'ì˜¤ì°¨': round(abs(future_10_max - pred_value), 2) if j == 0 else '-',
                'ì‹œí€€ìŠ¤ì‹œì‘': seq_start_time.strftime('%Y-%m-%d %H:%M'),
                'ì‹œí€€ìŠ¤ì¢…ë£Œ': seq_end_time.strftime('%Y-%m-%d %H:%M'),
                'ì‹œí€€ìŠ¤MAX': round(np.max(seq), 2),
                'ì‹œí€€ìŠ¤MIN': round(np.min(seq), 2),
                'ê·¹ë‹¨ê°’': 'O' if actual_value >= 300 else '-'
            })
    
    df_results = pd.DataFrame(results)
    
    # í‰ê°€ (10ë¶„ MAX ê¸°ì¤€)
    eval_df = df_results[df_results['10ë¶„MAXì˜ˆì¸¡'] != '-'].copy()
    actual = eval_df['10ë¶„MAXì‹¤ì œ'].astype(float).values
    predicted = eval_df['10ë¶„MAXì˜ˆì¸¡'].astype(float).values
    
    mae = mean_absolute_error(actual, predicted)
    rmse = np.sqrt(mean_squared_error(actual, predicted))
    r2 = r2_score(actual, predicted)
    
    print(f"\nğŸ“Š í‰ê°€ ê²°ê³¼:")
    print(f"  MAE:  {mae:.2f}")
    print(f"  RMSE: {rmse:.2f}")
    print(f"  RÂ²:   {r2:.3f}")
    
    # CSV ì €ì¥
    df_results.to_csv('evaluation_full_results.csv', index=False, encoding='utf-8-sig')
    print(f"\nâœ… ì „ì²´ ì €ì¥: evaluation_full_results.csv")
    
    # ìƒ˜í”Œ ì¶œë ¥
    print("\nìƒ˜í”Œ (ì²˜ìŒ 10ê°œ):")
    print(df_results[['ì‹œì ', 'ë¶„í›„', 'ì‹¤ì œê°’', '10ë¶„MAXì‹¤ì œ', '10ë¶„MAXì˜ˆì¸¡']].head(10))
    
    return df_results

# ì‹¤í–‰
if __name__ == '__main__':
    results = evaluate_and_save_csv('BBB.CSV')