import numpy as np
import pandas as pd
import pickle
from datetime import datetime, timedelta
from sklearn.metrics import mean_absolute_error, mean_squared_error, r2_score

def evaluate_and_save_csv(test_file='BBB.CSV'):
    """
    ì‹¤ì‹œê°„ ì˜ˆì¸¡ ë¡œì§ê³¼ ë™ì¼í•˜ê²Œ í‰ê°€
    """
    # ëª¨ë¸ ë¡œë“œ
    try:
        with open('xgboost_model_30min_10min.pkl', 'rb') as f:
            model = pickle.load(f)
    except:
        print("âŒ ëª¨ë¸ íŒŒì¼ ì—†ìŒ")
        return None
    
    # ë°ì´í„° ë¡œë“œ
    df_test = pd.read_csv(test_file, on_bad_lines='skip')
    TARGET_COL = 'CURRENT_M16A_3F_JOB_2'
    
    # STAT_DT ì²˜ë¦¬
    if 'STAT_DT' in df_test.columns:
        try:
            df_test['STAT_DT'] = pd.to_datetime(df_test['STAT_DT'].astype(str), format='%Y%m%d%H%M')
        except:
            base_date = datetime(2024, 1, 1)
            df_test['STAT_DT'] = [base_date + timedelta(minutes=i) for i in range(len(df_test))]
    
    results = []
    jump_count = 0
    
    for i in range(30, len(df_test) - 10):
        # 30ê°œ ì‹œí€€ìŠ¤ ì¶”ì¶œ (ì‹¤ì‹œê°„ ì˜ˆì¸¡ê³¼ ë™ì¼)
        seq_target = df_test[TARGET_COL].iloc[i-30:i].values
        
        # ì‹œê°„ ì •ë³´
        seq_start = df_test['STAT_DT'].iloc[i-30]
        seq_end = df_test['STAT_DT'].iloc[i-1]
        current_time = df_test['STAT_DT'].iloc[i]
        prediction_start = current_time
        prediction_end = df_test['STAT_DT'].iloc[i+9]
        
        # Feature ìƒì„± (ì‹¤ì‹œê°„ ì˜ˆì¸¡ê³¼ ë™ì¼)
        features = {
            'target_mean': np.mean(seq_target),
            'target_std': np.std(seq_target),
            'target_last_5_mean': np.mean(seq_target[-5:]),
            'target_max': np.max(seq_target),
            'target_min': np.min(seq_target),
            'target_slope': np.polyfit(np.arange(30), seq_target, 1)[0],
            'target_last_10_mean': np.mean(seq_target[-10:]),
            'target_first_10_mean': np.mean(seq_target[:10])
        }
        
        X_pred = pd.DataFrame([features])
        
        # 10ë¶„ MAX ì˜ˆì¸¡ (ì‹¤ì‹œê°„ ì˜ˆì¸¡ê³¼ ë™ì¼)
        prediction_max = model.predict(X_pred)[0]
        
        # ì‹¤ì œ 10ë¶„ MAX
        actual_max = df_test[TARGET_COL].iloc[i:i+10].max()
        
        # ì í”„ ì¼€ì´ìŠ¤ ì²´í¬
        seq_max = np.max(seq_target)
        is_jump = (seq_max < 280) and (actual_max >= 300)
        if is_jump:
            jump_count += 1
        
        results.append({
            'í˜„ì¬ì‹œê°„': current_time.strftime('%Y-%m-%d %H:%M'),
            'ì˜ˆì¸¡ì‹œê°„(+10ë¶„)': prediction_end.strftime('%Y-%m-%d %H:%M'),
            'ì‹œí€€ìŠ¤ì‹œì‘': seq_start.strftime('%Y-%m-%d %H:%M'),
            'ì‹œí€€ìŠ¤ì™„ë£Œ': seq_end.strftime('%Y-%m-%d %H:%M'),
            'ì‹¤ì œê°’': round(df_test[TARGET_COL].iloc[i+9], 2),  # i+9 ì‹œì  ì‹¤ì œê°’
            '10ë¶„MAXì‹¤ì œ': round(actual_max, 2),
            '10ë¶„MAXì˜ˆì¸¡': round(prediction_max, 2),
            'ì˜¤ì°¨': round(abs(actual_max - prediction_max), 2),
            'ì‹œí€€ìŠ¤MAX': round(seq_max, 2),
            'ì‹œí€€ìŠ¤MIN': round(np.min(seq_target), 2),
            'ì í”„ì¼€ì´ìŠ¤': 'O' if is_jump else '-',
            'ê·¹ë‹¨ê°’(300+)': 'O' if actual_max >= 300 else '-'
        })
    
    df_results = pd.DataFrame(results)
    
    # í‰ê°€ ì§€í‘œ (10ë¶„ MAX ê¸°ì¤€)
    y_true = df_results['10ë¶„MAXì‹¤ì œ'].values
    y_pred = df_results['10ë¶„MAXì˜ˆì¸¡'].values
    
    mae = mean_absolute_error(y_true, y_pred)
    rmse = np.sqrt(mean_squared_error(y_true, y_pred))
    r2 = r2_score(y_true, y_pred)
    
    print("\n" + "="*60)
    print("ğŸ“Š í‰ê°€ ê²°ê³¼ (ì‹¤ì‹œê°„ ì˜ˆì¸¡ ë¡œì§)")
    print("="*60)
    print(f"MAE:  {mae:.4f}")
    print(f"RMSE: {rmse:.4f}")
    print(f"RÂ²:   {r2:.4f}")
    
    # ê·¹ë‹¨ê°’ í‰ê°€
    extreme_count = sum(y_true >= 300)
    if extreme_count > 0:
        extreme_detected = sum((y_true >= 300) & (y_pred >= 290))
        print(f"\nê·¹ë‹¨ê°’(300+): {extreme_count}ê°œ")
        print(f"ê·¹ë‹¨ê°’ ê°ì§€: {extreme_detected}ê°œ ({extreme_detected/extreme_count*100:.1f}%)")
    
    print(f"ì í”„ ì¼€ì´ìŠ¤: {jump_count}ê°œ")
    
    # CSV ì €ì¥
    df_results.to_csv('evaluation_results.csv', index=False, encoding='utf-8-sig')
    print(f"\nâœ… ì €ì¥: evaluation_results.csv")
    
    return df_results

# ì‹¤í–‰
if __name__ == '__main__':
    results = evaluate_and_save_csv('BBB.CSV')