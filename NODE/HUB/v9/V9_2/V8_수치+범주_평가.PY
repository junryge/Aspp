import numpy as np
import pandas as pd
import pickle
from datetime import datetime, timedelta
from sklearn.metrics import accuracy_score

def evaluate_v8_5stage_ensemble():
    """
    ğŸ¯ V8 5ë‹¨ê³„ í‰ê°€ - í™•ë¥  ê°€ì¤‘ ì•™ìƒë¸”
    
    ê¸°ì¡´: ë¶„ë¥˜ ê²°ê³¼ â†’ í•´ë‹¹ ëª¨ë¸ë§Œ ì‚¬ìš©
    ë³€ê²½: 5ê°œ ëª¨ë¸ ì˜ˆì¸¡ì„ í™•ë¥ ë¡œ ê°€ì¤‘ í‰ê· 
    
    ì˜ˆ) ì •ì²´ 60%, ì†Œí­ìƒìŠ¹ 30%, ê¸‰ë“± 10%
        â†’ ì •ì²´ì˜ˆì¸¡Ã—0.6 + ì†Œí­ìƒìŠ¹ì˜ˆì¸¡Ã—0.3 + ê¸‰ë“±ì˜ˆì¸¡Ã—0.1
    """
    print("="*80)
    print("ğŸ¯ V8 5ë‹¨ê³„ í‰ê°€: í™•ë¥  ê°€ì¤‘ ì•™ìƒë¸”")
    print("="*80)
    
    FEATURE_COLS_V8 = {
        'storage': ['M16A_3F_STORAGE_UTIL'],
        'fs_storage': ['CD_M163FSTORAGEUSE', 'CD_M163FSTORAGETOTAL', 'CD_M163FSTORAGEUTIL'],
        'hub': ['HUBROOMTOTAL'],
        'cmd': ['M16A_3F_CMD', 'M16A_6F_TO_HUB_CMD'],
        'inflow': ['M16A_6F_TO_HUB_JOB', 'M16A_2F_TO_HUB_JOB2', 'M14A_3F_TO_HUB_JOB2'],
        'outflow': ['M16A_3F_TO_M16A_6F_JOB', 'M16A_3F_TO_M16A_2F_JOB', 'M16A_3F_TO_M14A_3F_JOB'],
        'maxcapa': ['M16A_6F_LFT_MAXCAPA', 'M16A_2F_LFT_MAXCAPA'],
    }
    
    TARGET_COL = 'CURRENT_M16A_3F_JOB_2'
    
    class_names = {0: 'ê¸‰ë½', 1: 'ì†Œí­í•˜ë½', 2: 'ì •ì²´', 3: 'ì†Œí­ìƒìŠ¹', 4: 'ê¸‰ë“±'}
    
    def get_class(change):
        if change <= -50: return 0
        elif change <= -20: return 1
        elif change <= 20: return 2
        elif change <= 50: return 3
        else: return 4
    
    # ëª¨ë¸ ë¡œë“œ
    try:
        with open('xgboost_5stage_V8.pkl', 'rb') as f:
            model_dict = pickle.load(f)
        clf_model = model_dict['classifier']
        regressors = model_dict['regressors']
        print("âœ… ëª¨ë¸ ë¡œë“œ: xgboost_5stage_V8.pkl")
    except Exception as e:
        print(f"âŒ ëª¨ë¸ ì—†ìŒ: {e}")
        return None
    
    # ë°ì´í„° ë¡œë“œ
    try:
        df = pd.read_csv('test_data.csv', on_bad_lines='skip', encoding='utf-8', low_memory=False)
    except:
        try:
            df = pd.read_csv('test_data.csv', on_bad_lines='skip', encoding='cp949', low_memory=False)
        except:
            df = pd.read_csv('test_data.csv', on_bad_lines='skip', encoding='euc-kr', low_memory=False)
    
    df[TARGET_COL] = pd.to_numeric(df[TARGET_COL], errors='coerce')
    df = df.dropna(subset=[TARGET_COL])
    print(f"âœ… ë°ì´í„° ë¡œë“œ: {len(df)}ê°œ í–‰")
    
    available_cols = set(df.columns)
    
    if 'STAT_DT' in df.columns:
        try:
            df['STAT_DT'] = pd.to_datetime(df['STAT_DT'].astype(str), format='%Y%m%d%H%M')
        except:
            df['STAT_DT'] = [datetime(2024,1,1) + timedelta(minutes=i) for i in range(len(df))]
    
    results = []
    all_true, all_pred = [], []
    x_range = np.arange(30)
    
    print("\ní‰ê°€ ì‹œì‘...")
    total = len(df) - 40
    
    for idx, i in enumerate(range(30, len(df) - 10)):
        if idx % 500 == 0:
            print(f"  ì§„í–‰: {idx}/{total} ({idx/total*100:.1f}%)")
        
        seq_data = df.iloc[i-30:i]
        seq_target = seq_data[TARGET_COL].values
        
        current_time = seq_data['STAT_DT'].iloc[-1]
        current_value = seq_target[-1]
        actual_value = df[TARGET_COL].iloc[i+9]
        actual_change = actual_value - current_value
        actual_class = get_class(actual_change)
        
        # Feature ìƒì„±
        features = {
            'target_mean': np.mean(seq_target),
            'target_std': np.std(seq_target),
            'target_max': np.max(seq_target),
            'target_min': np.min(seq_target),
            'target_last_value': seq_target[-1],
            'target_slope': np.polyfit(x_range, seq_target, 1)[0],
        }
        
        for group_name, cols in FEATURE_COLS_V8.items():
            for col in cols:
                if col not in available_cols: continue
                col_seq = seq_data[col].values
                if group_name == 'maxcapa':
                    features[f'{col}_last_value'] = col_seq[-1]
                elif group_name in ['cmd', 'storage', 'fs_storage', 'hub']:
                    features[f'{col}_mean'] = np.mean(col_seq)
                    features[f'{col}_std'] = np.std(col_seq)
                    features[f'{col}_max'] = np.max(col_seq)
                    features[f'{col}_min'] = np.min(col_seq)
                    features[f'{col}_last_value'] = col_seq[-1]
                    features[f'{col}_slope'] = np.polyfit(x_range, col_seq, 1)[0]
                else:
                    features[f'{col}_mean'] = np.mean(col_seq)
                    features[f'{col}_last_value'] = col_seq[-1]
                    features[f'{col}_slope'] = np.polyfit(x_range, col_seq, 1)[0]
        
        if 'CD_M163FSTORAGEUTIL' in available_cols:
            util_last = seq_data['CD_M163FSTORAGEUTIL'].iloc[-1]
            features['storage_util_high'] = 1 if util_last >= 7 else 0
            features['storage_util_critical'] = 1 if util_last >= 10 else 0
        
        if 'HUBROOMTOTAL' in available_cols:
            hub_last = seq_data['HUBROOMTOTAL'].iloc[-1]
            features['hub_critical'] = 1 if hub_last < 590 else 0
            features['hub_high'] = 1 if hub_last < 610 else 0
        
        inflow = sum(seq_data[c].iloc[-1] for c in FEATURE_COLS_V8['inflow'] if c in available_cols)
        outflow = sum(seq_data[c].iloc[-1] for c in FEATURE_COLS_V8['outflow'] if c in available_cols)
        features['net_flow'] = inflow - outflow
        
        X_pred = pd.DataFrame([features])
        
        # ë¶„ë¥˜
        pred_class = clf_model.predict(X_pred)[0]
        pred_proba = clf_model.predict_proba(X_pred)[0]
        
        all_true.append(actual_class)
        all_pred.append(pred_class)
        
        # 5ê°œ ëª¨ë¸ ì „ë¶€ ì˜ˆì¸¡
        preds = {}
        for cls in range(5):
            if regressors[cls] is not None:
                preds[cls] = regressors[cls].predict(X_pred)[0]
            else:
                default = {0: -60, 1: -35, 2: 0, 3: 35, 4: 60}
                preds[cls] = default[cls]
        
        # ========== í•µì‹¬: í™•ë¥  ê°€ì¤‘ ì•™ìƒë¸” ==========
        # ê¸°ì¡´: final_change = preds[pred_class]
        # ë³€ê²½: 5ê°œ ëª¨ë¸ ì˜ˆì¸¡ì„ í™•ë¥ ë¡œ ê°€ì¤‘ í‰ê· 
        
        ensemble_change = 0
        for cls in range(5):
            ensemble_change += preds[cls] * pred_proba[cls]
        
        ensemble_pred = current_value + ensemble_change
        ensemble_error = abs(actual_value - ensemble_pred)
        
        # ê¸°ì¡´ ë°©ì‹ë„ ê³„ì‚° (ë¹„êµìš©)
        old_change = preds[pred_class]
        old_pred = current_value + old_change
        old_error = abs(actual_value - old_pred)
        
        hub_value = seq_data['HUBROOMTOTAL'].iloc[-1] if 'HUBROOMTOTAL' in available_cols else 0
        
        results.append({
            'í˜„ì¬ì‹œê°„': current_time.strftime('%Y-%m-%d %H:%M'),
            'ì˜ˆì¸¡ì‹œì ': (current_time + timedelta(minutes=10)).strftime('%Y-%m-%d %H:%M'),
            'í˜„ì¬ê°’': round(current_value, 2),
            'ì‹¤ì œê°’': round(actual_value, 2),
            'ì‹¤ì œ_ë³€í™”ëŸ‰': round(actual_change, 2),
            'ì‹¤ì œ_í´ë˜ìŠ¤': class_names[actual_class],
            'ì˜ˆì¸¡_í´ë˜ìŠ¤': class_names[pred_class],
            'ë¶„ë¥˜ì •í™•': 'âœ…' if pred_class == actual_class else 'âŒ',
            'ê¸‰ë½ì˜ˆì¸¡': round(preds[0], 2),
            'ì†Œí­í•˜ë½ì˜ˆì¸¡': round(preds[1], 2),
            'ì •ì²´ì˜ˆì¸¡': round(preds[2], 2),
            'ì†Œí­ìƒìŠ¹ì˜ˆì¸¡': round(preds[3], 2),
            'ê¸‰ë“±ì˜ˆì¸¡': round(preds[4], 2),
            # ê¸°ì¡´ ë°©ì‹
            'ê¸°ì¡´_ë³€í™”ëŸ‰': round(old_change, 2),
            'ê¸°ì¡´_ì˜ˆì¸¡': round(old_pred, 2),
            'ê¸°ì¡´_ì˜¤ì°¨': round(old_error, 2),
            # ì•™ìƒë¸” ë°©ì‹
            'ì•™ìƒë¸”_ë³€í™”ëŸ‰': round(ensemble_change, 2),
            'ì•™ìƒë¸”_ì˜ˆì¸¡': round(ensemble_pred, 2),
            'ì•™ìƒë¸”_ì˜¤ì°¨': round(ensemble_error, 2),
            'ì•™ìƒë¸”_ì˜¤ì°¨â‰¤10': 'âœ…' if ensemble_error <= 10 else '',
            'ì•™ìƒë¸”_ì˜¤ì°¨â‰¤20': 'âœ…' if ensemble_error <= 20 else '',
            'ì•™ìƒë¸”_ì˜¤ì°¨â‰¤30': 'âœ…' if ensemble_error <= 30 else '',
            # í™•ë¥ 
            'ê¸‰ë½í™•ë¥ ': round(pred_proba[0]*100, 1),
            'ì†Œí­í•˜ë½í™•ë¥ ': round(pred_proba[1]*100, 1),
            'ì •ì²´í™•ë¥ ': round(pred_proba[2]*100, 1),
            'ì†Œí­ìƒìŠ¹í™•ë¥ ': round(pred_proba[3]*100, 1),
            'ê¸‰ë“±í™•ë¥ ': round(pred_proba[4]*100, 1),
            'HUBROOMTOTAL': round(hub_value, 0),
        })
    
    results_df = pd.DataFrame(results)
    results_df.to_csv('5ë‹¨ê³„_V8_ì•™ìƒë¸”_í‰ê°€ê²°ê³¼.csv', index=False, encoding='utf-8-sig')
    print(f"\nâœ… ì €ì¥: 5ë‹¨ê³„_V8_ì•™ìƒë¸”_í‰ê°€ê²°ê³¼.csv")
    
    # í†µê³„
    print("\n" + "="*80)
    print("ğŸ“Š í‰ê°€ í†µê³„ (V8 5ë‹¨ê³„ - í™•ë¥  ê°€ì¤‘ ì•™ìƒë¸”)")
    print("="*80)
    
    print(f"ì´ ì˜ˆì¸¡: {len(results_df)}ê°œ")
    
    # ê¸°ì¡´ vs ì•™ìƒë¸” ë¹„êµ
    print(f"\nğŸ”„ ê¸°ì¡´ vs ì•™ìƒë¸” ë¹„êµ:")
    
    old_avg = results_df['ê¸°ì¡´_ì˜¤ì°¨'].mean()
    new_avg = results_df['ì•™ìƒë¸”_ì˜¤ì°¨'].mean()
    print(f"\n  í‰ê·  ì˜¤ì°¨:")
    print(f"    ê¸°ì¡´: {old_avg:.2f}")
    print(f"    ì•™ìƒë¸”: {new_avg:.2f} ({'ê°œì„  âœ…' if new_avg < old_avg else 'ì•…í™” âŒ'} {abs(old_avg-new_avg):.2f})")
    
    old_10 = (results_df['ê¸°ì¡´_ì˜¤ì°¨'] <= 10).sum() / len(results_df) * 100
    new_10 = (results_df['ì•™ìƒë¸”_ì˜¤ì°¨â‰¤10'] == 'âœ…').sum() / len(results_df) * 100
    print(f"\n  ì˜¤ì°¨ â‰¤ 10:")
    print(f"    ê¸°ì¡´: {old_10:.1f}%")
    print(f"    ì•™ìƒë¸”: {new_10:.1f}% ({'ê°œì„  âœ…' if new_10 > old_10 else 'ì•…í™” âŒ'} {abs(new_10-old_10):.1f}%p)")
    
    old_20 = (results_df['ê¸°ì¡´_ì˜¤ì°¨'] <= 20).sum() / len(results_df) * 100
    new_20 = (results_df['ì•™ìƒë¸”_ì˜¤ì°¨â‰¤20'] == 'âœ…').sum() / len(results_df) * 100
    print(f"\n  ì˜¤ì°¨ â‰¤ 20:")
    print(f"    ê¸°ì¡´: {old_20:.1f}%")
    print(f"    ì•™ìƒë¸”: {new_20:.1f}% ({'ê°œì„  âœ…' if new_20 > old_20 else 'ì•…í™” âŒ'} {abs(new_20-old_20):.1f}%p)")
    
    old_30 = (results_df['ê¸°ì¡´_ì˜¤ì°¨'] <= 30).sum() / len(results_df) * 100
    new_30 = (results_df['ì•™ìƒë¸”_ì˜¤ì°¨â‰¤30'] == 'âœ…').sum() / len(results_df) * 100
    print(f"\n  ì˜¤ì°¨ â‰¤ 30:")
    print(f"    ê¸°ì¡´: {old_30:.1f}%")
    print(f"    ì•™ìƒë¸”: {new_30:.1f}% ({'ê°œì„  âœ…' if new_30 > old_30 else 'ì•…í™” âŒ'} {abs(new_30-old_30):.1f}%p)")
    
    # í´ë˜ìŠ¤ë³„ ê°œì„ 
    print(f"\nğŸ“Š ì‹¤ì œ í´ë˜ìŠ¤ë³„ ì•™ìƒë¸” íš¨ê³¼:")
    for cls in range(5):
        cls_name = class_names[cls]
        subset = results_df[results_df['ì‹¤ì œ_í´ë˜ìŠ¤'] == cls_name]
        if len(subset) > 0:
            old_err = subset['ê¸°ì¡´_ì˜¤ì°¨'].mean()
            new_err = subset['ì•™ìƒë¸”_ì˜¤ì°¨'].mean()
            diff = old_err - new_err
            print(f"  {cls_name}: {old_err:.1f} â†’ {new_err:.1f} ({'â†“' if diff > 0 else 'â†‘'}{abs(diff):.1f})")
    
    return results_df

if __name__ == '__main__':
    print("ğŸš€ V8 5ë‹¨ê³„ ì•™ìƒë¸” í‰ê°€ ì‹œì‘...\n")
    evaluate_v8_5stage_ensemble()