import tkinter as tk
from tkinter import filedialog, messagebox, colorchooser, scrolledtext, ttk
import pandas as pd
import plotly.graph_objects as go
from plotly.subplots import make_subplots
import webbrowser
import os

# í˜„ëŒ€ì ì¸ ìƒ‰ìƒ í…Œë§ˆ
COLORS = {
    'primary': '#2C3E50',      # ì§„í•œ ë„¤ì´ë¹„
    'secondary': '#3498DB',    # ë°ì€ ë¸”ë£¨
    'success': '#27AE60',      # ê·¸ë¦°
    'danger': '#E74C3C',       # ë ˆë“œ
    'warning': '#F39C12',      # ì˜¤ë Œì§€
    'info': '#16A085',         # í‹¸
    'light': '#ECF0F1',        # ì—°í•œ íšŒìƒ‰
    'dark': '#2C3E50',         # ë‹¤í¬
    'white': '#FFFFFF',
    'bg': '#F8F9FA',           # ë°°ê²½
    'border': '#BDC3C7',       # í…Œë‘ë¦¬
    'accent': '#9B59B6'        # ë³´ë¼
}

# --------------------------------------------------------------------------
# ì¸ì½”ë”© ìë™ ê°ì§€ í•¨ìˆ˜
# --------------------------------------------------------------------------
def read_csv_safe(filepath):
    """ì—¬ëŸ¬ ì¸ì½”ë”©ì„ ì‹œë„í•˜ì—¬ CSV íŒŒì¼ì„ ì•ˆì „í•˜ê²Œ ì½ìŠµë‹ˆë‹¤."""
    encodings = ['utf-8', 'cp949', 'euc-kr', 'ms949', 'latin-1']
    
    for encoding in encodings:
        try:
            return pd.read_csv(filepath, encoding=encoding)
        except UnicodeDecodeError:
            continue
    
    return pd.read_csv(filepath, encoding='utf-8', errors='ignore')

# --------------------------------------------------------------------------
# ì»¤ìŠ¤í…€ ìŠ¤íƒ€ì¼ ë²„íŠ¼
# --------------------------------------------------------------------------
class StyledButton(tk.Button):
    def __init__(self, parent, **kwargs):
        style = kwargs.pop('style', 'primary')
        
        colors = {
            'primary': (COLORS['secondary'], COLORS['white']),
            'success': (COLORS['success'], COLORS['white']),
            'danger': (COLORS['danger'], COLORS['white']),
            'warning': (COLORS['warning'], COLORS['white']),
            'info': (COLORS['info'], COLORS['white']),
            'accent': (COLORS['accent'], COLORS['white'])
        }
        
        bg, fg = colors.get(style, colors['primary'])
        
        super().__init__(
            parent,
            bg=bg,
            fg=fg,
            activebackground=self._darken_color(bg),
            activeforeground=fg,
            relief='flat',
            borderwidth=0,
            cursor='hand2',
            font=('Segoe UI', 10, 'bold'),
            padx=20,
            pady=10,
            **kwargs
        )
        
        self.bind('<Enter>', lambda e: self.config(bg=self._darken_color(bg)))
        self.bind('<Leave>', lambda e: self.config(bg=bg))
    
    def _darken_color(self, hex_color):
        """ìƒ‰ìƒì„ ì•½ê°„ ì–´ë‘¡ê²Œ ë§Œë“­ë‹ˆë‹¤."""
        hex_color = hex_color.lstrip('#')
        r, g, b = tuple(int(hex_color[i:i+2], 16) for i in (0, 2, 4))
        r, g, b = max(0, r-20), max(0, g-20), max(0, b-20)
        return f'#{r:02x}{g:02x}{b:02x}'

# --------------------------------------------------------------------------
# ì„±ëŠ¥ ì •ë³´ ì°½ í´ë˜ìŠ¤
# --------------------------------------------------------------------------
class PerformanceWindow:
    def __init__(self, parent):
        self.window = tk.Toplevel(parent)
        self.window.title("ğŸ“Š í‰ê°€ ê²°ê³¼ ë¶„ì„ ì…ë ¥")
        self.window.geometry("700x750")
        self.window.configure(bg=COLORS['bg'])
        
        # ì°½ ì¤‘ì•™ ë°°ì¹˜
        self.window.update_idletasks()
        x = (self.window.winfo_screenwidth() // 2) - (700 // 2)
        y = (self.window.winfo_screenheight() // 2) - (750 // 2)
        self.window.geometry(f'700x750+{x}+{y}')
        
        self.values = None
        
        # í—¤ë”
        header = tk.Frame(self.window, bg=COLORS['primary'], height=60)
        header.pack(fill='x')
        header.pack_propagate(False)
        
        tk.Label(
            header,
            text="ğŸ“Š í‰ê°€ ê²°ê³¼ ë¶„ì„",
            font=('Segoe UI', 16, 'bold'),
            bg=COLORS['primary'],
            fg=COLORS['white']
        ).pack(pady=15)
        
        main_frame = tk.Frame(self.window, bg=COLORS['bg'])
        main_frame.pack(fill='both', expand=True, padx=20, pady=20)
        
        # ì„±ëŠ¥ ì§€í‘œ ì…ë ¥ ì„¹ì…˜
        top_frame = tk.LabelFrame(
            main_frame,
            text="  ì„±ëŠ¥ ì§€í‘œ  ",
            font=('Segoe UI', 12, 'bold'),
            bg=COLORS['white'],
            fg=COLORS['primary'],
            relief='flat',
            borderwidth=2,
            padx=20,
            pady=20
        )
        top_frame.pack(fill='x', pady=(0, 20))
        
        input_frame = tk.Frame(top_frame, bg=COLORS['white'])
        input_frame.pack(pady=10, fill='x')
        
        metrics = [
            ("MAE:", "30.23", COLORS['info']),
            ("RMSE:", "36.02", COLORS['warning']),
            ("RÂ²:", "0.72", COLORS['success'])
        ]
        
        self.metric_vars = {}
        for idx, (label, default, color) in enumerate(metrics):
            # ë¼ë²¨
            label_widget = tk.Label(
                input_frame,
                text=label,
                font=('Segoe UI', 11, 'bold'),
                bg=COLORS['white'],
                fg=color,
                width=8,
                anchor='e'
            )
            label_widget.grid(row=idx, column=0, sticky='e', padx=(0, 10), pady=8)
            
            # ì…ë ¥ í•„ë“œ
            var = tk.StringVar(value=default)
            self.metric_vars[label.rstrip(':')] = var
            
            entry = tk.Entry(
                input_frame,
                textvariable=var,
                font=('Segoe UI', 11),
                width=20,
                relief='flat',
                borderwidth=2,
                bg=COLORS['light']
            )
            entry.grid(row=idx, column=1, padx=5, pady=8, sticky='ew')
        
        input_frame.columnconfigure(1, weight=1)
        
        # ê¸°íƒ€ ì •ë³´ ì„¹ì…˜
        bottom_frame = tk.LabelFrame(
            main_frame,
            text="  ê¸°íƒ€ ì •ë³´ (ë¶™ì—¬ë„£ê¸° ê°€ëŠ¥)  ",
            font=('Segoe UI', 12, 'bold'),
            bg=COLORS['white'],
            fg=COLORS['primary'],
            relief='flat',
            borderwidth=2,
            padx=20,
            pady=20
        )
        bottom_frame.pack(fill='both', expand=True)
        
        self.text_widget = scrolledtext.ScrolledText(
            bottom_frame,
            height=20,
            width=70,
            wrap=tk.WORD,
            font=('Consolas', 10),
            relief='flat',
            borderwidth=2,
            bg=COLORS['light']
        )
        self.text_widget.pack(fill='both', expand=True)
        
        self.text_widget.insert('1.0', """ğŸ“Š í‰ê°€ ê²°ê³¼ ë¶„ì„

ì—¬ê¸°ì— í‰ê°€ ê²°ê³¼ì™€ ë¶„ì„ ë‚´ìš©ì„ ì…ë ¥í•˜ì„¸ìš”...
""")
        
        # ë²„íŠ¼
        btn_frame = tk.Frame(main_frame, bg=COLORS['bg'])
        btn_frame.pack(pady=20)
        
        StyledButton(
            btn_frame,
            text="âœ“ í™•ì¸",
            command=self.save_and_close,
            style='success',
            width=15
        ).pack(side='left', padx=5)
        
        StyledButton(
            btn_frame,
            text="âœ— ì·¨ì†Œ",
            command=self.window.destroy,
            style='danger',
            width=15
        ).pack(side='left', padx=5)
        
    def save_and_close(self):
        self.values = {
            'mae': self.metric_vars['MAE'].get(),
            'rmse': self.metric_vars['RMSE'].get(),
            'r2': self.metric_vars['RÂ²'].get(),
            'other_info': self.text_widget.get('1.0', 'end-1c')
        }
        self.window.destroy()

# --------------------------------------------------------------------------
# ê·¸ë˜í”„ ìƒì„± ë¡œì§
# --------------------------------------------------------------------------
def create_graph(params, perf_values=None):
    try:
        df = read_csv_safe(params['file_path'])
        
        actual_x_col = params['actual_x']
        actual_y_col = params['actual_y']
        hubroom_x_col = params['hubroom_x']
        hubroom_y_col = params['hubroom_y']
        predicted1_x_col = params['predicted1_x']
        predicted1_y_col = params['predicted1_y']
        predicted2_x_col = params['predicted2_x']
        predicted2_y_col = params['predicted2_y']
        predicted3_x_col = params['predicted3_x']
        predicted3_y_col = params['predicted3_y']
        
        selected_lines = {
            'actual': params.get('enable_actual', True),
            'hubroom': params.get('enable_hubroom', True),
            'predicted1': params.get('enable_predicted1', True),
            'predicted2': params.get('enable_predicted2', True),
            'predicted3': params.get('enable_predicted3', True)
        }
        
        if selected_lines['actual'] and actual_y_col and actual_y_col in df.columns:
            df[actual_y_col] = pd.to_numeric(df[actual_y_col], errors='coerce')
        else:
            selected_lines['actual'] = False
            
        if selected_lines['hubroom'] and hubroom_y_col and hubroom_y_col in df.columns:
            df[hubroom_y_col] = pd.to_numeric(df[hubroom_y_col], errors='coerce')
        else:
            selected_lines['hubroom'] = False
            
        if selected_lines['predicted1'] and predicted1_y_col and predicted1_y_col in df.columns:
            df[predicted1_y_col] = pd.to_numeric(df[predicted1_y_col], errors='coerce')
        else:
            selected_lines['predicted1'] = False
            
        if selected_lines['predicted2'] and predicted2_y_col and predicted2_y_col in df.columns:
            df[predicted2_y_col] = pd.to_numeric(df[predicted2_y_col], errors='coerce')
        else:
            selected_lines['predicted2'] = False
            
        if selected_lines['predicted3'] and predicted3_y_col and predicted3_y_col in df.columns:
            df[predicted3_y_col] = pd.to_numeric(df[predicted3_y_col], errors='coerce')
        else:
            selected_lines['predicted3'] = False
        
        if not any(selected_lines.values()):
            messagebox.showerror("ì˜¤ë¥˜", "ìµœì†Œ 1ê°œ ì´ìƒì˜ ë°ì´í„° ë¼ì¸ì„ ì„ íƒí•´ì•¼ í•©ë‹ˆë‹¤.")
            return
        
        trend_data = params.get('trend_data', [])
        for trend_info in trend_data:
            x_col = trend_info['x_col']
            y_col = trend_info['y_col']
            if x_col in df.columns and y_col in df.columns:
                df[y_col] = pd.to_numeric(df[y_col], errors='coerce')
                try:
                    df[x_col] = pd.to_datetime(df[x_col])
                except:
                    pass
        
        dropna_cols = []
        if selected_lines['actual']:
            dropna_cols.append(actual_y_col)
        if selected_lines['hubroom']:
            dropna_cols.append(hubroom_y_col)
        if selected_lines['predicted1']:
            dropna_cols.append(predicted1_y_col)
        if selected_lines['predicted2']:
            dropna_cols.append(predicted2_y_col)
        if selected_lines['predicted3']:
            dropna_cols.append(predicted3_y_col)
            
        if dropna_cols:
            df = df.dropna(subset=dropna_cols)
        
        jump_col = None
        for col in df.columns:
            if 'ì í”„ì˜ˆì¸¡' in col or 'jump' in col.lower():
                jump_col = col
                break
        
        pattern_col = None
        for col in df.columns:
            if 'íŒ¨í„´ì˜ˆì¸¡' in col or 'pattern' in col.lower():
                pattern_col = col
                break
        
        if selected_lines['actual']:
            try:
                df[actual_x_col] = pd.to_datetime(df[actual_x_col])
                df['actual_time_str'] = df[actual_x_col].dt.strftime('%Y-%m-%d %H:%M:%S')
            except:
                df['actual_time_str'] = df[actual_x_col].astype(str)
        else:
            df['actual_time_str'] = ''
                
        if selected_lines['hubroom']:
            try:
                df[hubroom_x_col] = pd.to_datetime(df[hubroom_x_col])
                df['hubroom_time_str'] = df[hubroom_x_col].dt.strftime('%Y-%m-%d %H:%M:%S')
            except:
                df['hubroom_time_str'] = df[hubroom_x_col].astype(str)
        else:
            df['hubroom_time_str'] = ''
                
        if selected_lines['predicted1']:
            try:
                df[predicted1_x_col] = pd.to_datetime(df[predicted1_x_col])
                df['predicted1_time_str'] = df[predicted1_x_col].dt.strftime('%Y-%m-%d %H:%M:%S')
            except:
                df['predicted1_time_str'] = df[predicted1_x_col].astype(str)
        else:
            df['predicted1_time_str'] = ''
                
        if selected_lines['predicted2']:
            try:
                df[predicted2_x_col] = pd.to_datetime(df[predicted2_x_col])
                df['predicted2_time_str'] = df[predicted2_x_col].dt.strftime('%Y-%m-%d %H:%M:%S')
            except:
                df['predicted2_time_str'] = df[predicted2_x_col].astype(str)
        else:
            df['predicted2_time_str'] = ''
                
        if selected_lines['predicted3']:
            try:
                df[predicted3_x_col] = pd.to_datetime(df[predicted3_x_col])
                df['predicted3_time_str'] = df[predicted3_x_col].dt.strftime('%Y-%m-%d %H:%M:%S')
            except:
                df['predicted3_time_str'] = df[predicted3_x_col].astype(str)
        else:
            df['predicted3_time_str'] = ''
        
        if selected_lines['actual']:
            df['common_time'] = df[actual_x_col]
        elif selected_lines['hubroom']:
            df['common_time'] = df[hubroom_x_col]
        elif selected_lines['predicted1']:
            df['common_time'] = df[predicted1_x_col]
        elif selected_lines['predicted2']:
            df['common_time'] = df[predicted2_x_col]
        elif selected_lines['predicted3']:
            df['common_time'] = df[predicted3_x_col]
        
        if jump_col:
            df['jump_value'] = df[jump_col].astype(str)
            df['jump_color'] = df[jump_col].apply(
                lambda x: '#27AE60' if str(x).upper() == 'O' else '#E74C3C' if str(x).upper() == 'X' else '#666'
            )
        else:
            df['jump_value'] = 'N/A'
            df['jump_color'] = '#666'
        
        if pattern_col:
            df['pattern_value'] = df[pattern_col].astype(str)
            def get_pattern_color(val):
                val_str = str(val).strip()
                if 'ìƒìŠ¹' in val_str or 'ì¦ê°€' in val_str:
                    return '#27AE60'
                elif 'í•˜ë½' in val_str or 'ê°ì†Œ' in val_str:
                    return '#E74C3C'
                elif 'ì•ˆì •' in val_str or 'ìœ ì§€' in val_str:
                    return '#3498DB'
                else:
                    return '#8E44AD'
            df['pattern_color'] = df[pattern_col].apply(get_pattern_color)
        else:
            df['pattern_value'] = 'N/A'
            df['pattern_color'] = '#95A5A6'
        
        for trend_info in trend_data:
            y_col = trend_info.get('y_col', '')
            if y_col and y_col in df.columns:
                try:
                    df[y_col] = pd.to_numeric(df[y_col], errors='coerce')
                except:
                    pass

        fig = go.Figure()

        if selected_lines['actual']:
            fig.add_trace(go.Scattergl(
                x=df['common_time'],
                y=df[actual_y_col], 
                mode='lines+markers',
                name='ì‹¤ì œê°’ (Actual)',
                line=dict(color=params['actual_color'], 
                         dash=None if params['actual_style'] == 'Solid' else params['actual_style'].lower(), 
                         width=3),
                marker=dict(size=6),
                customdata=df[['actual_time_str']].values,
                hovertemplate='<b style="color: #2E86C1; font-size: 14px;">ğŸ“Š INFO ì •ë³´</b><br>' +
                             '<span style="color: #85C1E2;">â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•</span><br>' +
                             '<b style="color: #1f77b4;">ğŸ”µ ì‹¤ì œê°’</b><br>' +
                             '<span style="color: #666;">ì‹œê°„:</span> %{customdata[0]}<br>' +
                             '<span style="color: #666;">ê°’:</span> <b>%{y:.2f}</b>' +
                             '<extra></extra>'
            ))
        
        if selected_lines['hubroom']:
            fig.add_trace(go.Scattergl(
                x=df['common_time'],
                y=df[hubroom_y_col], 
                mode='lines+markers',
                name='HUBROOM',
                line=dict(color=params['hubroom_color'], 
                         dash=None if params['hubroom_style'] == 'Solid' else params['hubroom_style'].lower(), 
                         width=3),
                marker=dict(size=6),
                customdata=df[['hubroom_time_str']].values,
                hovertemplate='<b style="color: #9467bd;">ğŸŸ£ HUBROOM</b><br>' +
                             '<span style="color: #666;">ì‹œê°„:</span> %{customdata[0]}<br>' +
                             '<span style="color: #666;">ê°’:</span> <b>%{y:.2f}</b>' +
                             '<extra></extra>'
            ))
        
        if selected_lines['predicted1']:
            fig.add_trace(go.Scattergl(
                x=df['common_time'],
                y=df[predicted1_y_col], 
                mode='lines+markers',
                name='ì˜ˆì¸¡ê°’1 (Predicted1)',
                line=dict(color=params['predicted1_color'], 
                         dash=None if params['predicted1_style'] == 'Solid' else params['predicted1_style'].lower(), 
                         width=3),
                marker=dict(size=6),
                customdata=df[['predicted1_time_str']].values,
                hovertemplate='<b style="color: #ff7f0e;">ğŸ”¶ ì˜ˆì¸¡ê°’1</b><br>' +
                             '<span style="color: #666;">ì‹œê°„:</span> %{customdata[0]}<br>' +
                             '<span style="color: #666;">ê°’:</span> <b>%{y:.2f}</b>' +
                             '<extra></extra>'
            ))
        
        if selected_lines['predicted2']:
            fig.add_trace(go.Scattergl(
                x=df['common_time'],
                y=df[predicted2_y_col], 
                mode='lines+markers',
                name='ì˜ˆì¸¡ê°’2 (Predicted2)',
                line=dict(color=params['predicted2_color'], 
                         dash=None if params['predicted2_style'] == 'Solid' else params['predicted2_style'].lower(), 
                         width=3),
                marker=dict(size=6),
                customdata=df[['predicted2_time_str']].values,
                hovertemplate='<b style="color: #2ca02c;">ğŸ”· ì˜ˆì¸¡ê°’2</b><br>' +
                             '<span style="color: #666;">ì‹œê°„:</span> %{customdata[0]}<br>' +
                             '<span style="color: #666;">ê°’:</span> <b>%{y:.2f}</b>' +
                             '<extra></extra>'
            ))
        
        if selected_lines['predicted3']:
            fig.add_trace(go.Scattergl(
                x=df['common_time'],
                y=df[predicted3_y_col], 
                mode='lines+markers',
                name='ì˜ˆì¸¡ê°’3 (Predicted3)',
                line=dict(color=params['predicted3_color'], 
                         dash=None if params['predicted3_style'] == 'Solid' else params['predicted3_style'].lower(), 
                         width=3),
                marker=dict(size=6),
                customdata=df[['predicted3_time_str']].values,
                hovertemplate='<b style="color: #d62728;">ğŸ”¸ ì˜ˆì¸¡ê°’3</b><br>' +
                             '<span style="color: #666;">ì‹œê°„:</span> %{customdata[0]}<br>' +
                             '<span style="color: #666;">ê°’:</span> <b>%{y:.2f}</b>' +
                             '<extra></extra>'
            ))
        
        trend_colors = ['#808080', '#A9A9A9', '#696969', '#778899', '#708090', 
                       '#2F4F4F', '#556B2F', '#8B4513', '#A0522D', '#B8860B',
                       '#BDB76B', '#8B008B', '#9932CC', '#8B0000', '#DC143C',
                       '#FF6347', '#FF4500']
        
        for idx, trend_info in enumerate(trend_data):
            x_col = trend_info.get('x_col', '')
            y_col = trend_info.get('y_col', '')
            name = trend_info.get('name', '')
            
            if not x_col or not y_col or not name:
                continue
            
            if x_col in df.columns and y_col in df.columns:
                color = trend_colors[idx % len(trend_colors)]
                
                fig.add_trace(go.Scattergl(
                    x=df[x_col],
                    y=df[y_col],
                    mode='lines',
                    name=f'{name}',
                    line=dict(color=color, dash='dot', width=1.5),
                    opacity=0.7,
                    hovertemplate=f'<b>{name}:</b> %{{y:.2f}}<extra></extra>'
                ))
        
        try:
            limit_value = float(params.get('limit_value', 300))
            all_x = df['common_time'].sort_values()
            limit_x = pd.date_range(start=all_x.iloc[0], end=all_x.iloc[-1], periods=100)
            limit_y = [limit_value] * 100
            
            fig.add_trace(go.Scatter(
                x=limit_x,
                y=limit_y,
                mode='lines',
                name=f'ë¦¬ë¯¸íŠ¸ì„  ({limit_value})',
                line=dict(color='red', width=2.5),
                hovertemplate=f'<b style="color: red;">âš ï¸ ë¦¬ë¯¸íŠ¸ì„ : {limit_value:.2f}</b><extra></extra>'
            ))
        except Exception as e:
            print(f"ë¦¬ë¯¸íŠ¸ì„  ìƒì„± ì¤‘ ì˜¤ë¥˜: {e}")
            pass
        
        fig.update_layout(
            title=params['title'], 
            xaxis_title='ì‹œê°„', 
            yaxis_title='ê°’', 
            hovermode='x unified',
            plot_bgcolor='white',
            xaxis=dict(showgrid=True, gridcolor='lightgray'),
            yaxis=dict(showgrid=True, gridcolor='lightgray'),
            showlegend=True,
            legend=dict(
                yanchor="top",
                y=0.99,
                xanchor="left",
                x=0.01
            ),
            hoverlabel=dict(
                bgcolor="white",
                font_size=12,
                font_family="Arial",
                bordercolor="#2E86C1"
            )
        )

        output_filename = "final_guided_graph.html"
        html_content = fig.to_html(include_plotlyjs='cdn')

        if perf_values:
            other_info = perf_values.get('other_info', 'ì •ë³´ê°€ ì…ë ¥ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.')
            other_info_escaped = other_info.replace('<', '&lt;').replace('>', '&gt;')
            
            performance_section = f"""
            <div style="margin: 30px auto; max-width: 1200px; padding: 0 20px;">
                <div style="background-color: white; padding: 30px; border-radius: 10px; box-shadow: 0 2px 10px rgba(0,0,0,0.1);">
                    <h2 style="color: #2E86C1; text-align: center; margin-bottom: 30px; border-bottom: 3px solid #2E86C1; padding-bottom: 15px;">
                        ğŸ“Š í‰ê°€ ê²°ê³¼ ë¶„ì„
                    </h2>
                    <div style="white-space: pre-wrap; line-height: 1.8; font-size: 14px; color: #333; background-color: #f8f9fa; padding: 25px; border-radius: 8px; border: 2px solid #dee2e6; font-family: 'Courier New', monospace;">
{other_info_escaped}
                    </div>
                </div>
            </div>
            """
        else:
            performance_section = ""

        html_content = html_content.replace('</body>', performance_section + '</body>')

        style_section = """
        <style>
            body {
                background-color: #f8f9fa;
                margin: 0;
                padding: 20px 0;
            }
            .plotly-graph-div {
                margin: 0 auto;
                max-width: 1400px;
            }
        </style>
        """
        html_content = html_content.replace('</head>', style_section + '</head>')

        with open(output_filename, 'w', encoding='utf-8') as f:
            f.write(html_content)

        webbrowser.open('file://' + os.path.realpath(output_filename))

        trend_count = len(trend_data)
        messagebox.showinfo("ì„±ê³µ", 
            f"'{output_filename}' íŒŒì¼ì´ ìƒì„±ë˜ì—ˆìŠµë‹ˆë‹¤.\n\n"
            f"âœ… ë©”ì¸ 5ê°œ ë¼ì¸ + íŠ¸ë Œë“œ {trend_count}ê°œ\n"
            f"âœ… ì‹¤ì œê°’ ë¼ì¸ì— ì „ì²´ INFO ì •ë³´ í¬í•¨\n"
            f"âœ… ë²”ë¡€ í´ë¦­ìœ¼ë¡œ í‘œì‹œ/ìˆ¨ê¹€ ê°€ëŠ¥")
            
    except Exception as e:
        import traceback
        error_detail = traceback.format_exc()
        messagebox.showerror("ì˜¤ë¥˜ ë°œìƒ", f"ê·¸ë˜í”„ ìƒì„± ì¤‘ ì˜¤ë¥˜:\n{e}\n\nìƒì„¸:\n{error_detail}")

# --------------------------------------------------------------------------
# GUI ì• í”Œë¦¬ì¼€ì´ì…˜
# --------------------------------------------------------------------------
class GraphApp:
    def __init__(self, root):
        self.root = root
        self.root.title("ğŸ“ˆ ê·¸ë˜í”„ ìƒì„±ê¸° Pro v5.0")
        self.root.geometry("1300x900")
        self.root.configure(bg=COLORS['bg'])
        
        self.file_path = ""
        self.df_columns = []
        self.perf_values = None
        self.trend_widgets = {}

        # í—¤ë”
        self.create_header()
        
        # ë©”ì¸ ì»¨í…Œì´ë„ˆ (ìŠ¤í¬ë¡¤ ê°€ëŠ¥)
        container = tk.Frame(root, bg=COLORS['bg'])
        container.pack(fill='both', expand=True)
        
        main_canvas = tk.Canvas(container, bg=COLORS['bg'], highlightthickness=0)
        scrollbar = ttk.Scrollbar(container, orient="vertical", command=main_canvas.yview)
        self.scrollable_frame = tk.Frame(main_canvas, bg=COLORS['bg'])
        
        self.scrollable_frame.bind(
            "<Configure>",
            lambda e: main_canvas.configure(scrollregion=main_canvas.bbox("all"))
        )
        
        main_canvas.create_window((0, 0), window=self.scrollable_frame, anchor="nw")
        main_canvas.configure(yscrollcommand=scrollbar.set)
        
        def _on_mousewheel(event):
            main_canvas.yview_scroll(int(-1*(event.delta/120)), "units")
        main_canvas.bind_all("<MouseWheel>", _on_mousewheel)
        
        main_canvas.pack(side="left", fill="both", expand=True)
        scrollbar.pack(side="right", fill="y")

        # ê° ë‹¨ê³„ë³„ ì„¹ì…˜
        self.create_all_sections()
        
    def create_header(self):
        """ìƒë‹¨ í—¤ë” ìƒì„±"""
        header = tk.Frame(self.root, bg=COLORS['primary'], height=80)
        header.pack(fill='x')
        header.pack_propagate(False)
        
        # ì œëª©
        title_label = tk.Label(
            header,
            text="ğŸ“ˆ ê·¸ë˜í”„ ìƒì„±ê¸° Pro",
            font=('Segoe UI', 20, 'bold'),
            bg=COLORS['primary'],
            fg=COLORS['white']
        )
        title_label.pack(side='left', padx=30, pady=20)
        
        # ë²„ì „
        version_label = tk.Label(
            header,
            text="v5.0",
            font=('Segoe UI', 10),
            bg=COLORS['primary'],
            fg=COLORS['light']
        )
        version_label.pack(side='left', pady=20)
        
        # í‰ê°€ ê²°ê³¼ ë²„íŠ¼
        StyledButton(
            header,
            text="ğŸ“Š ë‚´ìš©ì •ë³´ ì…ë ¥",
            command=self.open_performance_window,
            style='accent',
            width=15
        ).pack(side='right', padx=30, pady=20)
    
    def create_section_frame(self, title, emoji, state='locked'):
        """ì„¹ì…˜ í”„ë ˆì„ ìƒì„±"""
        # ì™¸ë¶€ í”„ë ˆì„
        outer_frame = tk.Frame(self.scrollable_frame, bg=COLORS['bg'])
        outer_frame.pack(fill='x', padx=20, pady=10)
        
        # ì¹´ë“œ ìŠ¤íƒ€ì¼ í”„ë ˆì„
        card = tk.Frame(
            outer_frame,
            bg=COLORS['white'],
            relief='flat',
            borderwidth=0
        )
        card.pack(fill='x')
        
        # ê·¸ë¦¼ì íš¨ê³¼ (ê°„ë‹¨íˆ)
        shadow = tk.Frame(outer_frame, bg=COLORS['border'], height=2)
        shadow.place(relx=0.01, rely=1, relwidth=0.98)
        
        # í—¤ë”
        header_frame = tk.Frame(card, bg=COLORS['secondary'] if state == 'active' else COLORS['border'], height=50)
        header_frame.pack(fill='x')
        header_frame.pack_propagate(False)
        
        status_emoji = "âœ“" if state == 'active' else "ğŸ”’" if state == 'locked' else emoji
        
        tk.Label(
            header_frame,
            text=f"{status_emoji} {title}",
            font=('Segoe UI', 12, 'bold'),
            bg=COLORS['secondary'] if state == 'active' else COLORS['border'],
            fg=COLORS['white']
        ).pack(side='left', padx=20, pady=10)
        
        # ë‚´ìš© í”„ë ˆì„
        content_frame = tk.Frame(card, bg=COLORS['white'], padx=20, pady=20)
        content_frame.pack(fill='both', expand=True)
        
        return content_frame, header_frame
    
    def create_all_sections(self):
        """ëª¨ë“  ì„¹ì…˜ ìƒì„±"""
        # 1ë‹¨ê³„: íŒŒì¼ ì„ íƒ
        self.step1_content, self.step1_header = self.create_section_frame("1ë‹¨ê³„: íŒŒì¼ ì„ íƒ", "ğŸ“", 'active')
        self.create_step1_widgets()
        
        # 2ë‹¨ê³„: ë©”ì¸ ë°ì´í„°
        self.step2_content, self.step2_header = self.create_section_frame("2ë‹¨ê³„: ë©”ì¸ ë°ì´í„° ì»¬ëŸ¼ ì„ íƒ", "ğŸ“Š", 'locked')
        self.create_step2_widgets()
        
        # 2.5ë‹¨ê³„: íŠ¸ë Œë“œ ë°ì´í„°
        self.step2_5_content, self.step2_5_header = self.create_section_frame("2.5ë‹¨ê³„: íŠ¸ë Œë“œ ë°ì´í„° ì„ íƒ", "ğŸ“ˆ", 'locked')
        self.create_step2_5_widgets()
        
        # 3ë‹¨ê³„: ìŠ¤íƒ€ì¼ ì„¤ì •
        self.step3_content, self.step3_header = self.create_section_frame("3ë‹¨ê³„: ê·¸ë˜í”„ ìŠ¤íƒ€ì¼ ì„¤ì •", "ğŸ¨", 'locked')
        self.create_step3_widgets()
        
        # 4ë‹¨ê³„: ìƒì„±
        self.step4_content, self.step4_header = self.create_section_frame("4ë‹¨ê³„: ê·¸ë˜í”„ ìƒì„±", "ğŸš€", 'locked')
        self.create_step4_widgets()
    
    def create_step1_widgets(self):
        btn_frame = tk.Frame(self.step1_content, bg=COLORS['white'])
        btn_frame.pack(fill='x')
        
        StyledButton(
            btn_frame,
            text="ğŸ“‚ CSV íŒŒì¼ ì„ íƒ",
            command=self.select_file,
            style='primary',
            width=20
        ).pack(side='left', padx=5)
        
        self.file_label = tk.Label(
            btn_frame,
            text="ì„ íƒëœ íŒŒì¼ì´ ì—†ìŠµë‹ˆë‹¤.",
            fg=COLORS['border'],
            bg=COLORS['white'],
            font=('Segoe UI', 10)
        )
        self.file_label.pack(side='left', padx=20)
    
    def create_step2_widgets(self):
        """ë©”ì¸ ë°ì´í„° ì„ íƒ ìœ„ì ¯"""
        labels = [
            "ì‹¤ì œê°’ Xì¶• (ì‹œê°„):", "ì‹¤ì œê°’ Yì¶• (ê°’):",
            "HUBROOM Xì¶• (ì‹œê°„):", "HUBROOM Yì¶• (ê°’):",
            "ì˜ˆì¸¡ê°’1 Xì¶• (ì‹œê°„):", "ì˜ˆì¸¡ê°’1 Yì¶• (ê°’):",
            "ì˜ˆì¸¡ê°’2 Xì¶• (ì‹œê°„):", "ì˜ˆì¸¡ê°’2 Yì¶• (ê°’):",
            "ì˜ˆì¸¡ê°’3 Xì¶• (ì‹œê°„):", "ì˜ˆì¸¡ê°’3 Yì¶• (ê°’):"
        ]
        
        self.enable_actual = tk.BooleanVar(value=True)
        self.enable_hubroom = tk.BooleanVar(value=True)
        self.enable_predicted1 = tk.BooleanVar(value=True)
        self.enable_predicted2 = tk.BooleanVar(value=True)
        self.enable_predicted3 = tk.BooleanVar(value=True)
        
        self.column_vars = [tk.StringVar() for _ in labels]
        self.column_menus = []

        enable_vars = [
            (self.enable_actual, "âœ“ ì‹¤ì œê°’ ì‚¬ìš©"),
            (self.enable_actual, ""),
            (self.enable_hubroom, "âœ“ HUBROOM ì‚¬ìš©"),
            (self.enable_hubroom, ""),
            (self.enable_predicted1, "âœ“ ì˜ˆì¸¡ê°’1 ì‚¬ìš©"),
            (self.enable_predicted1, ""),
            (self.enable_predicted2, "âœ“ ì˜ˆì¸¡ê°’2 ì‚¬ìš©"),
            (self.enable_predicted2, ""),
            (self.enable_predicted3, "âœ“ ì˜ˆì¸¡ê°’3 ì‚¬ìš©"),
            (self.enable_predicted3, "")
        ]

        for i, label_text in enumerate(labels):
            row_frame = tk.Frame(self.step2_content, bg=COLORS['white'])
            row_frame.pack(fill='x', pady=5)
            
            if i % 2 == 0:
                enable_var, checkbox_text = enable_vars[i]
                cb = tk.Checkbutton(
                    row_frame,
                    text=checkbox_text,
                    variable=enable_var,
                    font=('Segoe UI', 10, 'bold'),
                    bg=COLORS['white'],
                    activebackground=COLORS['white'],
                    selectcolor=COLORS['light']
                )
                cb.pack(side='left', padx=(0, 20))
            
            tk.Label(
                row_frame,
                text=label_text,
                font=('Segoe UI', 10),
                bg=COLORS['white'],
                width=20,
                anchor='w'
            ).pack(side='left', padx=5)
            
            menu = ttk.Combobox(
                row_frame,
                textvariable=self.column_vars[i],
                state='readonly',
                width=40,
                font=('Segoe UI', 9)
            )
            menu.pack(side='left', padx=5, fill='x', expand=True)
            self.column_menus.append(menu)
    
    def create_step2_5_widgets(self):
        """íŠ¸ë Œë“œ ë°ì´í„° ì„ íƒ ìœ„ì ¯"""
        # íŠ¸ë Œë“œ ê·¸ë£¹
        trend_groups = {
            'ğŸ“¦ MAXCAP ê·¸ë£¹': [
                'M14A_3F_CNV_MAXCAP', 'M14B_7F_LFT_MAXCAP', 'M16A_2F_LFT_MAXCAP',
                'M16A_3F_CNV_MAXCAP', 'M16A_3F_LFT_MAXCAP', 'M16A_3F_M14BLFT_MAXCAP',
                'M16A_6F_LFT_MAXCAP'
            ],
            'ğŸ“Š UTIL ê·¸ë£¹': ['M16A_3F_STORAGE_UTIL'],
            'ğŸ”„ JOB ê·¸ë£¹': [
                'M14A_3F_TO_HUB_JOB2', 'M14A_3F_TO_HUB_JOB_ALT', 'M14B_7F_TO_HUB_JOB2',
                'M14B_7F_TO_HUB_JOB_ALT', 'M16A_2F_TO_HUB_JOB2', 'M16A_2F_TO_HUB_JOB_ALT',
                'M16A_6F_TO_HUB_JOB', 'M16A_6F_TO_HUB_JOB_ALT', 'M16B_10F_TO_HUB_JOB'
            ]
        }
        
        # ìŠ¤í¬ë¡¤ ê°€ëŠ¥ ì˜ì—­
        canvas = tk.Canvas(self.step2_5_content, height=450, bg=COLORS['white'], highlightthickness=0)
        scrollbar_v = ttk.Scrollbar(self.step2_5_content, orient="vertical", command=canvas.yview)
        scrollbar_h = ttk.Scrollbar(self.step2_5_content, orient="horizontal", command=canvas.xview)
        scrollable_frame = tk.Frame(canvas, bg=COLORS['white'])
        
        scrollable_frame.bind(
            "<Configure>",
            lambda e: canvas.configure(scrollregion=canvas.bbox("all"))
        )
        
        canvas.create_window((0, 0), window=scrollable_frame, anchor="nw")
        canvas.configure(yscrollcommand=scrollbar_v.set, xscrollcommand=scrollbar_h.set)
        
        for group_name, trend_list in trend_groups.items():
            # ê·¸ë£¹ í”„ë ˆì„
            group_card = tk.Frame(
                scrollable_frame,
                bg=COLORS['light'],
                relief='flat',
                borderwidth=2
            )
            group_card.pack(fill='x', padx=10, pady=10)
            
            # ê·¸ë£¹ í—¤ë”
            header = tk.Frame(group_card, bg=COLORS['info'], height=40)
            header.pack(fill='x')
            header.pack_propagate(False)
            
            tk.Label(
                header,
                text=group_name,
                font=('Segoe UI', 11, 'bold'),
                bg=COLORS['info'],
                fg=COLORS['white']
            ).pack(side='left', padx=15, pady=8)
            
            # ê·¸ë£¹ ë²„íŠ¼ë“¤
            btn_container = tk.Frame(header, bg=COLORS['info'])
            btn_container.pack(side='right', padx=10)
            
            group_vars = []
            
            def make_toggle_func(vars_list, value):
                return lambda: [v.set(value) for v in vars_list]
            
            def make_auto_match_func(trend_names, group_title):
                def auto_match():
                    if not self.df_columns:
                        messagebox.showwarning("ê²½ê³ ", "ë¨¼ì € CSV íŒŒì¼ì„ ì„ íƒí•´ì£¼ì„¸ìš”!")
                        return
                    
                    select_window = tk.Toplevel(self.root)
                    select_window.title(f"{group_title} Xì¶• ì„ íƒ")
                    select_window.geometry("500x250")
                    select_window.configure(bg=COLORS['bg'])
                    select_window.transient(self.root)
                    select_window.grab_set()
                    
                    select_window.update_idletasks()
                    x = (select_window.winfo_screenwidth() // 2) - (500 // 2)
                    y = (select_window.winfo_screenheight() // 2) - (250 // 2)
                    select_window.geometry(f'500x250+{x}+{y}')
                    
                    selected_col = tk.StringVar()
                    
                    frame = tk.Frame(select_window, bg=COLORS['white'])
                    frame.pack(fill='both', expand=True, padx=30, pady=30)
                    
                    tk.Label(
                        frame,
                        text=f"{group_title}ì˜ Xì¶•(ì‹œê°„) ì»¬ëŸ¼ ì„ íƒ",
                        font=('Segoe UI', 12, 'bold'),
                        bg=COLORS['white'],
                        fg=COLORS['primary']
                    ).pack(pady=15)
                    
                    col_menu = ttk.Combobox(
                        frame,
                        textvariable=selected_col,
                        values=self.df_columns,
                        font=('Segoe UI', 10),
                        width=50,
                        state='readonly'
                    )
                    col_menu.pack(pady=10)
                    
                    time_keywords = ['ë‚ ì§œ', 'date', 'time', 'ì‹œê°„', 'datetime', 'timestamp']
                    for col in self.df_columns:
                        if any(kw in col.lower() for kw in time_keywords):
                            selected_col.set(col)
                            break
                    
                    def confirm():
                        time_col = selected_col.get()
                        if not time_col:
                            messagebox.showwarning("ê²½ê³ ", "Xì¶• ì»¬ëŸ¼ì„ ì„ íƒí•´ì£¼ì„¸ìš”!")
                            return
                        
                        select_window.destroy()
                        matched = 0
                        for tn in trend_names:
                            wd = self.trend_widgets[tn]
                            y_col = None
                            for col in self.df_columns:
                                if tn in col or col in tn:
                                    y_col = col
                                    break
                            if y_col:
                                wd['x_var'].set(time_col)
                                wd['y_var'].set(y_col)
                                wd['enabled'].set(True)
                                matched += 1
                        messagebox.showinfo("ì™„ë£Œ", f"{group_title}: {matched}ê°œ ë§¤ì¹­")
                    
                    btn_frame = tk.Frame(frame, bg=COLORS['white'])
                    btn_frame.pack(pady=20)
                    
                    StyledButton(btn_frame, text="í™•ì¸", command=confirm, style='success', width=12).pack(side='left', padx=5)
                    StyledButton(btn_frame, text="ì·¨ì†Œ", command=select_window.destroy, style='danger', width=12).pack(side='left', padx=5)
                
                return auto_match
            
            small_btn_style = {'font': ('Segoe UI', 8), 'padx': 10, 'pady': 5}
            
            btn1 = tk.Button(btn_container, text="ì „ì²´ì„ íƒ", bg=COLORS['success'], fg=COLORS['white'],
                            relief='flat', cursor='hand2', **small_btn_style)
            btn1.pack(side='left', padx=2)
            
            btn2 = tk.Button(btn_container, text="ì „ì²´í•´ì œ", bg=COLORS['danger'], fg=COLORS['white'],
                            relief='flat', cursor='hand2', **small_btn_style)
            btn2.pack(side='left', padx=2)
            
            btn3 = tk.Button(btn_container, text="ìë™ë§¤ì¹­", bg=COLORS['accent'], fg=COLORS['white'],
                            relief='flat', cursor='hand2', **small_btn_style)
            btn3.pack(side='left', padx=2)
            
            # ë‚´ìš© í”„ë ˆì„
            content = tk.Frame(group_card, bg=COLORS['white'], padx=15, pady=15)
            content.pack(fill='both', expand=True)
            
            # í—¤ë” í–‰
            tk.Label(content, text="ì‚¬ìš©", font=('Segoe UI', 9, 'bold'), bg=COLORS['white'], width=6).grid(row=0, column=0, padx=5, pady=8)
            tk.Label(content, text="íŠ¸ë Œë“œ ì´ë¦„", font=('Segoe UI', 9, 'bold'), bg=COLORS['white'], width=32, anchor='w').grid(row=0, column=1, sticky='w', padx=5, pady=8)
            tk.Label(content, text="Xì¶• (ì‹œê°„)", font=('Segoe UI', 9, 'bold'), bg=COLORS['white'], width=32, anchor='w').grid(row=0, column=2, padx=5, pady=8)
            tk.Label(content, text="Yì¶• (ê°’)", font=('Segoe UI', 9, 'bold'), bg=COLORS['white'], width=32, anchor='w').grid(row=0, column=3, padx=5, pady=8)
            
            # ê° íŠ¸ë Œë“œ
            for idx, trend_name in enumerate(trend_list):
                row = idx + 1
                
                var = tk.BooleanVar(value=False)
                cb = tk.Checkbutton(content, variable=var, bg=COLORS['white'], activebackground=COLORS['white'])
                cb.grid(row=row, column=0, padx=5, pady=5)
                group_vars.append(var)
                
                tk.Label(content, text=trend_name, font=('Segoe UI', 9), bg=COLORS['white'], anchor='w', width=32).grid(row=row, column=1, sticky='w', padx=5, pady=5)
                
                x_var = tk.StringVar()
                x_menu = ttk.Combobox(content, textvariable=x_var, state='readonly', width=30, font=('Segoe UI', 9))
                x_menu.grid(row=row, column=2, padx=5, pady=5, sticky='ew')
                
                y_var = tk.StringVar()
                y_menu = ttk.Combobox(content, textvariable=y_var, state='readonly', width=30, font=('Segoe UI', 9))
                y_menu.grid(row=row, column=3, padx=5, pady=5, sticky='ew')
                
                self.trend_widgets[trend_name] = {
                    'name': trend_name,
                    'enabled': var,
                    'x_var': x_var,
                    'x_menu': x_menu,
                    'y_var': y_var,
                    'y_menu': y_menu
                }
            
            content.grid_columnconfigure(2, weight=1)
            content.grid_columnconfigure(3, weight=1)
            
            btn1.config(command=make_toggle_func(group_vars, True))
            btn2.config(command=make_toggle_func(group_vars, False))
            btn3.config(command=make_auto_match_func(trend_list, group_name))
        
        canvas.pack(side='top', fill='both', expand=True)
        scrollbar_v.pack(side='right', fill='y')
        scrollbar_h.pack(side='bottom', fill='x')
        
        # ì „ì²´ ìë™ ë§¤ì¹­ ë²„íŠ¼
        auto_all_frame = tk.Frame(self.step2_5_content, bg=COLORS['white'])
        auto_all_frame.pack(fill='x', pady=15)
        
        StyledButton(
            auto_all_frame,
            text="ğŸ”„ ì „ì²´ ìë™ ë§¤ì¹­",
            command=self.auto_match_all_trends,
            style='accent',
            width=20
        ).pack()
        
        tk.Label(
            auto_all_frame,
            text="â€» íŠ¸ë Œë“œ ì´ë¦„ê³¼ ì¼ì¹˜í•˜ëŠ” Yì¶• + ë‚ ì§œ/ì‹œê°„ Xì¶•ì„ ìë™ ì„ íƒ",
            font=('Segoe UI', 9),
            fg=COLORS['border'],
            bg=COLORS['white']
        ).pack(pady=5)
    
    def create_step3_widgets(self):
        """ê·¸ë˜í”„ ìŠ¤íƒ€ì¼ ì„¤ì • ìœ„ì ¯"""
        # ì œëª©
        title_frame = tk.Frame(self.step3_content, bg=COLORS['white'])
        title_frame.pack(fill='x', pady=10)
        
        tk.Label(
            title_frame,
            text="ê·¸ë˜í”„ ì œëª©:",
            font=('Segoe UI', 10, 'bold'),
            bg=COLORS['white'],
            width=15,
            anchor='w'
        ).pack(side='left', padx=5)
        
        self.title_var = tk.StringVar(value="ì‚¬ìš©ì ì •ì˜ ê·¸ë˜í”„")
        title_entry = tk.Entry(
            title_frame,
            textvariable=self.title_var,
            font=('Segoe UI', 10),
            relief='flat',
            bg=COLORS['light']
        )
        title_entry.pack(side='left', fill='x', expand=True, padx=5)
        
        # ë¼ì¸ ìŠ¤íƒ€ì¼ë“¤
        styles = [
            ("ì‹¤ì œê°’", 'actual', '#1f77b4', 'Solid'),
            ("HUBROOM", 'hubroom', '#9467bd', 'Solid'),
            ("ì˜ˆì¸¡ê°’1", 'predicted1', '#ff7f0e', 'Dash'),
            ("ì˜ˆì¸¡ê°’2", 'predicted2', '#2ca02c', 'Dot'),
            ("ì˜ˆì¸¡ê°’3", 'predicted3', '#d62728', 'Dash')
        ]
        
        for label, key, default_color, default_style in styles:
            self.create_style_row(label, key, default_color, default_style)
        
        # ë¦¬ë¯¸íŠ¸ì„ 
        limit_frame = tk.Frame(self.step3_content, bg=COLORS['white'])
        limit_frame.pack(fill='x', pady=10)
        
        tk.Label(
            limit_frame,
            text="ğŸ”´ ë¦¬ë¯¸íŠ¸ì„ :",
            font=('Segoe UI', 10, 'bold'),
            bg=COLORS['white'],
            fg=COLORS['danger'],
            width=15,
            anchor='w'
        ).pack(side='left', padx=5)
        
        tk.Label(
            limit_frame,
            text="ê°’:",
            font=('Segoe UI', 10),
            bg=COLORS['white']
        ).pack(side='left', padx=5)
        
        self.limit_value_var = tk.StringVar(value="300")
        tk.Entry(
            limit_frame,
            textvariable=self.limit_value_var,
            font=('Segoe UI', 10),
            width=15,
            relief='flat',
            bg=COLORS['light']
        ).pack(side='left', padx=5)
    
    def create_style_row(self, label, key, default_color, default_style):
        """ìŠ¤íƒ€ì¼ ì„¤ì • í–‰ ìƒì„±"""
        row_frame = tk.Frame(self.step3_content, bg=COLORS['white'])
        row_frame.pack(fill='x', pady=8)
        
        tk.Label(
            row_frame,
            text=f"{label}:",
            font=('Segoe UI', 10, 'bold'),
            bg=COLORS['white'],
            width=15,
            anchor='w'
        ).pack(side='left', padx=5)
        
        # ìƒ‰ìƒ ë³€ìˆ˜ì™€ ë²„íŠ¼
        color_var = tk.StringVar(value=default_color)
        setattr(self, f'{key}_color_var', color_var)
        
        color_btn = tk.Button(
            row_frame,
            text="  ìƒ‰ìƒ ì„ íƒ  ",
            command=lambda: self.choose_color(color_var, color_btn),
            bg=default_color,
            fg=COLORS['white'],
            font=('Segoe UI', 9, 'bold'),
            relief='flat',
            cursor='hand2',
            padx=15,
            pady=5
        )
        color_btn.pack(side='left', padx=5)
        setattr(self, f'{key}_color_btn', color_btn)
        
        # ìŠ¤íƒ€ì¼ ì„ íƒ
        style_var = tk.StringVar(value=default_style)
        setattr(self, f'{key}_style_var', style_var)
        
        style_menu = ttk.Combobox(
            row_frame,
            textvariable=style_var,
            values=['Solid', 'Dash', 'Dot'],
            state='readonly',
            width=15,
            font=('Segoe UI', 9)
        )
        style_menu.pack(side='left', padx=5)
    
    def create_step4_widgets(self):
        """ê·¸ë˜í”„ ìƒì„± ë²„íŠ¼"""
        StyledButton(
            self.step4_content,
            text="ğŸš€ ê·¸ë˜í”„ ìƒì„± ì‹¤í–‰",
            command=self.generate_graph,
            style='success',
            font=('Segoe UI', 14, 'bold'),
            width=30
        ).pack(pady=20)
        
        tk.Label(
            self.step4_content,
            text="ëª¨ë“  ì„¤ì •ì„ ì™„ë£Œí•œ í›„ ë²„íŠ¼ì„ í´ë¦­í•˜ì„¸ìš”",
            font=('Segoe UI', 10),
            fg=COLORS['border'],
            bg=COLORS['white']
        ).pack()
    
    def open_performance_window(self):
        perf_window = PerformanceWindow(self.root)
        self.root.wait_window(perf_window.window)
        self.perf_values = perf_window.values
    
    def activate_section(self, section_num):
        """ì„¹ì…˜ í™œì„±í™”"""
        sections = [
            (self.step2_header, self.step2_content),
            (self.step2_5_header, self.step2_5_content),
            (self.step3_header, self.step3_content),
            (self.step4_header, self.step4_content)
        ]
        
        if section_num <= len(sections):
            header, content = sections[section_num - 1]
            header.config(bg=COLORS['secondary'])
            for child in header.winfo_children():
                if isinstance(child, tk.Label):
                    child.config(bg=COLORS['secondary'])

    def choose_color(self, color_var, button):
        color_code = colorchooser.askcolor(title="ìƒ‰ìƒ ì„ íƒ")[1]
        if color_code:
            color_var.set(color_code)
            button.config(bg=color_code)
    
    def auto_match_all_trends(self):
        """ì „ì²´ íŠ¸ë Œë“œ ìë™ ë§¤ì¹­"""
        if not self.df_columns:
            messagebox.showwarning("ê²½ê³ ", "ë¨¼ì € CSV íŒŒì¼ì„ ì„ íƒí•´ì£¼ì„¸ìš”!")
            return
        
        select_window = tk.Toplevel(self.root)
        select_window.title("Xì¶•(ì‹œê°„) ì»¬ëŸ¼ ì„ íƒ")
        select_window.geometry("500x250")
        select_window.configure(bg=COLORS['bg'])
        select_window.transient(self.root)
        select_window.grab_set()
        
        select_window.update_idletasks()
        x = (select_window.winfo_screenwidth() // 2) - (500 // 2)
        y = (select_window.winfo_screenheight() // 2) - (250 // 2)
        select_window.geometry(f'500x250+{x}+{y}')
        
        selected_col = tk.StringVar()
        
        frame = tk.Frame(select_window, bg=COLORS['white'])
        frame.pack(fill='both', expand=True, padx=30, pady=30)
        
        tk.Label(
            frame,
            text="ëª¨ë“  íŠ¸ë Œë“œì˜ Xì¶•(ì‹œê°„) ì»¬ëŸ¼ ì„ íƒ",
            font=('Segoe UI', 12, 'bold'),
            bg=COLORS['white'],
            fg=COLORS['primary']
        ).pack(pady=15)
        
        col_menu = ttk.Combobox(
            frame,
            textvariable=selected_col,
            values=self.df_columns,
            font=('Segoe UI', 10),
            width=50,
            state='readonly'
        )
        col_menu.pack(pady=10)
        
        time_keywords = ['ë‚ ì§œ', 'date', 'time', 'ì‹œê°„', 'datetime', 'timestamp']
        for col in self.df_columns:
            if any(kw in col.lower() for kw in time_keywords):
                selected_col.set(col)
                break
        
        def confirm():
            time_col = selected_col.get()
            if not time_col:
                messagebox.showwarning("ê²½ê³ ", "Xì¶• ì»¬ëŸ¼ì„ ì„ íƒí•´ì£¼ì„¸ìš”!")
                return
            
            select_window.destroy()
            matched = 0
            for trend_name, wd in self.trend_widgets.items():
                y_col = None
                for col in self.df_columns:
                    if trend_name in col or col in trend_name:
                        y_col = col
                        break
                if y_col:
                    wd['x_var'].set(time_col)
                    wd['y_var'].set(y_col)
                    wd['enabled'].set(True)
                    matched += 1
            messagebox.showinfo("ì™„ë£Œ", f"ì´ {matched}ê°œ íŠ¸ë Œë“œ ìë™ ë§¤ì¹­ ì™„ë£Œ\nXì¶•: {time_col}")
        
        btn_frame = tk.Frame(frame, bg=COLORS['white'])
        btn_frame.pack(pady=20)
        
        StyledButton(btn_frame, text="í™•ì¸", command=confirm, style='success', width=12).pack(side='left', padx=5)
        StyledButton(btn_frame, text="ì·¨ì†Œ", command=select_window.destroy, style='danger', width=12).pack(side='left', padx=5)

    def select_file(self):
        path = filedialog.askopenfilename(filetypes=[("CSV files", "*.csv")])
        if not path:
            return
        
        self.file_path = path
        filename = os.path.basename(path)
        self.file_label.config(text=f"âœ“ {filename}", fg=COLORS['success'])
        
        try:
            df = read_csv_safe(self.file_path)
            self.df_columns = df.columns.tolist()
            
            # ë©”ì¸ ë°ì´í„° ì»¬ëŸ¼ ì—…ë°ì´íŠ¸
            for i, menu in enumerate(self.column_menus):
                menu['values'] = self.df_columns
            
            # íŠ¸ë Œë“œ ë°ì´í„° ì»¬ëŸ¼ ì—…ë°ì´íŠ¸
            for wd in self.trend_widgets.values():
                wd['x_menu']['values'] = self.df_columns
                wd['y_menu']['values'] = self.df_columns
            
            # ìë™ ì¶”ì²œ
            patterns = [
                ['ë‚ ì§œ', 'date', 'time'],
                ['ì‹¤ì œê°’', 'actual', 'real'],
                ['hubroom', 'hub'],
                ['hubroom', 'hub'],
                ['ì˜ˆì¸¡ë‚ ì§œ', 'pred_date', 'forecast'],
                ['ì˜ˆì¸¡ê°’', 'predicted', 'pred'],
                ['ì˜ˆì¸¡ë‚ ì§œ', 'pred_date', 'forecast', '2'],
                ['ì˜ˆì¸¡ê°’', 'predicted', 'pred', '2'],
                ['ì˜ˆì¸¡ë‚ ì§œ', 'pred_date', 'forecast', '3'],
                ['ì˜ˆì¸¡ê°’', 'predicted', 'pred', '3']
            ]
            
            for idx, pattern_list in enumerate(patterns):
                for col in self.df_columns:
                    if any(p in col.lower() for p in pattern_list):
                        self.column_vars[idx].set(col)
                        break

            # ì„¹ì…˜ í™œì„±í™”
            for i in range(1, 5):
                self.activate_section(i)
            
            messagebox.showinfo("ì„±ê³µ", f"íŒŒì¼ì´ ë¡œë“œë˜ì—ˆìŠµë‹ˆë‹¤!\n\nì»¬ëŸ¼ ìˆ˜: {len(self.df_columns)}")

        except Exception as e:
            messagebox.showerror("ì˜¤ë¥˜", f"CSV íŒŒì¼ ì½ê¸° ì‹¤íŒ¨:\n{e}")

    def generate_graph(self):
        selected_trends = []
        for wd in self.trend_widgets.values():
            if wd['enabled'].get():
                x_col = wd['x_var'].get()
                y_col = wd['y_var'].get()
                if x_col and y_col:
                    selected_trends.append({
                        'name': wd['name'],
                        'x_col': x_col,
                        'y_col': y_col
                    })
        
        params = {
            'file_path': self.file_path,
            'title': self.title_var.get(),
            'actual_x': self.column_vars[0].get() if self.enable_actual.get() else '',
            'actual_y': self.column_vars[1].get() if self.enable_actual.get() else '',
            'hubroom_x': self.column_vars[2].get() if self.enable_hubroom.get() else '',
            'hubroom_y': self.column_vars[3].get() if self.enable_hubroom.get() else '',
            'predicted1_x': self.column_vars[4].get() if self.enable_predicted1.get() else '',
            'predicted1_y': self.column_vars[5].get() if self.enable_predicted1.get() else '',
            'predicted2_x': self.column_vars[6].get() if self.enable_predicted2.get() else '',
            'predicted2_y': self.column_vars[7].get() if self.enable_predicted2.get() else '',
            'predicted3_x': self.column_vars[8].get() if self.enable_predicted3.get() else '',
            'predicted3_y': self.column_vars[9].get() if self.enable_predicted3.get() else '',
            'actual_color': self.actual_color_var.get(),
            'actual_style': self.actual_style_var.get(),
            'hubroom_color': self.hubroom_color_var.get(),
            'hubroom_style': self.hubroom_style_var.get(),
            'predicted1_color': self.predicted1_color_var.get(),
            'predicted1_style': self.predicted1_style_var.get(),
            'predicted2_color': self.predicted2_color_var.get(),
            'predicted2_style': self.predicted2_style_var.get(),
            'predicted3_color': self.predicted3_color_var.get(),
            'predicted3_style': self.predicted3_style_var.get(),
            'limit_value': self.limit_value_var.get(),
            'trend_data': selected_trends,
            'enable_actual': self.enable_actual.get(),
            'enable_hubroom': self.enable_hubroom.get(),
            'enable_predicted1': self.enable_predicted1.get(),
            'enable_predicted2': self.enable_predicted2.get(),
            'enable_predicted3': self.enable_predicted3.get()
        }
        
        enabled_count = sum([
            self.enable_actual.get(),
            self.enable_hubroom.get(),
            self.enable_predicted1.get(),
            self.enable_predicted2.get(),
            self.enable_predicted3.get()
        ])
        
        if enabled_count == 0:
            messagebox.showwarning("ê²½ê³ ", "ìµœì†Œ 1ê°œ ì´ìƒì˜ ë©”ì¸ ë°ì´í„°ë¥¼ ì„ íƒí•´ì£¼ì„¸ìš”.")
            return
        
        missing = []
        if self.enable_actual.get() and (not params['actual_x'] or not params['actual_y']):
            missing.append("ì‹¤ì œê°’")
        if self.enable_hubroom.get() and (not params['hubroom_x'] or not params['hubroom_y']):
            missing.append("HUBROOM")
        if self.enable_predicted1.get() and (not params['predicted1_x'] or not params['predicted1_y']):
            missing.append("ì˜ˆì¸¡ê°’1")
        if self.enable_predicted2.get() and (not params['predicted2_x'] or not params['predicted2_y']):
            missing.append("ì˜ˆì¸¡ê°’2")
        if self.enable_predicted3.get() and (not params['predicted3_x'] or not params['predicted3_y']):
            missing.append("ì˜ˆì¸¡ê°’3")
        
        if missing:
            messagebox.showwarning("ê²½ê³ ", f"ë‹¤ìŒ í•­ëª©ì˜ ì»¬ëŸ¼ì„ ì„ íƒí•´ì£¼ì„¸ìš”:\n{', '.join(missing)}")
            return
        
        if not self.perf_values:
            self.perf_values = {
                'mae': '30.23',
                'rmse': '36.02',
                'r2': '0.72',
                'other_info': 'ê¸°íƒ€ ì •ë³´ê°€ ì…ë ¥ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.'
            }
        
        create_graph(params, self.perf_values)

if __name__ == "__main__":
    root = tk.Tk()
    app = GraphApp(root)
    root.mainloop()