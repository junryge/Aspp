def create_transition_sequences(self, df):
        """ì „ì´ íŒ¨í„´ ì¤‘ì‹¬ ì‹œí€€ìŠ¤ ìƒì„± - [ìˆ˜ì •ë¨] ë©”ëª¨ë¦¬ ì•ˆì •í™”ë¥¼ ìœ„í•´ ì˜¤ë²„ìƒ˜í”Œë§ ë¹„ìœ¨ ëŒ€í­ ì¶•ì†Œ"""
        print("\nğŸ”„ ì „ì´ íŒ¨í„´ ì‹œí€€ìŠ¤ ìƒì„± ì¤‘... (ë©”ëª¨ë¦¬ ì•ˆì •í™” ë²„ì „)")
        
        X_data = df[self.feature_columns].values
        y_data = df['TOTALCNT'].shift(-self.pred_len).values
        
        X, y = [], []
        transition_X, transition_y = [], []  # ì „ì´ íŒ¨í„´
        danger_X, danger_y = [], []          # ìœ„í—˜ íŒ¨í„´
        
        # ìƒìŠ¹/í•˜ë½ êµ¬ë¶„ ì¹´ìš´í„°
        rise_signal_to_danger = 0
        rise_in_danger = 0
        fall_from_danger = 0
        
        for i in range(len(df) - self.seq_len - self.pred_len):
            seq_X = X_data[i:i+self.seq_len]
            target = y_data[i+self.seq_len-1]
            
            if np.isnan(target):
                continue
                
            current = df['TOTALCNT'].iloc[i+self.seq_len-1]
            
            X.append(seq_X)
            y.append(target)
            
            # â­ ìƒìŠ¹/í•˜ë½ êµ¬ë¶„
            is_rising = target > current  # ìƒìŠ¹ ì¤‘
            change_amount = target - current
            
            # ì „ì´ íŒ¨í„´ íƒì§€ ë° ì˜¤ë²„ìƒ˜í”Œë§ (ë³µì œ ë¹„ìœ¨ ëŒ€í­ ì¶•ì†Œ)
            
            # 1. ì‹ í˜¸â†’ìœ„í—˜ ìƒìŠ¹ ì „ì´ (ê°€ì¥ ì¤‘ìš”!)
            if 1650 <= current <= 1699 and target >= 1700 and is_rising:
                # [ìˆ˜ì •] 20ë°° -> 5ë°°
                for _ in range(5):
                    transition_X.append(seq_X)
                    transition_y.append(target)
                rise_signal_to_danger += 1
            
            # 2. ìœ„í—˜êµ¬ê°„ ë‚´ ìƒìŠ¹ ì§€ì†
            elif current >= 1700 and target >= 1700 and is_rising:
                # [ìˆ˜ì •] 15ë°° -> 4ë°°
                for _ in range(4):
                    danger_X.append(seq_X)
                    danger_y.append(target)
                rise_in_danger += 1
            
            # 3. ìœ„í—˜êµ¬ê°„ì—ì„œ í•˜ë½ (ì•ˆì •í™”)
            elif current >= 1700 and target < current:
                # [ìˆ˜ì •] 3ë°° -> 2ë°°
                for _ in range(2):
                    transition_X.append(seq_X)
                    transition_y.append(target)
                fall_from_danger += 1
            
            # 4. ê¸‰ìƒìŠ¹ íŒ¨í„´ (50 ì´ìƒ)
            elif change_amount >= 50 and is_rising:
                # [ìˆ˜ì •] 12ë°° -> 3ë°°
                for _ in range(3):
                    transition_X.append(seq_X)
                    transition_y.append(target)
            
            # 5. ì‹ í˜¸êµ¬ê°„ ë‚´ ìƒìŠ¹
            elif 1651 <= current <= 1699 and is_rising and change_amount >= 20:
                # [ìˆ˜ì •] 8ë°° -> 3ë°°
                for _ in range(3):
                    transition_X.append(seq_X)
                    transition_y.append(target)
            
            # 6. 1680 ì´ìƒì—ì„œ ìƒìŠ¹ (ìœ„í—˜ ì„ë°•)
            elif current >= 1680 and is_rising:
                # [ìˆ˜ì •] 10ë°° -> 3ë°°
                for _ in range(3):
                    danger_X.append(seq_X)
                    danger_y.append(target)
        
        # ì˜¤ë²„ìƒ˜í”Œë§ ë°ì´í„° ì¶”ê°€
        if transition_X:
            X.extend(transition_X)
            y.extend(transition_y)
            print(f"  ğŸ”¥ ì „ì´ íŒ¨í„´ {len(transition_X)}ê°œ ì¶”ê°€")
        
        if danger_X:
            X.extend(danger_X)
            y.extend(danger_y)
            print(f"  ğŸ”¥ ìœ„í—˜ íŒ¨í„´ {len(danger_X)}ê°œ ì¶”ê°€")
        
        print(f"\n  ğŸ“Š íŒ¨í„´ í†µê³„:")
        print(f"    ì‹ í˜¸â†’ìœ„í—˜ ìƒìŠ¹ ì „ì´: {rise_signal_to_danger}ê±´")
        print(f"    ìœ„í—˜êµ¬ê°„ ë‚´ ìƒìŠ¹: {rise_in_danger}ê±´")
        print(f"    ìœ„í—˜êµ¬ê°„ì—ì„œ í•˜ë½: {fall_from_danger}ê±´")
        
        X = np.array(X, dtype=np.float32)
        y = np.array(y, dtype=np.float32)
        
        print(f"  ì´ ì‹œí€€ìŠ¤: {X.shape[0]}ê°œ")
        
        # ì…”í”Œ
        shuffle_idx = np.arange(len(X))
        np.random.shuffle(shuffle_idx)
        X = X[shuffle_idx]
        y = y[shuffle_idx]
        
        return self.split_and_scale(X, y)