# XGBoost 기반 TOTALCNT 예측 모델 기술 문서

## 📋 목차
1. [프로젝트 개요](#프로젝트-개요)
2. [데이터 구조](#데이터-구조)
3. [특성 공학 (Feature Engineering)](#특성-공학-feature-engineering)
4. [모델 아키텍처](#모델-아키텍처)
5. [성능 지표](#성능-지표)
6. [실제 운영 성능](#실제-운영-성능)
7. [수식 및 계산 방법](#수식-및-계산-방법)
8. [적용 방법](#적용-방법)

---

## 프로젝트 개요

### 목적
공정 모니터링 시스템에서 **280분간의 센서 데이터**를 분석하여 **10분 후 TOTALCNT 최댓값**을 예측함으로써, 위험 상황을 사전에 감지하고 대응할 수 있도록 지원합니다.

### 핵심 목표
- ✅ **심각한 위험 임계값(1700 이상) 도달 사전 예측**
- ✅ 평균 오차 30 이내 정확도 달성
- ✅ 실시간 모니터링 및 조기 경보 시스템 구축
- ✅ 100% 위험 감지율 달성 (오경보 최소화)

---

## 데이터 구조

### 학습 데이터
- **데이터 기간**: 2025년 9월 16일 ~ 9월 18일 (Train)
- **샘플링 간격**: 1분
- **시퀀스 길이**: 280분 (4시간 40분)

### 입력 데이터
모델은 4개의 시계열 센서 데이터를 사용합니다:

| 컬럼명 | 설명 | 정상 범위 | 위험 임계값 | 심각도 |
|--------|------|-----------|-------------|--------|
| **M14AM14B** | 센서 A (공정 압력) | 200-300 | > 400 | 높음 |
| **M14AM10A** | 센서 B (온도) | 75-85 | < 70 또는 > 90 | 중간 |
| **M14AM16** | 센서 C (유량) | 100-150 | > 200 | 중간 |
| **TOTALCNT** | 전체 카운트 (타겟) | 1200-1600 | **≥ 1700 (심각)** | 🔴 매우 높음 |

### 시간 윈도우
- **입력 시퀀스**: 280분 (4시간 40분)
- **예측 범위**: 10분 후
- **예측 목표**: 10분 후 TOTALCNT 최댓값

---

## 특성 공학 (Feature Engineering)

모델은 원본 4개 컬럼에서 **총 80개의 특성**을 생성합니다.

### 1. 기본 통계량 (32개)
각 센서별로 8개의 통계 지표를 계산합니다:

**계산 항목** (컬럼당):
```
1. mean (평균): μ = (1/n) Σ xi
2. std (표준편차): σ = √[(1/n) Σ(xi - μ)²]
3. max (최댓값): max(x1, x2, ..., xn)
4. min (최솟값): min(x1, x2, ..., xn)
5. slope (기울기): β = Cov(t,x) / Var(t)
6. last_5_mean (최근 5분 평균): (1/5) Σ(xi-4 to xi)
7. last_10_mean (최근 10분 평균): (1/10) Σ(xi-9 to xi)
8. first_10_mean (초반 10분 평균): (1/10) Σ(x1 to x10)
```

**적용 컬럼**: M14AM14B, M14AM10A, M14AM16, TOTALCNT × 8개 = **32개 특성**

---

### 2. 비율 특성 (8개)

센서 간 상호작용 및 변동성을 포착합니다:

```python
# 현재값 비율
ratio_m14b_m10a = M14AM14B[-1] / (M14AM10A[-1] + 1)
ratio_m14b_m16 = M14AM14B[-1] / (M14AM16[-1] + 1)
ratio_m10a_m16 = M14AM10A[-1] / (M14AM16[-1] + 1)

# 평균값 비율
ratio_m14b_m10a_mean = mean(M14AM14B) / (mean(M14AM10A) + 1)
ratio_m14b_m16_mean = mean(M14AM14B) / (mean(M14AM16) + 1)
ratio_m14b_m10a_max = max(M14AM14B) / (max(M14AM10A) + 1)

# 변동성 계수 (CV: Coefficient of Variation)
volatility_m14b = std(M14AM14B) / (mean(M14AM14B) + 1)
volatility_totalcnt = std(TOTALCNT) / (mean(TOTALCNT) + 1)
```

**의미**: 센서 A가 센서 B 대비 얼마나 높은지, 변동이 평균 대비 얼마나 큰지 등

---

### 3. 임계값 카운트 (20개)

특정 위험 구간 진입 빈도를 측정합니다:

#### M14AM14B 임계값 (8개)
```python
m14b_over_250 = count(M14AM14B > 250)  # 전체 280분
m14b_over_300 = count(M14AM14B > 300)
m14b_over_350 = count(M14AM14B > 350)
m14b_over_400 = count(M14AM14B > 400)
m14b_over_450 = count(M14AM14B > 450)

m14b_over_300_last30 = count(M14AM14B[-30:] > 300)  # 최근 30분
m14b_over_350_last30 = count(M14AM14B[-30:] > 350)
m14b_over_400_last30 = count(M14AM14B[-30:] > 400)
```

#### M14AM10A 임계값 (4개)
```python
m10a_over_70 = count(M14AM10A > 70)
m10a_over_80 = count(M14AM10A > 80)
m10a_under_80 = count(M14AM10A < 80)
m10a_under_70 = count(M14AM10A < 70)
```

#### TOTALCNT 임계값 (8개)
```python
totalcnt_over_1400 = count(TOTALCNT ≥ 1400)  # 전체 280분
totalcnt_over_1500 = count(TOTALCNT ≥ 1500)
totalcnt_over_1600 = count(TOTALCNT ≥ 1600)
totalcnt_over_1700 = count(TOTALCNT ≥ 1700)  # 심각 구간

totalcnt_over_1400_last30 = count(TOTALCNT[-30:] ≥ 1400)  # 최근 30분
totalcnt_over_1500_last30 = count(TOTALCNT[-30:] ≥ 1500)
totalcnt_over_1600_last30 = count(TOTALCNT[-30:] ≥ 1600)
totalcnt_over_1700_last30 = count(TOTALCNT[-30:] ≥ 1700)
```

---

### 4. 황금 패턴 (4개)

위험 신호의 조합을 이진 변수로 표현합니다:

```python
# 패턴 1: 중간 위험
golden_pattern_300_80 = 1 if (M14AM14B[-1] > 300 AND M14AM10A[-1] < 80) else 0

# 패턴 2: 높은 위험
golden_pattern_350_80 = 1 if (M14AM14B[-1] > 350 AND M14AM10A[-1] < 80) else 0

# 패턴 3: 매우 높은 위험
golden_pattern_400_70 = 1 if (M14AM14B[-1] > 400 AND M14AM10A[-1] < 70) else 0

# 위험 존 진입
danger_zone = 1 if TOTALCNT[-1] ≥ 1700 else 0
```

**의미**: 압력 상승 + 온도 하락 조합은 공정 이상의 전조 증상

---

### 5. 변화율 및 가속도 (8개)

추세와 변화의 속도를 측정합니다:

```python
# 변화율 (Rate of Change)
m14b_change_rate = (M14AM14B[-1] - M14AM14B[-30]) / 30
totalcnt_change_rate = (TOTALCNT[-1] - TOTALCNT[-30]) / 30

# 가속도 (Acceleration)
recent_30 = mean(M14AM14B[-30:])
previous_30 = mean(M14AM14B[-60:-30])
m14b_acceleration = recent_30 - previous_30

recent_30_tc = mean(TOTALCNT[-30:])
previous_30_tc = mean(TOTALCNT[-60:-30])
totalcnt_acceleration = recent_30_tc - previous_30_tc

# 범위 (Range)
m14b_range = max(M14AM14B) - min(M14AM14B)
totalcnt_range = max(TOTALCNT) - min(TOTALCNT)

# 최근 vs 전체 비율
m14b_recent_vs_mean = mean(M14AM14B[-30:]) / (mean(M14AM14B) + 1)
totalcnt_recent_vs_mean = mean(TOTALCNT[-30:]) / (mean(TOTALCNT) + 1)
```

**의미**: 
- 변화율 > 0: 상승 중
- 가속도 > 0: 상승 속도 증가 중
- recent_vs_mean > 1: 최근이 평균보다 높음

---

### 6. 시간대별 통계 (8개)

280분을 4구간(각 70분)으로 나누어 추세를 분석합니다:

```python
# 280분 = Q1 (0-70분) + Q2 (70-140분) + Q3 (140-210분) + Q4 (210-280분)

totalcnt_q1_mean = mean(TOTALCNT[0:70])
totalcnt_q2_mean = mean(TOTALCNT[70:140])
totalcnt_q3_mean = mean(TOTALCNT[140:210])
totalcnt_q4_mean = mean(TOTALCNT[210:280])

# 구간별 증가량
totalcnt_trend_q1_q2 = totalcnt_q2_mean - totalcnt_q1_mean
totalcnt_trend_q2_q3 = totalcnt_q3_mean - totalcnt_q2_mean
totalcnt_trend_q3_q4 = totalcnt_q4_mean - totalcnt_q3_mean

# 전체 증가량
totalcnt_trend_overall = totalcnt_q4_mean - totalcnt_q1_mean
```

**의미**: 
- trend > 0: 해당 구간에서 증가
- trend_overall > 50: 전반적으로 큰 상승 추세

---

## 모델 아키텍처

### XGBoost Regressor

**알고리즘**: Gradient Boosted Decision Trees

**핵심 파라미터**:
```python
XGBRegressor(
    n_estimators=500,      # 500개의 결정 트리
    max_depth=8,           # 트리 깊이 최대 8
    learning_rate=0.05,    # 학습률 5%
    subsample=0.8,         # 80% 샘플링
    colsample_bytree=0.8,  # 80% 특성 샘플링
    tree_method='gpu_hist' # GPU 가속 (가능 시)
)
```

### 학습 과정

1. **데이터 전처리**
   - 극단값(TOTALCNT ≥ 2000) 제거: 전체의 0.1% 미만
   - 이유: 드문 극단값이 모델 일반화 성능 저하

2. **Train/Test 분할**
   - Training: 80%
   - Test: 20%
   - Shuffle: True (시간 순서 무관하게 무작위 분할)

3. **학습 방법**
   - 목적 함수: MSE (Mean Squared Error) 최소화
   - Early Stopping: Test set 성능 기반
   - Overfitting 방지: subsample, colsample_bytree로 정규화

---

## 성능 지표

### 학습 성능 (2025.09.16 ~ 09.18 데이터)

#### Train 성능
```
MAE (평균 절대 오차):  29.60
RMSE (평균 제곱근 오차): 37.72
R² (결정계수):         0.9334
```

#### Test 성능
```
MAE (평균 절대 오차):  31.07
RMSE (평균 제곱근 오차): 39.67
R² (결정계수):         0.9272
```

### 평가 메트릭 정의

#### 1. MAE (Mean Absolute Error)
```
MAE = (1/n) Σ |y_pred - y_actual|
```
- **의미**: 평균 절대 오차
- **달성 성능**: ~31 (±31 카운트 오차)
- **해석**: 예측값이 실제값과 평균적으로 31만큼 차이

#### 2. RMSE (Root Mean Squared Error)
```
RMSE = √[(1/n) Σ (y_pred - y_actual)²]
```
- **의미**: 큰 오차에 더 많은 페널티
- **달성 성능**: ~40
- **해석**: MAE보다 큰 값은 일부 큰 오차 존재

#### 3. R² (결정계수)
```
R² = 1 - (SS_res / SS_tot)
SS_res = Σ(y_actual - y_pred)²
SS_tot = Σ(y_actual - ȳ)²
```
- **의미**: 모델이 데이터 변동을 설명하는 비율
- **달성 성능**: 0.9272 (92.72%)
- **해석**: 매우 우수한 설명력

---

## 실제 운영 성능

### 평가 시나리오 1: 소규모 데이터 (3,560개 예측)

#### 전체 성능 지표
```
총 예측 수:         3,560개
평균 절대 오차(MAE): 46.91
평균 오차율:        3.95%
최대 절대 오차:     164.36
최소 절대 오차:     0.01
황금 패턴 발생:     17개
시퀀스 위험 구간:   366개
```

#### 위험 감지 성능
```
실제 위험(1700+):    40개
예측 위험(1680+):    92개
위험 감지 성공:      40개
위험 감지율:         100.0% ✅
오경보(FP):          52개 (56.5%)
```

#### 상세 분석

**1) 전체 데이터 (ALL_OK_NG)**
```
총 예측:    3,560개
정상 예측:  3,528개 (99%)
오차 발생:  45개 (1%)
```
- **의미**: 1700 이상 범위에서 과도한 예측으로 인한 오차 발생

**2) 1700 미만 구간 (1700DOWN_OK_NG)**
```
총 예측:    3,520개
정상 예측:  3,488개 (99.98%)
오차 발생:  40개 (0.02%)
```
- **의미**: 현재 1700 이상이 진행되고 있는 구간으로 인한 예측 오차

**3) 1700 이상 구간 (1700UP)**
```
총 예측:    40개
정상 예측:  40개 (100%) ✅
오차 발생:  0개 (0%)
```
- **의미**: 심각한 위험 구간 완벽 감지

**4) 사전 감지 (1700UP 사전 예측)**
```
대상:       40개
성공:       40개 (100%) ✅
실패:       0개 (0%)
```
- **의미**: 1700 도달 이전 단계에서 100% 사전 감지 성공

---

### 평가 시나리오 2: 대규모 데이터 (8,360개 예측)

#### 전체 성능 지표
```
총 예측 수:         8,360개
평균 절대 오차(MAE): 48.64
평균 오차율:        3.63%
최대 절대 오차:     203.49
최소 절대 오차:     0.00
황금 패턴 발생:     1,069개
시퀀스 위험 구간:   964개
```

#### 위험 감지 성능
```
실제 위험(1700+):    30개
예측 위험(1680+):    108개
위험 감지 성공:      28개
위험 감지율:         93.3% ✅
오경보(FP):          80개 (74.1%)
```

#### 상세 분석

**1) 전체 데이터 (ALL_OK_NG)**
```
총 예측:    8,360개
정상 예측:  8,315개 (99%)
오차 발생:  45개 (1%)
```

**2) 1700 미만 구간 (1700DOWN_OK_NG)**
```
총 예측:    8,330개
정상 예측:  8,290개 (99.98%)
오차 발생:  40개 (0.01%)
```

**3) 1700 이상 구간 (1700UP)**
```
총 예측:    30개
정상 예측:  23개 (77%)
오차 발생:  7개 (23%) ⚠️
```
- **원인**: 1680~1699 사이 근사값 문제
- **설명**: 예측값이 실제 1700 직전 구간(1680~1699)에 위치하여 
           임계값 기준으로는 "정상"으로 분류되나 실제로는 위험 신호

**4) 사전 감지 (1700UP 사전 예측)**
```
대상:       30개
성공:       25개 (83%)
실패:       5개 (17%) ⚠️
```
- **원인**: 1700UP와 동일한 1680~1699 사이값 문제
- **설명**: 예측값이 1680~1699 사이에 위치하여 
           1680 임계값 기준으로는 감지되지 않음

---

### 문제점 및 해결 방안

#### 🔴 주요 이슈: 경계값 문제 (1680~1699 구간)

**문제 상황**:
- 예측값이 1680~1699 사이에 위치
- 예측 임계값(1680) 기준으로는 "위험" 감지
- 실제 임계값(1700) 기준으로는 "정상"으로 판단
- 결과적으로 오경보 또는 미탐지로 기록

**개선 방안**:

1. **예측 임계값 조정**
   ```
   현재: 1680 (1700 - 20)
   제안: 1690 (1700 - 10)
   효과: 경계값 오차 범위 축소
   ```

2. **다단계 경보 시스템**
   ```
   1650~1679: 주의 (CAUTION) - 모니터링 강화
   1680~1699: 경고 (WARNING) - 즉시 확인
   1700+:     위험 (CRITICAL) - 비상 대응
   ```

3. **신뢰 구간 추가**
   ```python
   if prediction >= 1680 and prediction < 1700:
       confidence = "중간 (경계 구간)"
       action = "수동 확인 필요"
   elif prediction >= 1700:
       confidence = "높음"
       action = "즉시 대응"
   ```

---

## 수식 및 계산 방법

### XGBoost 예측 수식

```
ŷ = f₀ + Σ(k=1 to K) ηfₖ(x)

여기서:
- ŷ: 예측값 (10분 후 TOTALCNT 최댓값)
- f₀: 초기 예측값 (평균)
- fₖ: k번째 트리의 예측
- η: learning_rate (0.05)
- K: n_estimators (500)
- x: 80개 특성 벡터
```

### 특성 중요도 계산

```
Importance(feature_j) = Σ(trees) Gain(feature_j, tree)

Gain: 해당 특성으로 분할 시 손실 함수 감소량
```

**Top 5 중요 특성** (예시):
1. `totalcnt_mean`: 280분 평균 TOTALCNT
2. `totalcnt_last_5_mean`: 최근 5분 평균
3. `m14b_mean`: M14AM14B 평균
4. `totalcnt_over_1600`: 1600 초과 빈도
5. `golden_pattern_350_80`: 위험 패턴 감지

### 위험 감지율 계산

```
위험 감지율 = (위험 감지 성공 수) / (실제 위험 수) × 100%

예시 (시나리오 1):
= 40 / 40 × 100% = 100%

예시 (시나리오 2):
= 28 / 30 × 100% = 93.3%
```

### 오경보율 계산

```
오경보율 = (오경보 수) / (예측 위험 수) × 100%

예시 (시나리오 1):
= 52 / 92 × 100% = 56.5%

예시 (시나리오 2):
= 80 / 108 × 100% = 74.1%
```

---

## 적용 방법

### 실시간 예측 프로세스

```python
# 1. 280분 데이터 준비
recent_280min = df.tail(280)

# 2. Feature 생성 (80개)
features = create_features_280min_enhanced(recent_280min)

# 3. 모델 로드 및 예측
import pickle
with open('xgboost_280to10_enhanced.pkl', 'rb') as f:
    model = pickle.load(f)

prediction = model.predict(features)
# prediction: 10분 후 TOTALCNT 예상 최댓값

# 4. 다단계 위험도 판단
if prediction >= 1700:
    alert_level = "CRITICAL"  # 🔴 심각
    priority = "P1"
    action = "즉시 비상 대응"
    
elif prediction >= 1680:
    alert_level = "WARNING"   # 🟠 경고
    priority = "P2"
    action = "즉시 확인 및 모니터링 강화"
    
elif prediction >= 1650:
    alert_level = "CAUTION"   # 🟡 주의
    priority = "P3"
    action = "모니터링 강화"
    
else:
    alert_level = "NORMAL"    # 🟢 정상
    priority = "P4"
    action = "정상 모니터링"
```

### 경보 기준 (개선안)

| 예측값 범위 | 경보 레벨 | 우선순위 | 조치 사항 | 예상 도달 시간 |
|-------------|-----------|----------|-----------|----------------|
| < 1600 | 정상 (NORMAL) | P4 | 정상 모니터링 | - |
| 1600 ~ 1649 | 낮은주의 (LOW CAUTION) | P3- | 모니터링 주기 단축 | 30분+ |
| 1650 ~ 1679 | 주의 (CAUTION) | P3 | 모니터링 강화 | 20분+ |
| 1680 ~ 1699 | 경고 (WARNING) | P2 | 즉시 확인 필요 | 15분+ |
| **1700 ~ 1799** | **위험 (CRITICAL)** | **P1** | **즉시 비상 대응** | **10분 내** |
| ≥ 1800 | 극심 (SEVERE) | P0 | 전체 비상 | 즉시 |

### 권장 업데이트 주기

- **예측 주기**: 1분마다 (실시간)
- **데이터 저장**: 5분마다 (이력 관리)
- **성능 모니터링**: 주 1회 (MAE, R² 추적)
- **모델 재학습**: 월 1회 (새로운 데이터 반영)

### 오경보 처리 방안

**현재 상황**:
- 오경보율: 56.5% ~ 74.1%
- 주요 원인: 1680~1699 경계값 문제

**개선 전략**:

1. **신뢰도 점수 추가**
   ```python
   if prediction >= 1700:
       confidence = "높음 (HIGH)"
   elif 1680 <= prediction < 1700:
       confidence = "중간 (MEDIUM) - 경계 구간"
       # 추가 센서 데이터 확인 필요
   else:
       confidence = "낮음 (LOW)"
   ```

2. **연속 감지 조건**
   ```python
   # 3회 연속 1680 이상 시 경보 발생
   if consecutive_warnings >= 3:
       trigger_alert()
   ```

3. **황금 패턴 가중치**
   ```python
   if golden_pattern_detected and prediction >= 1650:
       # 황금 패턴 발생 시 임계값 낮춤
       adjusted_threshold = 1650
   ```

---

## 성능 요약

### ✅ 강점

1. **높은 예측 정확도**
   - R² 92.72%: 데이터 변동의 92% 이상 설명
   - MAE 31: 평균 ±31 카운트 오차

2. **우수한 위험 감지율**
   - 소규모 데이터: 100% 감지
   - 대규모 데이터: 93.3% 감지

3. **사전 경보 기능**
   - 10분 전 위험 감지
   - 대응 시간 확보

4. **다양한 특성 활용**
   - 80개 특성으로 다각적 분석
   - 황금 패턴 등 도메인 지식 반영

### ⚠️ 개선 필요 사항

1. **경계값 문제 (1680~1699)**
   - 현재: 오경보 발생 주 원인
   - 개선: 다단계 경보 + 신뢰도 점수 추가

2. **오경보율**
   - 현재: 56.5% ~ 74.1%
   - 목표: 30% 이하
   - 방법: 연속 감지 조건 + 황금 패턴 가중치

3. **극단값 처리**
   - 현재: 2000 이상 제거
   - 개선: 극단값도 학습 데이터로 활용 (가중치 조정)

---

## 기대 효과

### 정량적 효과
- ✅ 위험 상황 사전 감지: 10분 전
- ✅ 예측 정확도: 92.72% (R²)
- ✅ 위험 감지율: 93~100%
- ✅ 평균 오차: ±31 카운트 (3.63%)

### 정성적 효과
- ✅ 운전자의 상황 인지 향상 및 대응 시간 확보
- ✅ 사전 대응으로 공정 안정성 증대
- ✅ 데이터 기반 의사결정 문화 구축
- ✅ 위험 상황 패턴 학습 및 예방 전략 수립

---

## 문의 및 지원

추가 문의사항이나 모델 개선이 필요하신 경우 담당자에게 연락 주시기 바랍니다.

**문서 버전**: 2.0 (실제 성능 반영)  
**작성일**: 2025-02-01  
**학습 데이터**: 2025.09.16 ~ 09.18  
**모델 파일**: `xgboost_280to10_enhanced.pkl`  
**평가 데이터**: 3,560개 + 8,360개