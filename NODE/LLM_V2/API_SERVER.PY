#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
CSV ì§ì ‘ ê²€ìƒ‰ RAG ì„œë²„ (Qwen3-Coder API ì—°ë™ ë²„ì „)
"""

import os
import requests
from fastapi import FastAPI
from fastapi.responses import FileResponse, JSONResponse
from pydantic import BaseModel
import logging
from datetime import datetime
import json

# CSV ê²€ìƒ‰ ëª¨ë“ˆ
import csv_searcher

# STAR DB ê²€ìƒ‰ ëª¨ë“ˆ
import star_searcher

# MongoDB/Logpresso ê²€ìƒ‰ ëª¨ë“ˆ
import mongo_searcher

# M14 ì˜ˆì¸¡ ëª¨ë“ˆ
import m14_predictor

# HUB ì˜ˆì¸¡ ëª¨ë“ˆ
import hub_predictor_numerical
import hub_predictor_categorical

# LLM í›„ì²˜ë¦¬ ëª¨ë“ˆ
from llm_postprocessor import clean_llm_response, get_llm_analysis, get_prediction_llm_analysis

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

app = FastAPI()

# ì „ì—­ ë³€ìˆ˜
COLUMN_DEFINITIONS = ""

# ========== Qwen3-Coder API ì„¤ì • ==========
QWEN_API_URL = "http://ë¦¬ëˆ…ìŠ¤ì„œë²„IP:8000"  # â† ì—¬ê¸°ì— ë¦¬ëˆ…ìŠ¤ ì„œë²„ IP ì…ë ¥


def call_qwen_api(message: str, system: str = "You are a helpful assistant. í•œêµ­ì–´ë¡œ ë‹µë³€í•´ì£¼ì„¸ìš”.", max_tokens: int = 256) -> str:
    """Qwen3-Coder API í˜¸ì¶œ"""
    try:
        resp = requests.post(
            f"{QWEN_API_URL}/chat",
            json={"message": message, "system": system},
            timeout=180
        )
        if resp.status_code == 200:
            return resp.json().get('response', '')
        else:
            logger.error(f"Qwen API ì—ëŸ¬: {resp.status_code}")
            return None
    except Exception as e:
        logger.error(f"Qwen API í˜¸ì¶œ ì‹¤íŒ¨: {e}")
        return None


def is_qwen_available() -> bool:
    """Qwen API ì„œë²„ ìƒíƒœ í™•ì¸"""
    try:
        resp = requests.get(f"{QWEN_API_URL}/health", timeout=5)
        return resp.status_code == 200
    except:
        return False


def load_column_definitions():
    """ì»¬ëŸ¼ ì •ì˜ íŒŒì¼ ë¡œë“œ"""
    try:
        with open("column_definitions_short.txt", "r", encoding="utf-8") as f:
            return f.read()
    except:
        try:
            with open("column_definitions.txt", "r", encoding="utf-8") as f:
                return f.read()
        except Exception as e:
            logger.error(f"ì»¬ëŸ¼ ì •ì˜ ë¡œë“œ ì‹¤íŒ¨: {e}")
            return ""


@app.on_event("startup")
async def startup():
    """ì„œë²„ ì‹œì‘ ì‹œ ì´ˆê¸°í™”"""
    global COLUMN_DEFINITIONS
    
    # 0. ì»¬ëŸ¼ ì •ì˜ ë¡œë“œ
    COLUMN_DEFINITIONS = load_column_definitions()
    logger.info("âœ… ì»¬ëŸ¼ ì •ì˜ ë¡œë“œ ì™„ë£Œ")
    
    # 1. CSV ë¡œë“œ
    CSV_PATH = "./csv/with.csv"
    if os.path.exists(CSV_PATH):
        if csv_searcher.load_csv(CSV_PATH):
            logger.info("âœ… CSV ë¡œë“œ ì™„ë£Œ (csv_searcher)")
        else:
            logger.error("âŒ CSV ë¡œë“œ ì‹¤íŒ¨")
    else:
        logger.error(f"âŒ CSV íŒŒì¼ ì—†ìŒ: {CSV_PATH}")
    
    # 1.5. STAR DB ë¬¸ì„œ ë¡œë“œ
    if star_searcher.load_md():
        logger.info("âœ… STAR DB ë¬¸ì„œ ë¡œë“œ ì™„ë£Œ")
    else:
        logger.warning("âš ï¸ STAR DB ë¬¸ì„œ ë¡œë“œ ì‹¤íŒ¨ (STAR_READ.md ì—†ìŒ)")
    
    # 1.6. MongoDB/Logpresso ë¬¸ì„œ ë¡œë“œ
    if mongo_searcher.load_md():
        logger.info("âœ… MongoDB/Logpresso ë¬¸ì„œ ë¡œë“œ ì™„ë£Œ")
    else:
        logger.warning("âš ï¸ MongoDB/Logpresso ë¬¸ì„œ ë¡œë“œ ì‹¤íŒ¨ (MOGO_Read.md ì—†ìŒ)")
    
    # 2. Qwen3-Coder API ì—°ê²° í™•ì¸
    if is_qwen_available():
        logger.info("âœ… Qwen3-Coder API ì—°ê²°ë¨")
    else:
        logger.warning("âš ï¸ Qwen3-Coder API ì—°ê²° ì•ˆë¨ - ë¦¬ëˆ…ìŠ¤ ì„œë²„ í™•ì¸ í•„ìš”")


def get_llm_summary(text: str, prompt_suffix: str) -> str:
    """Qwen APIë¡œ ìš”ì•½ ìƒì„±"""
    prompt = f"{text}\n\n{prompt_suffix}"
    result = call_qwen_api(prompt, system="ë°˜ë“œì‹œ í•œêµ­ì–´ë¡œë§Œ ë‹µë³€í•˜ì„¸ìš”. ê°„ê²°í•˜ê²Œ ë‹µë³€í•˜ì„¸ìš”.")
    return result if result else None


class Query(BaseModel):
    question: str
    mode: str = "search"


class PredictQuery(BaseModel):
    mode: str
    data: str


class CodeQuery(BaseModel):
    question: str
    system: str = "You are a helpful coding assistant. í•œêµ­ì–´ë¡œ ë‹µë³€í•´ì£¼ì„¸ìš”."


@app.get("/")
async def home():
    """ë©”ì¸ í˜ì´ì§€"""
    return FileResponse("index.html")


@app.get("/columns")
async def get_columns():
    """ì»¬ëŸ¼ ëª©ë¡ ë°˜í™˜"""
    return {"columns": csv_searcher.get_columns()}


@app.get("/stats/{column}")
async def get_column_stats(column: str):
    """ì»¬ëŸ¼ í†µê³„ ë°˜í™˜"""
    return csv_searcher.get_statistics(column)


@app.post("/code")
async def code_assistant(query: CodeQuery):
    """Qwen3-Coderë¡œ ì½”ë“œ ìƒì„±"""
    try:
        if not is_qwen_available():
            return {"answer": "âŒ Qwen3-Coder API ì„œë²„ê°€ ì—°ê²°ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤."}
        
        logger.info(f"Qwen3-Coder ìš”ì²­: {query.question[:50]}...")
        response = call_qwen_api(query.question, query.system)
        
        if response:
            return {"answer": f"ğŸ¤– Qwen3-Coder:\n\n{response}"}
        else:
            return {"answer": "âŒ Qwen3-Coder ì‘ë‹µ ì‹¤íŒ¨"}
    
    except Exception as e:
        logger.error(f"ì½”ë“œ ìƒì„± ì‹¤íŒ¨: {e}")
        return {"answer": f"âŒ ì˜¤ë¥˜: {str(e)}"}


@app.post("/ask")
async def ask(query: Query):
    """RAG ì§ˆë¬¸ ì²˜ë¦¬"""
    global COLUMN_DEFINITIONS
    
    try:
        logger.info(f"ì§ˆë¬¸: {query.question} | ëª¨ë“œ: {query.mode}")
        
        if query.mode == "search":
            
            # â­ MongoDB/Logpresso ì¿¼ë¦¬ ë¨¼ì € ì²´í¬
            if mongo_searcher.is_mongo_query(query.question):
                logger.info("MongoDB/Logpresso ê²€ìƒ‰ ê°ì§€")
                section_key, answer = mongo_searcher.search(query.question)
                
                # Qwen APIë¡œ ìš”ì•½
                if is_qwen_available():
                    summary = get_llm_summary(answer[:500], "ìœ„ ì ‘ì† ì •ë³´ë¥¼ í•œêµ­ì–´ 1ë¬¸ì¥ìœ¼ë¡œ ìš”ì•½í•˜ì„¸ìš”.")
                    if summary:
                        import re
                        summary = re.sub(r'<think>.*?</think>', '', summary, flags=re.DOTALL).strip()
                    
                    if not summary or len(summary) < 5:
                        # í…œí”Œë¦¿ í´ë°±
                        if 'MongoDB' in answer and 'ì´ì²œ' in answer:
                            summary = "ì´ì²œ MongoDB í´ëŸ¬ìŠ¤í„° ì ‘ì† ì •ë³´ì…ë‹ˆë‹¤."
                        elif 'MongoDB' in answer and 'ì²­ì£¼' in answer:
                            summary = "ì²­ì£¼ MongoDB í´ëŸ¬ìŠ¤í„° ì ‘ì† ì •ë³´ì…ë‹ˆë‹¤."
                        elif 'Logpresso' in answer and 'ì´ì²œ' in answer:
                            summary = "ì´ì²œ Logpresso ë¡œê·¸ ì„œë²„ ì ‘ì† ì •ë³´ì…ë‹ˆë‹¤."
                        elif 'Logpresso' in answer and 'ì²­ì£¼' in answer:
                            summary = "ì²­ì£¼ Logpresso ë¡œê·¸ ì„œë²„ ì ‘ì† ì •ë³´ì…ë‹ˆë‹¤."
                        elif 'Logpresso' in answer and 'ìš°ì‹œ' in answer:
                            summary = "ìš°ì‹œ Logpresso ë¡œê·¸ ì„œë²„ ì ‘ì† ì •ë³´ì…ë‹ˆë‹¤."
                        else:
                            summary = "MongoDB/Logpresso ì ‘ì† ì •ë³´ì…ë‹ˆë‹¤."
                    
                    answer += f"\n---\nğŸ¤– ìš”ì•½: {summary}"
                
                return {"answer": answer}
            
            # â­ STAR DB ì¿¼ë¦¬ ì²´í¬
            if star_searcher.is_star_query(query.question):
                logger.info("STAR DB ê²€ìƒ‰ ê°ì§€")
                section_key, answer = star_searcher.search(query.question)
                
                # Qwen APIë¡œ ìš”ì•½
                if is_qwen_available():
                    summary = get_llm_summary(answer, "ìœ„ DB ì ‘ì† ì •ë³´ë¥¼ í•œêµ­ì–´ 1ë¬¸ì¥ìœ¼ë¡œ ìš”ì•½í•˜ì„¸ìš”.")
                    if summary:
                        import re
                        summary = re.sub(r'<think>.*?</think>', '', summary, flags=re.DOTALL).strip()
                    
                    if not summary or len(summary) < 5:
                        # í…œí”Œë¦¿ í´ë°±
                        if 'ì²­ì£¼' in answer and 'ìš´ì˜' in answer:
                            summary = "ì²­ì£¼ ìš´ì˜ í™˜ê²½ Oracle RAC DB ì ‘ì† ì •ë³´ì…ë‹ˆë‹¤."
                        elif 'ì²­ì£¼' in answer and 'QA' in answer:
                            summary = "ì²­ì£¼ QA í™˜ê²½ Oracle RAC DB ì ‘ì† ì •ë³´ì…ë‹ˆë‹¤."
                        elif 'ì´ì²œ' in answer and 'ìš´ì˜' in answer:
                            summary = "ì´ì²œ ìš´ì˜ í™˜ê²½ Oracle RAC DB ì ‘ì† ì •ë³´ì…ë‹ˆë‹¤."
                        elif 'ì´ì²œ' in answer and 'QA' in answer:
                            summary = "ì´ì²œ QA í™˜ê²½ Oracle RAC DB ì ‘ì† ì •ë³´ì…ë‹ˆë‹¤."
                        else:
                            summary = "STAR DB ì ‘ì† ì •ë³´ì…ë‹ˆë‹¤."
                    
                    answer += f"\n---\nğŸ¤– ìš”ì•½: {summary}"
                
                return {"answer": answer}
            
            # csv_searcherë¡œ ê²€ìƒ‰
            result, data_text = csv_searcher.search_csv(query.question)
            
            if result is None:
                return {"answer": data_text}
            
            # 1. ì •í™•í•œ ë°ì´í„° ë¨¼ì €
            answer = f"ğŸ“Š ê²€ìƒ‰ ê²°ê³¼\n{data_text}\n"
            
            # 2. Qwen APIë¡œ ë¶„ì„ ì¶”ê°€
            if is_qwen_available():
                analysis_prompt = f"{data_text}\n\nìœ„ ë°ì´í„°ë¥¼ í•œêµ­ì–´ 3-4ë¬¸ì¥ìœ¼ë¡œ ë¶„ì„í•˜ì„¸ìš”."
                analysis = call_qwen_api(analysis_prompt, system="You are a data analyst. í•œêµ­ì–´ë¡œ ê°„ê²°í•˜ê²Œ ë¶„ì„í•˜ì„¸ìš”.")
                if analysis:
                    answer += f"\n---\nğŸ¤– LLM ë¶„ì„\n{analysis}"
            
            return {"answer": answer}
        
        elif query.mode == "m14":
            data_text = "M14 ì˜ˆì¸¡ ê¸°ëŠ¥ì€ ì¤€ë¹„ ì¤‘ì…ë‹ˆë‹¤.\ní˜„ì¬ëŠ” ë°ì´í„° ê²€ìƒ‰ë§Œ ê°€ëŠ¥í•©ë‹ˆë‹¤."
            return {"answer": data_text}
        
        elif query.mode == "hub":
            data_text = "HUB ì˜ˆì¸¡ ê¸°ëŠ¥ì€ ì¤€ë¹„ ì¤‘ì…ë‹ˆë‹¤.\ní˜„ì¬ëŠ” ë°ì´í„° ê²€ìƒ‰ë§Œ ê°€ëŠ¥í•©ë‹ˆë‹¤."
            return {"answer": data_text}
        
        else:
            result, data_text = csv_searcher.search_csv(query.question)
            if result is None:
                return {"answer": data_text}
            return {"answer": data_text}
        
    except Exception as e:
        logger.error(f"ì²˜ë¦¬ ì‹¤íŒ¨: {e}")
        import traceback
        logger.error(traceback.format_exc())
        return {"answer": f"âŒ ì˜¤ë¥˜: {str(e)}"}


@app.post("/predict")
async def predict(query: PredictQuery):
    """M14/HUB ì˜ˆì¸¡ ì²˜ë¦¬"""
    try:
        logger.info(f"ì˜ˆì¸¡ ìš”ì²­: ëª¨ë“œ={query.mode}")
        
        if query.mode == "m14":
            result = m14_predictor.predict_m14(query.data)
            
            if 'error' in result:
                return JSONResponse(content=result, status_code=400)
            
            # HTML ëŒ€ì‹œë³´ë“œ ì €ì¥
            timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
            dashboard_filename = f'M14_Dashboard_{timestamp}.html'
            dashboard_path = os.path.join('dashboards', dashboard_filename)
            
            os.makedirs('dashboards', exist_ok=True)
            with open(dashboard_path, 'w', encoding='utf-8') as f:
                f.write(result['dashboard_html'])
            
            logger.info(f"ëŒ€ì‹œë³´ë“œ ì €ì¥: {dashboard_filename}")
            
            # ìš”ì•½ ìƒì„±
            summary = generate_prediction_summary(result)
            
            # Qwen APIë¡œ ë¶„ì„
            llm_analysis = ""
            if is_qwen_available():
                llm_analysis = generate_llm_analysis_api(result)
            
            return {
                "success": True,
                "summary": summary,
                "llm_analysis": llm_analysis,
                "dashboard_url": f"/dashboard/{dashboard_filename}",
                "predictions": result['predictions'],
                "current_value": result['current_value'],
                "current_status": result['current_status']
            }
        
        elif query.mode == "hub":
            result_numerical = hub_predictor_numerical.predict_hub_numerical(query.data)
            result_categorical = hub_predictor_categorical.predict_hub_categorical(query.data)
            
            if 'error' in result_numerical:
                return JSONResponse(content=result_numerical, status_code=400)
            
            if 'error' in result_categorical:
                return JSONResponse(content=result_categorical, status_code=400)
            
            # HTML ëŒ€ì‹œë³´ë“œ ì €ì¥
            timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
            
            dashboard_numerical_filename = f'HUB_Numerical_{timestamp}.html'
            dashboard_numerical_path = os.path.join('dashboards', dashboard_numerical_filename)
            
            dashboard_categorical_filename = f'HUB_Categorical_{timestamp}.html'
            dashboard_categorical_path = os.path.join('dashboards', dashboard_categorical_filename)
            
            os.makedirs('dashboards', exist_ok=True)
            
            with open(dashboard_numerical_path, 'w', encoding='utf-8') as f:
                f.write(result_numerical['dashboard_html'])
            
            with open(dashboard_categorical_path, 'w', encoding='utf-8') as f:
                f.write(result_categorical['dashboard_html'])
            
            logger.info(f"ëŒ€ì‹œë³´ë“œ ì €ì¥: {dashboard_numerical_filename}, {dashboard_categorical_filename}")
            
            # ìš”ì•½ ìƒì„±
            summary = generate_hub_summary(result_numerical, result_categorical)
            
            # Qwen APIë¡œ ë¶„ì„
            llm_analysis = ""
            if is_qwen_available():
                llm_analysis = generate_hub_llm_analysis_api(result_numerical, result_categorical)
            
            return {
                "success": True,
                "summary": summary,
                "llm_analysis": llm_analysis,
                "dashboard_numerical_url": f"/dashboard/{dashboard_numerical_filename}",
                "dashboard_categorical_url": f"/dashboard/{dashboard_categorical_filename}",
                "predictions_numerical": result_numerical['predictions'],
                "predictions_categorical": result_categorical['predictions'],
                "current_value": result_numerical['current_value']
            }
        
        else:
            return {
                "error": "Invalid mode",
                "message": "modeëŠ” 'm14' ë˜ëŠ” 'hub'ì—¬ì•¼ í•©ë‹ˆë‹¤."
            }
        
    except Exception as e:
        logger.error(f"ì˜ˆì¸¡ ì‹¤íŒ¨: {e}")
        import traceback
        logger.error(traceback.format_exc())
        return JSONResponse(
            content={"error": "Prediction failed", "message": str(e)},
            status_code=500
        )


def generate_prediction_summary(result):
    """M14 ì˜ˆì¸¡ ê²°ê³¼ ê°„ë‹¨ ìš”ì•½"""
    predictions = result['predictions']
    current_val = result['current_value']
    current_status = result['current_status']
    
    summary = f"ğŸ“Š í˜„ì¬: {current_val:,} ({current_status})\n\n"
    summary += "ğŸ”® ì˜ˆì¸¡:\n"
    
    for pred in predictions:
        status_emoji = {
            'LOW': 'âœ…',
            'NORMAL': 'ğŸŸ¢',
            'CAUTION': 'âš ï¸',
            'CRITICAL': 'ğŸš¨'
        }.get(pred['status'], 'â“')
        
        summary += f"â€¢ {pred['horizon']}ë¶„: {pred['prediction']:,} {status_emoji} (ìœ„í—˜ {pred['danger_probability']}%)\n"
    
    return summary


def generate_hub_summary(result_numerical, result_categorical):
    """HUB ì˜ˆì¸¡ ê²°ê³¼ ê°„ë‹¨ ìš”ì•½"""
    current_val = result_numerical['current_value']
    
    pred_num = result_numerical['predictions']
    pred_cat = result_categorical['predictions']
    
    summary = f"ğŸ“Š í˜„ì¬: {current_val:,.1f}\n\n"
    summary += "ğŸ”¢ ìˆ˜ì¹˜í˜• ì˜ˆì¸¡:\n"
    
    for pred in pred_num:
        status_emoji = {
            'NORMAL': 'âœ…',
            'CAUTION': 'âš ï¸',
            'WARNING': 'ğŸŸ ',
            'CRITICAL': 'ğŸš¨'
        }.get(pred['status'], 'â“')
        
        summary += f"â€¢ {pred['horizon']}ë¶„: {pred['pred_min']:.1f} ~ {pred['pred_max']:.1f} {status_emoji}\n"
    
    summary += "\nğŸ¯ ë²”ì£¼í˜• ì˜ˆì¸¡:\n"
    
    for pred in pred_cat:
        status_emoji = {
            'LOW': 'âœ…',
            'MEDIUM': 'âš ï¸',
            'HIGH': 'ğŸŸ ',
            'CRITICAL': 'ğŸš¨'
        }.get(pred['status'], 'â“')
        
        summary += f"â€¢ {pred['horizon']}ë¶„: {pred['class_name']} (ê¸‰ì¦ {pred['prob2']:.1f}%) {status_emoji}\n"
    
    return summary


def generate_llm_analysis_api(result):
    """Qwen APIë¡œ M14 ì˜ˆì¸¡ ê²°ê³¼ ë¶„ì„"""
    predictions = result['predictions']
    current_val = result['current_value']
    current_status = result['current_status']
    
    current_m14b = result.get('current_m14b', 0)
    current_m14bsum = result.get('current_m14bsum', 0)
    current_gap = result.get('current_gap', 0)
    current_trans = result.get('current_trans', 0)
    
    max_danger = max(p['danger_probability'] for p in predictions)
    
    pred_text = ""
    for pred in predictions:
        pred_text += f"{pred['horizon']}ë¶„ í›„: {pred['prediction']:,} (ìœ„í—˜ë„ {pred['danger_probability']}%)\n"
    
    prompt = f"""í˜„ì¬ AMHS ë¬¼ë¥˜ ìƒí™©:
- TOTALCNT: {current_val:,} ({current_status})
- M14AM14B: {current_m14b:.0f} (ì„ê³„ê°’: 517ì£¼ì˜/520ì‹¬ê°)
- M14AM14BSUM: {current_m14bsum:.0f} (ì„ê³„ê°’: 576ì£¼ì˜/588ì‹¬ê°)
- queue_gap: {current_gap:.0f} (ì„ê³„ê°’: 300ìœ„í—˜)
- TRANSPORT: {current_trans:.0f} (ì„ê³„ê°’: 151ì£¼ì˜/180ì‹¬ê°)

ì˜ˆì¸¡ ê²°ê³¼:
{pred_text}

ìœ„ ë°ì´í„°ë¥¼ ë°”íƒ•ìœ¼ë¡œ í•œêµ­ì–´ 3-4ë¬¸ì¥ìœ¼ë¡œ ë¶„ì„í•˜ì„¸ìš”:
1. ì™œ ìœ„í—˜ë„ê°€ ë†’ì€ì§€ êµ¬ì²´ì  ì´ìœ 
2. ì˜ˆì¸¡ë˜ëŠ” ì¶”ì„¸
3. ê¶Œì¥ ì¡°ì¹˜ì‚¬í•­"""
    
    response = call_qwen_api(prompt, system="You are an AMHS logistics analyst. í•œêµ­ì–´ë¡œ ê°„ê²°í•˜ê²Œ ë¶„ì„í•˜ì„¸ìš”.")
    
    if response:
        return response
    else:
        # í…œí”Œë¦¿ í´ë°±
        return f"í˜„ì¬ TOTALCNT {current_val:,}ì´ë©°, ìµœëŒ€ ìœ„í—˜ë„ {max_danger}%ì…ë‹ˆë‹¤. ì§€ì†ì ì¸ ëª¨ë‹ˆí„°ë§ì´ í•„ìš”í•©ë‹ˆë‹¤."


def generate_hub_llm_analysis_api(result_numerical, result_categorical):
    """Qwen APIë¡œ HUB ì˜ˆì¸¡ ê²°ê³¼ ë¶„ì„"""
    current_val = result_numerical['current_value']
    
    pred_num = result_numerical['predictions']
    pred_cat = result_categorical['predictions']
    
    max_surge_prob = max(p['prob2'] for p in pred_cat)
    max_pred_value = max(p['pred_max'] for p in pred_num)
    
    pred_text = ""
    for pred in pred_num:
        pred_text += f"{pred['horizon']}ë¶„ í›„: {pred['pred_min']:.1f} ~ {pred['pred_max']:.1f}\n"
    
    for pred in pred_cat:
        pred_text += f"{pred['horizon']}ë¶„ í›„ ê¸‰ì¦í™•ë¥ : {pred['prob2']:.1f}%\n"
    
    prompt = f"""í˜„ì¬ HUB ë¬¼ë¥˜ ìƒí™©:
- í˜„ì¬ê°’: {current_val:.1f} (ì„ê³„ê°’: 270ì •ìƒ/280ì£¼ì˜/300ì‹¬ê°)
- ìµœëŒ€ ì˜ˆì¸¡ê°’: {max_pred_value:.1f}
- ìµœëŒ€ ê¸‰ì¦ í™•ë¥ : {max_surge_prob:.1f}%

ì˜ˆì¸¡ ê²°ê³¼:
{pred_text}

ìœ„ ë°ì´í„°ë¥¼ ë°”íƒ•ìœ¼ë¡œ í•œêµ­ì–´ 3-4ë¬¸ì¥ìœ¼ë¡œ ë¶„ì„í•˜ì„¸ìš”:
1. ì™œ ìœ„í—˜í•œì§€ êµ¬ì²´ì  ì´ìœ 
2. ì˜ˆì¸¡ ì¶”ì„¸
3. ê¶Œì¥ ì¡°ì¹˜ì‚¬í•­"""
    
    response = call_qwen_api(prompt, system="You are a HUB logistics analyst. í•œêµ­ì–´ë¡œ ê°„ê²°í•˜ê²Œ ë¶„ì„í•˜ì„¸ìš”.")
    
    if response:
        return response
    else:
        # í…œí”Œë¦¿ í´ë°±
        return f"í˜„ì¬ê°’ {current_val:.1f}, ìµœëŒ€ ì˜ˆì¸¡ê°’ {max_pred_value:.1f}, ê¸‰ì¦ í™•ë¥  {max_surge_prob:.1f}%ì…ë‹ˆë‹¤. ëª¨ë‹ˆí„°ë§ì´ í•„ìš”í•©ë‹ˆë‹¤."


@app.get("/dashboard/{filename}")
async def get_dashboard(filename: str):
    """ìƒì„±ëœ HTML ëŒ€ì‹œë³´ë“œ ë°˜í™˜"""
    filepath = os.path.join("dashboards", filename)
    
    if not os.path.exists(filepath):
        return JSONResponse(
            content={"error": "File not found"},
            status_code=404
        )
    
    return FileResponse(filepath)


if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="127.0.0.1", port=8000)