<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>SK hynix ì´ì²œìº í¼ìŠ¤ 3D</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@300;400;600;700;900&display=swap');
  
  * { margin: 0; padding: 0; box-sizing: border-box; }
  
  body {
    background: #0a0a0f;
    color: #e0e0e0;
    font-family: 'Noto Sans KR', sans-serif;
    overflow: hidden;
    width: 100vw;
    height: 100vh;
  }

  #canvas-container {
    width: 100%;
    height: 100%;
    position: relative;
  }

  canvas { display: block; }

  /* Title overlay */
  .title-overlay {
    position: fixed;
    top: 20px;
    left: 24px;
    text-align: left;
    z-index: 100;
    pointer-events: none;
  }
  .title-overlay h1 {
    font-size: 22px;
    font-weight: 900;
    letter-spacing: 2px;
    color: #fff;
    text-shadow: 0 2px 20px rgba(0,0,0,0.8);
    margin-bottom: 4px;
  }
  .title-overlay p {
    font-size: 11px;
    color: #888;
    letter-spacing: 4px;
    text-transform: uppercase;
  }

  /* Info panel */
  .info-panel {
    position: fixed;
    bottom: 24px;
    left: 24px;
    background: rgba(10,10,20,0.85);
    backdrop-filter: blur(20px);
    border: 1px solid rgba(255,255,255,0.08);
    border-radius: 12px;
    padding: 16px 20px;
    z-index: 100;
    min-width: 220px;
    transition: all 0.3s ease;
  }
  .info-panel .building-name {
    font-size: 18px;
    font-weight: 700;
    color: #fff;
    margin-bottom: 4px;
  }
  .info-panel .building-type {
    font-size: 11px;
    color: #888;
    letter-spacing: 1px;
    text-transform: uppercase;
    margin-bottom: 8px;
  }
  .info-panel .building-detail {
    font-size: 12px;
    color: #aaa;
    line-height: 1.6;
  }
  .info-panel .color-dot {
    display: inline-block;
    width: 8px;
    height: 8px;
    border-radius: 50%;
    margin-right: 6px;
    vertical-align: middle;
  }

  /* Legend */
  .legend {
    position: fixed;
    top: 24px;
    right: 24px;
    background: rgba(10,10,20,0.85);
    backdrop-filter: blur(20px);
    border: 1px solid rgba(255,255,255,0.08);
    border-radius: 12px;
    padding: 14px 18px;
    z-index: 100;
    font-size: 11px;
  }
  .legend-title {
    font-size: 10px;
    color: #666;
    letter-spacing: 2px;
    text-transform: uppercase;
    margin-bottom: 10px;
  }
  .legend-item {
    display: flex;
    align-items: center;
    margin-bottom: 6px;
    color: #aaa;
  }
  .legend-item .swatch {
    width: 14px;
    height: 14px;
    border-radius: 3px;
    margin-right: 8px;
    flex-shrink: 0;
  }

  /* Controls hint */
  .controls-hint {
    position: fixed;
    bottom: 24px;
    right: 24px;
    background: rgba(10,10,20,0.7);
    backdrop-filter: blur(12px);
    border: 1px solid rgba(255,255,255,0.06);
    border-radius: 10px;
    padding: 10px 14px;
    z-index: 100;
    font-size: 10px;
    color: #666;
    line-height: 1.8;
  }
  .controls-hint kbd {
    background: rgba(255,255,255,0.08);
    border: 1px solid rgba(255,255,255,0.12);
    border-radius: 3px;
    padding: 1px 5px;
    font-family: inherit;
    color: #999;
  }

  /* Loading */
  .loading {
    position: fixed;
    inset: 0;
    display: flex;
    align-items: center;
    justify-content: center;
    background: #0a0a0f;
    z-index: 999;
    transition: opacity 0.8s ease;
  }
  .loading.hidden { opacity: 0; pointer-events: none; }
  .loading-text {
    font-size: 14px;
    color: #555;
    letter-spacing: 6px;
    text-transform: uppercase;
    animation: pulse 1.5s ease-in-out infinite;
  }
  @keyframes pulse { 0%,100%{opacity:0.3} 50%{opacity:1} }

  /* Minimap */
  #minimap {
    position: fixed;
    bottom: 24px;
    right: 24px;
    width: 150px;
    height: 130px;
    background: rgba(10,10,20,0.9);
    backdrop-filter: blur(16px);
    border: 1px solid rgba(255,255,255,0.1);
    border-radius: 12px;
    z-index: 150;
    overflow: hidden;
    cursor: pointer;
  }
  #minimap canvas {
    display: block;
    width: 100%;
    height: 100%;
  }
  .minimap-label {
    position: absolute;
    top: 6px;
    left: 10px;
    font-size: 9px;
    color: #555;
    letter-spacing: 2px;
    text-transform: uppercase;
    pointer-events: none;
  }
  .minimap-compass {
    position: absolute;
    top: 6px;
    right: 10px;
    font-size: 9px;
    color: #666;
    pointer-events: none;
    letter-spacing: 1px;
  }

  /* Tooltip */
  #tooltip {
    position: fixed;
    pointer-events: none;
    background: rgba(0,0,0,0.85);
    backdrop-filter: blur(8px);
    border: 1px solid rgba(255,255,255,0.15);
    border-radius: 6px;
    padding: 6px 10px;
    font-size: 12px;
    color: #fff;
    font-weight: 600;
    z-index: 200;
    display: none;
    white-space: nowrap;
    transform: translate(-50%, -120%);
  }

  /* ë§í’ì„  */
  #speechBubble {
    position: fixed;
    pointer-events: none;
    z-index: 300;
    display: none;
    transform: translate(-50%, -130%);
    animation: bubblePop 0.3s ease-out;
  }
  #speechBubble .bubble-inner {
    background: rgba(255,255,255,0.95);
    color: #222;
    font-size: 14px;
    font-weight: 600;
    padding: 10px 16px;
    border-radius: 14px;
    box-shadow: 0 4px 20px rgba(0,0,0,0.3);
    white-space: nowrap;
    position: relative;
  }
  #speechBubble .bubble-inner::after {
    content: '';
    position: absolute;
    bottom: -8px;
    left: 50%;
    transform: translateX(-50%);
    border-left: 8px solid transparent;
    border-right: 8px solid transparent;
    border-top: 8px solid rgba(255,255,255,0.95);
  }
  @keyframes bubblePop {
    0% { transform: translate(-50%, -130%) scale(0.3); opacity: 0; }
    60% { transform: translate(-50%, -130%) scale(1.1); opacity: 1; }
    100% { transform: translate(-50%, -130%) scale(1); opacity: 1; }
  }
</style>
</head>
<body>

<div class="loading" id="loading">
  <div class="loading-text">Building Campus...</div>
</div>

<div class="title-overlay">
  <h1>SK hynix ì´ì²œìº í¼ìŠ¤</h1>
  <p>3D Campus Visualization</p>
</div>

<div class="legend">
  <div class="legend-title">ë²”ë¡€</div>
  <div class="legend-item"><div class="swatch" style="background:#ecc94b"></div>M14 DRAM FAB</div>
  <div class="legend-item"><div class="swatch" style="background:#48bb78"></div>M16 DRAM FAB</div>
  <div class="legend-item"><div class="swatch" style="background:#63b3ed"></div>M10 FAB</div>
  <div class="legend-item"><div class="swatch" style="background:#e07098"></div>DRAM WT (ê²€ì‚¬ë™)</div>
  <div class="legend-item"><div class="swatch" style="background:#c4956a"></div>P&T (íŒ¨í‚¤ì§€Â·í…ŒìŠ¤íŠ¸)</div>
  <div class="legend-item"><div class="swatch" style="background:#44aaee"></div>OHT ì—°ê²°í†µë¡œ</div>
</div>

<div id="timeToggle" style="position:fixed;top:75px;left:24px;z-index:200;background:rgba(10,10,20,0.85);border-radius:10px;border:1px solid rgba(255,255,255,0.1);backdrop-filter:blur(8px);user-select:none;">
  <div id="timeToggleHeader" style="display:flex;align-items:center;justify-content:space-between;padding:6px 12px;cursor:move;">
    <span style="font-size:11px;color:#666;letter-spacing:1px;">â° ì‹œê°„ ì„¤ì •</span>
    <button id="btnCollapse" onclick="toggleTimePanel()" style="background:none;border:none;color:#888;cursor:pointer;font-size:14px;padding:0 4px;">â–¼</button>
  </div>
  <div id="timeToggleBody" style="display:none;gap:6px;padding:4px 12px 8px 12px;">
    <button id="btnMorning" onclick="setTimeMode('morning')" style="padding:6px 14px;border:none;border-radius:6px;cursor:pointer;font-size:13px;font-weight:600;background:rgba(255,180,50,0.2);color:#ffcc66;transition:all 0.3s;">ğŸŒ… ì•„ì¹¨</button>
    <button id="btnAuto" onclick="setTimeMode('auto')" style="padding:6px 14px;border:none;border-radius:6px;cursor:pointer;font-size:13px;font-weight:600;background:rgba(100,200,255,0.3);color:#88ddff;transition:all 0.3s;box-shadow:0 0 8px rgba(100,200,255,0.3);">ğŸ• ì‹¤ì‹œê°„</button>
    <button id="btnNight" onclick="setTimeMode('night')" style="padding:6px 14px;border:none;border-radius:6px;cursor:pointer;font-size:13px;font-weight:600;background:rgba(100,100,200,0.2);color:#aabbdd;transition:all 0.3s;">ğŸŒ™ ë°¤</button>
  </div>
</div>
<script>
// ì ‘ê¸°/í¼ì¹˜ê¸°
function toggleTimePanel() {
  const body = document.getElementById('timeToggleBody');
  const btn = document.getElementById('btnCollapse');
  if (body.style.display === 'none') {
    body.style.display = 'flex';
    btn.textContent = 'â–²';
  } else {
    body.style.display = 'none';
    btn.textContent = 'â–¼';
  }
}
// ë“œë˜ê·¸ ì´ë™
(function() {
  const panel = document.getElementById('timeToggle');
  const header = document.getElementById('timeToggleHeader');
  let dragging = false, offX = 0, offY = 0;
  header.addEventListener('mousedown', function(e) {
    if (e.target.id === 'btnCollapse') return;
    dragging = true;
    const rect = panel.getBoundingClientRect();
    offX = e.clientX - rect.left;
    offY = e.clientY - rect.top;
    e.preventDefault();
  });
  document.addEventListener('mousemove', function(e) {
    if (!dragging) return;
    panel.style.left = (e.clientX - offX) + 'px';
    panel.style.top = (e.clientY - offY) + 'px';
    panel.style.right = 'auto';
  });
  document.addEventListener('mouseup', function() { dragging = false; });
  // í„°ì¹˜ ì§€ì›
  header.addEventListener('touchstart', function(e) {
    if (e.target.id === 'btnCollapse') return;
    dragging = true;
    const rect = panel.getBoundingClientRect();
    offX = e.touches[0].clientX - rect.left;
    offY = e.touches[0].clientY - rect.top;
  }, {passive: true});
  document.addEventListener('touchmove', function(e) {
    if (!dragging) return;
    panel.style.left = (e.touches[0].clientX - offX) + 'px';
    panel.style.top = (e.touches[0].clientY - offY) + 'px';
    panel.style.right = 'auto';
  });
  document.addEventListener('touchend', function() { dragging = false; });
})();
</script>

<div class="info-panel" id="infoPanel">
  <div class="building-name" id="bName">SK hynix ì´ì²œ</div>
  <div class="building-type" id="bType">ìº í¼ìŠ¤ ì „ê²½</div>
  <div class="building-detail" id="bDetail">ê±´ë¬¼ì„ í´ë¦­í•˜ë©´ ìƒì„¸ì •ë³´ë¥¼ ë³¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤</div>
</div>


<div id="minimap">
  <canvas id="minimapCanvas"></canvas>
  <div class="minimap-label">MINIMAP</div>
  <div class="minimap-compass">N</div>
</div>

<div id="tooltip"></div>
<div id="speechBubble"><div class="bubble-inner" id="speechText"></div></div>
<div id="canvas-container"></div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script>
// ============================================================
// SK hynix Icheon Campus 3D Visualization
// ============================================================

const SCALE = 0.5; // scale factor for coordinates

// Building data: [name, x, y, w, h, height, color, type, detail]
const buildings = [
  // Main FABs (ê°„ê²© í™•ë³´)
  { name: 'M14A/B', x: 150, z: 280, w: 210, d: 160, h: 96, color: 0xecc94b, type: 'DRAM ìƒì‚°ë™', detail: 'M14A/B FABë™\n1a/1b nm DRAM ìƒì‚°\nìµœì‹  ê³µì • ë¼ì¸\n8ì¸µ(ì˜¥ìƒ)' },
  { name: 'M10A',   x: 160, z: 520, w: 200, d: 120, h: 65, color: 0x63b3ed, type: 'ìƒì‚°ë™', detail: 'M10A FABë™\nDRAM ìƒì‚°' },
  { name: 'M10B/R3',x: 500, z: 300, w: 140, d: 100, h: 60, color: 0x63b3ed, type: 'ìƒì‚°ë™', detail: 'M10B/R3 FABë™\nDRAM ìƒì‚°' },
  { name: 'M10C',   x: 700, z: 200, w: 160, d: 100, h: 60, color: 0x63b3ed, type: 'ìƒì‚°ë™', detail: 'M10C FABë™\nDRAM ìƒì‚°' },
  { name: 'M16A/B', x: 530, z: 520, w: 230, d: 120, h: 132, color: 0x48bb78, type: 'DRAM ìƒì‚°ë™', detail: 'M16A/B FABë™\nDRAM ìƒì‚°ë™\nAMHS ë¬¼ë¥˜ ì‹œìŠ¤í…œ ìš´ì˜\n11ì¸µ(ì˜¥ìƒ)' },
  { name: 'DRAM_WT',x: 420, z: 730, w: 150, d: 70,  h: 45, color: 0xe07098, type: 'ì›¨ì´í¼ í…ŒìŠ¤íŠ¸', detail: 'DRAM ì›¨ì´í¼ í…ŒìŠ¤íŠ¸ë™\nì›¨ì´í¼ ê²€ì‚¬ ë° í…ŒìŠ¤íŠ¸' },

  // P&T
  { name: 'P&T1',   x: 420, z: 140, w: 110, d: 80,  h: 35, color: 0xc4956a, type: 'íŒ¨í‚¤ì§€ ë° í…ŒìŠ¤íŠ¸', detail: 'P&T1 íŒ¨í‚¤ì§€ ë° í…ŒìŠ¤íŠ¸ë™' },
  { name: 'P&T4',   x: 830, z: 320, w: 140, d: 120, h: 96, color: 0xc4956a, type: 'íŒ¨í‚¤ì§€ ë° í…ŒìŠ¤íŠ¸', detail: 'P&T4 íŒ¨í‚¤ì§€ ë° í…ŒìŠ¤íŠ¸ë™\n8ì¸µ(ì˜¥ìƒ)\níŒ¨í‚¤ì§€ ë° í…ŒìŠ¤íŠ¸ ê³µì •' },
  { name: 'P&T5',   x: 780, z: 660, w: 130, d: 90,  h: 48, color: 0xc4956a, type: 'íŒ¨í‚¤ì§€ ë° í…ŒìŠ¤íŠ¸', detail: 'P&T5 íŒ¨í‚¤ì§€ ë° í…ŒìŠ¤íŠ¸ë™\n4ì¸µ(ì˜¥ìƒ)' },
];

// ============================================================
// Three.js Setup
// ============================================================
const container = document.getElementById('canvas-container');
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x0a0a12);
scene.fog = new THREE.FogExp2(0x0a0a12, 0.0006);

const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 5000);
camera.position.set(-200, 300, 450);
camera.lookAt(250, 0, 250);

const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
renderer.shadowMap.enabled = true;
renderer.shadowMap.type = THREE.PCFSoftShadowMap;
renderer.toneMapping = THREE.ACESFilmicToneMapping;
renderer.toneMappingExposure = 1.4;
container.appendChild(renderer.domElement);

// ============================================================
// Lighting
// ============================================================
const ambientLight = new THREE.AmbientLight(0x667799, 0.9);
scene.add(ambientLight);

const dirLight = new THREE.DirectionalLight(0xffeedd, 1.2);
dirLight.position.set(300, 400, 200);
dirLight.castShadow = true;
dirLight.shadow.mapSize.width = 2048;
dirLight.shadow.mapSize.height = 2048;
dirLight.shadow.camera.left = -500;
dirLight.shadow.camera.right = 500;
dirLight.shadow.camera.top = 500;
dirLight.shadow.camera.bottom = -500;
scene.add(dirLight);

const hemiLight = new THREE.HemisphereLight(0x99bbdd, 0x445566, 0.8);
scene.add(hemiLight);

// Accent light
const pointLight = new THREE.PointLight(0x4488ff, 0.3, 600);
pointLight.position.set(200, 150, 300);
scene.add(pointLight);

// ============================================================
// ì²œì²´ ì‹œìŠ¤í…œ (í•´/ë‹¬ - ì‹¤ì‹œê°„)
// ============================================================
// í•´
const sunGeo = new THREE.SphereGeometry(18, 32, 32);
const sunMat = new THREE.MeshBasicMaterial({ color: 0xffdd44 });
const sunMesh = new THREE.Mesh(sunGeo, sunMat);
scene.add(sunMesh);
// í•´ ê¸€ë¡œìš°
const sunGlowGeo = new THREE.SphereGeometry(25, 32, 32);
const sunGlowMat = new THREE.MeshBasicMaterial({ color: 0xffaa22, transparent: true, opacity: 0.2 });
const sunGlow = new THREE.Mesh(sunGlowGeo, sunGlowMat);
sunMesh.add(sunGlow);

// ë‹¬ (í¬ê³  ë°ê²Œ)
const moonGeo = new THREE.SphereGeometry(20, 32, 32);
const moonMat = new THREE.MeshBasicMaterial({ color: 0xfffff0 });
const moonMesh = new THREE.Mesh(moonGeo, moonMat);
scene.add(moonMesh);
// ë‹¬ ê¸€ë¡œìš° 1 (ë‚´ë¶€)
const moonGlowGeo = new THREE.SphereGeometry(30, 32, 32);
const moonGlowMat = new THREE.MeshBasicMaterial({ color: 0xcceeff, transparent: true, opacity: 0.25 });
const moonGlow = new THREE.Mesh(moonGlowGeo, moonGlowMat);
moonMesh.add(moonGlow);
// ë‹¬ ê¸€ë¡œìš° 2 (ì™¸ë¶€ - ë” í° í›„ê´‘)
const moonGlow2Geo = new THREE.SphereGeometry(50, 32, 32);
const moonGlow2Mat = new THREE.MeshBasicMaterial({ color: 0x99bbdd, transparent: true, opacity: 0.1 });
const moonGlow2 = new THREE.Mesh(moonGlow2Geo, moonGlow2Mat);
moonMesh.add(moonGlow2);
// ë‹¬ í¬ì¸íŠ¸ë¼ì´íŠ¸ (ë‹¬ë¹› íš¨ê³¼)
const moonLight = new THREE.PointLight(0x8899cc, 0, 800);
moonMesh.add(moonLight);

// ì²œì²´ ê¶¤ë„ ì¤‘ì‹¬ & ë°˜ì§€ë¦„ (ê°€ê¹Œì´)
const skyCenter = new THREE.Vector3(35, 0, 170);
const skyRadius = 350;

// ì•„ì¹¨/ë°¤ ì „í™˜ ëª¨ë“œ
let timeMode = 'auto'; // 'auto', 'morning', 'night'
function setTimeMode(mode) {
  timeMode = mode;
  // ë²„íŠ¼ ìŠ¤íƒ€ì¼ ì—…ë°ì´íŠ¸
  const btnM = document.getElementById('btnMorning');
  const btnA = document.getElementById('btnAuto');
  const btnN = document.getElementById('btnNight');
  btnM.style.background = mode === 'morning' ? 'rgba(255,180,50,0.5)' : 'rgba(255,180,50,0.2)';
  btnM.style.boxShadow = mode === 'morning' ? '0 0 8px rgba(255,180,50,0.4)' : 'none';
  btnA.style.background = mode === 'auto' ? 'rgba(100,200,255,0.3)' : 'rgba(100,200,255,0.1)';
  btnA.style.boxShadow = mode === 'auto' ? '0 0 8px rgba(100,200,255,0.3)' : 'none';
  btnN.style.background = mode === 'night' ? 'rgba(100,100,200,0.5)' : 'rgba(100,100,200,0.2)';
  btnN.style.boxShadow = mode === 'night' ? '0 0 8px rgba(100,100,200,0.4)' : 'none';
}

function updateSky() {
  let hours;
  if (timeMode === 'morning') {
    hours = 10; // ì˜¤ì „ 10ì‹œ (ë°ì€ ë‚®)
  } else if (timeMode === 'night') {
    hours = 0;  // ìì • (í•œë°¤ì¤‘)
  } else {
    const now = new Date();
    hours = now.getHours() + now.getMinutes() / 60;
  }

  // í•´ ê°ë„: 6ì‹œ=ë™ìª½(0ë„), 12ì‹œ=ë‚¨ìª½ ìµœê³ ì (90ë„), 18ì‹œ=ì„œìª½(180ë„)
  // ì¼ì¶œ 6ì‹œ, ì¼ëª° 18ì‹œ ê¸°ì¤€
  const sunAngle = ((hours - 6) / 12) * Math.PI; // 0~Ï€ (6ì‹œ~18ì‹œ)
  const sunUp = (hours >= 5.5 && hours <= 18.5);

  if (sunUp) {
    const sx = skyCenter.x + skyRadius * Math.cos(sunAngle);
    const sy = skyRadius * Math.sin(sunAngle) * 0.7; // ìµœê³  ë†’ì´ ì¡°ì ˆ
    const sz = skyCenter.z - 200;
    sunMesh.position.set(sx, Math.max(sy, -20), sz);
    sunMesh.visible = true;
    sunGlowMat.opacity = 0.2 + 0.15 * Math.sin(sunAngle);
  } else {
    sunMesh.visible = false;
  }

  // ë‹¬ ê°ë„: 18ì‹œ=ë™ìª½, 0ì‹œ=ìµœê³ ì , 6ì‹œ=ì„œìª½
  const moonAngle = ((hours - 18 + 24) % 24 / 12) * Math.PI;
  const moonUp = (hours >= 17.5 || hours <= 6.5);

  if (moonUp) {
    const mx = skyCenter.x - skyRadius * Math.cos(moonAngle);
    const my = skyRadius * Math.sin(moonAngle) * 0.6;
    const mz = skyCenter.z + 150;
    moonMesh.position.set(mx, Math.max(my, -20), mz);
    moonMesh.visible = true;
    // ë‹¬ ë†’ì´ì— ë”°ë¼ ë°ê¸° ì¡°ì ˆ
    const moonAlt = Math.max(0, my) / (skyRadius * 0.6);
    moonLight.intensity = 2.5 * moonAlt;
    moonGlowMat.opacity = 0.2 + 0.2 * moonAlt;
    moonGlow2Mat.opacity = 0.08 + 0.12 * moonAlt;
  } else {
    moonMesh.visible = false;
    moonLight.intensity = 0;
  }

  // í•˜ëŠ˜ìƒ‰ & ì¡°ëª… ì¡°ì ˆ
  let skyProgress; // 0=ë°¤, 1=ë‚®
  if (hours >= 6 && hours <= 18) {
    // ë‚®: 6~12 ì ì  ë°ì•„ì§, 12~18 ì ì  ì–´ë‘ì›Œì§
    skyProgress = 1 - Math.abs(hours - 12) / 6;
  } else {
    skyProgress = 0;
  }
  // ìƒˆë²½/ì„ì–‘ ì „í™˜
  if (hours >= 5 && hours < 6) skyProgress = (hours - 5) * 0.3;
  if (hours > 18 && hours <= 19) skyProgress = (19 - hours) * 0.3;

  // ë°°ê²½ìƒ‰: ë°¤(0x0a0a12) â†” ë‚®(0x4488cc)
  const nightR = 0x10/255, nightG = 0x12/255, nightB = 0x22/255;
  const dayR = 0x55/255, dayG = 0x99/255, dayB = 0xdd/255;
  const dawnR = 0x88/255, dawnG = 0x44/255, dawnB = 0x33/255;

  let r, g, b;
  if (skyProgress > 0.3) {
    // ë‚®
    const t = (skyProgress - 0.3) / 0.7;
    r = dayR * t + nightR * (1-t);
    g = dayG * t + nightG * (1-t);
    b = dayB * t + nightB * (1-t);
  } else if (skyProgress > 0) {
    // ìƒˆë²½/ì„ì–‘
    const t = skyProgress / 0.3;
    r = dawnR * t + nightR * (1-t);
    g = dawnG * t + nightG * (1-t);
    b = dawnB * t + nightB * (1-t);
  } else {
    r = nightR; g = nightG; b = nightB;
  }
  scene.background.setRGB(r, g, b);
  scene.fog.color.setRGB(r, g, b);

  // ì¡°ëª… ê°•ë„
  const dayAmbient = 1.5, nightAmbient = 0.8;
  const dayDir = 1.8, nightDir = 0.5;
  ambientLight.intensity = nightAmbient + (dayAmbient - nightAmbient) * skyProgress;
  dirLight.intensity = nightDir + (dayDir - nightDir) * skyProgress;

  // í•´ ìœ„ì¹˜ì— ë§ì¶° directional light ì´ë™
  if (sunUp) {
    dirLight.position.copy(sunMesh.position);
    dirLight.color.setHex(skyProgress > 0.3 ? 0xffeedd : 0xff8844);
  } else {
    dirLight.position.set(100, 300, 100);
    dirLight.color.setHex(0x334466);
  }

  // í†¤ë§¤í•‘ ë°ê¸°
  renderer.toneMappingExposure = 1.2 + skyProgress * 0.6;

  // ë‚®/ë°¤ ì°½ë¬¸ ì „ê¸° ì „í™˜
  const isNight = skyProgress < 0.15;
  buildingMeshes.forEach(group => {
    group.children.forEach(child => {
      if (child.userData && child.userData.isWindow) {
        if (isNight) {
          // ë°¤: ë…¸ë€ ë¶ˆë¹› ì¼œì§ (ì•¼ê²½)
          child.material.color.setHex(0xffdd88);
          child.material.emissive.setHex(0xddaa33);
          child.material.emissiveIntensity = 0.6 + Math.random() * 0.35;
          child.material.opacity = 0.8 + Math.random() * 0.2;
        } else {
          // ë‚®: ì „ê¸° êº¼ì§ - ìœ ë¦¬ ë°˜ì‚¬ë§Œ
          child.material.color.setHex(0x8ac4ed);
          child.material.emissive.setHex(0x3388bb);
          child.material.emissiveIntensity = 0.03;
          child.material.opacity = 0.3;
        }
      }
    });
  });
}

// ============================================================
// Ground
// ============================================================
const groundGeo = new THREE.PlaneGeometry(850, 800);
const groundMat = new THREE.MeshStandardMaterial({
  color: 0x141820,
  roughness: 0.95,
  metalness: 0.05,
});
const ground = new THREE.Mesh(groundGeo, groundMat);
ground.rotation.x = -Math.PI / 2;
ground.position.set(35, -0.5, 170);
ground.receiveShadow = true;
scene.add(ground);

// Grid overlay
const gridHelper = new THREE.GridHelper(850, 42, 0x14171e, 0x10121a);
gridHelper.position.set(35, 0.05, 170);
gridHelper.material.transparent = true;
gridHelper.material.opacity = 0.07;
scene.add(gridHelper);

// ============================================================
// ìº í¼ìŠ¤ ì™¸ê³½ í™˜ê²½ (ë‚˜ë¬´, ì£¼ë³€ê±´ë¬¼, ë¶€ì†ê±´ë¬¼, ì •ë¬¸)
// ============================================================

// â”€â”€ ë‚˜ë¬´ (ê°œì„ ëœ ì›ë¿”í˜• ì¹¨ì—½ìˆ˜ + í™œì—½ìˆ˜ í˜¼í•©) â”€â”€
const _trunkMat = new THREE.MeshStandardMaterial({ color: 0x5a4030, roughness: 0.9 });
const _trunkGeo = new THREE.CylinderGeometry(0.12, 0.22, 1, 5);
const _coneGeo = new THREE.ConeGeometry(1, 1, 6);
const _sphereGeo = new THREE.SphereGeometry(1, 6, 5);

function addTree(x, z) {
  const s = 2.0 + Math.random() * 2.5;
  const g = new THREE.Group();
  const isCone = Math.random() > 0.4; // 60% ì¹¨ì—½ìˆ˜, 40% í™œì—½ìˆ˜
  const lc = [0x1e5a18, 0x2d6a22, 0x1a5010, 0x2a6830, 0x1d4a12][Math.floor(Math.random()*5)];
  const lm = new THREE.MeshStandardMaterial({ color: lc, roughness: 0.8, flatShading: true });

  // ì¤„ê¸°
  const trunk = new THREE.Mesh(_trunkGeo, _trunkMat);
  trunk.scale.set(s*0.5, s*2.5, s*0.5);
  trunk.position.y = s*1.2;
  g.add(trunk);

  if (isCone) {
    // ì¹¨ì—½ìˆ˜: ê²¹ì¹œ ì›ë¿” 2~3ê°œ
    for (let i = 0; i < 2 + (Math.random()>0.5?1:0); i++) {
      const cone = new THREE.Mesh(_coneGeo, lm);
      const cs = s * (1.4 - i*0.3);
      cone.scale.set(cs, cs*1.2, cs);
      cone.position.y = s*2.2 + i*s*0.9;
      g.add(cone);
    }
  } else {
    // í™œì—½ìˆ˜: ë‘¥ê·¼ ìˆ˜ê´€
    const crown = new THREE.Mesh(_sphereGeo, lm);
    crown.scale.set(s*1.3, s*1.1, s*1.3);
    crown.position.y = s*3.2;
    g.add(crown);
  }
  g.position.set(x, 0, z);
  scene.add(g);
}

// ìº í¼ìŠ¤ ë‘˜ë ˆ ë‚˜ë¬´ (ìì—°ìŠ¤ëŸ¬ìš´ ìˆ² ëŠë‚Œ, ê±´ë¬¼ ì‚¬ì´ì‚¬ì´)
const treePosArr = [];
// ì™¼ìª½ (sparse)
for (let i = 0; i < 18; i++) { treePosArr.push([-230 + Math.random()*20, 340 - i*35 + Math.random()*12]); }
// ì˜¤ë¥¸ìª½ (sparse)
for (let i = 0; i < 18; i++) { treePosArr.push([275 + Math.random()*20, 340 - i*35 + Math.random()*12]); }
// ìœ„ìª½ (ì •ë¬¸ ì£¼ë³€ì€ ë¹ˆ ê³µê°„)
for (let i = 0; i < 8; i++) { treePosArr.push([-200 + i*20 + Math.random()*8, 380 + Math.random()*15]); }
for (let i = 0; i < 8; i++) { treePosArr.push([100 + i*20 + Math.random()*8, 380 + Math.random()*15]); }
// ì•„ë˜ìª½
for (let i = 0; i < 14; i++) { treePosArr.push([-180 + i*32 + Math.random()*10, -45 - Math.random()*20]); }
treePosArr.forEach(([x, z]) => addTree(x, z));

// â”€â”€ ì™¸ê³½ ì£¼ë³€ ê±´ë¬¼ (ì¼ë°˜ ì‹œê°€ì§€ ëŠë‚Œ) â”€â”€
function addOuterBuilding(x, z, w, d, h, color) {
  const geo = new THREE.BoxGeometry(w, h, d);
  const mat = new THREE.MeshStandardMaterial({
    color: color, roughness: 0.85, metalness: 0.05
  });
  const mesh = new THREE.Mesh(geo, mat);
  mesh.position.set(x, h/2, z);
  mesh.castShadow = true;
  mesh.receiveShadow = true;
  scene.add(mesh);

  // ì˜¥ìƒ (ì–´ë‘ìš´ ìƒ‰)
  const roofGeo = new THREE.BoxGeometry(w+0.5, 0.4, d+0.5);
  const roofMat = new THREE.MeshStandardMaterial({ color: 0x333840, roughness: 0.7 });
  const roof = new THREE.Mesh(roofGeo, roofMat);
  roof.position.set(x, h+0.2, z);
  scene.add(roof);

  // ê°„ë‹¨í•œ ì°½ë¬¸ (ì •ë©´ë§Œ)
  const winRows = Math.max(1, Math.floor(h/5));
  const winCols = Math.max(1, Math.floor(w/5));
  for (let r = 0; r < winRows; r++) {
    for (let c = 0; c < winCols; c++) {
      const wg = new THREE.PlaneGeometry(2.2, 1.8);
      const wm = new THREE.MeshStandardMaterial({
        color: 0x88bbdd, emissive: 0x224466, emissiveIntensity: 0.05,
        transparent: true, opacity: 0.35, side: THREE.DoubleSide
      });
      const win = new THREE.Mesh(wg, wm);
      win.userData.isWindow = true;
      win.position.set(x - w/2 + 3 + c*4.5, 3 + r*5, z + d/2 + 0.1);
      scene.add(win);
    }
  }
}

// ì™¸ê³½ ê±´ë¬¼ ë°°ì¹˜ (ìº í¼ìŠ¤ ë°”ê¹¥ ì‚¬ë°© - í¬ì§í•˜ê²Œ)
const outerColors = [0x667788, 0x778899, 0x606872, 0x7a8090, 0x8b8f98, 0x6e7580];

// ì™¼ìª½ ì™¸ê³½ ê±´ë¬¼êµ° (ëŒ€í˜•)
addOuterBuilding(-290, 300, 55, 40, 60, 0x778899);
addOuterBuilding(-300, 220, 48, 38, 50, 0x6e7580);
addOuterBuilding(-285, 140, 60, 45, 75, 0x8b8f98);
addOuterBuilding(-295, 55, 50, 40, 45, 0x667788);
addOuterBuilding(-288, -20, 55, 42, 58, 0x7a8090);
addOuterBuilding(-300, -85, 45, 35, 40, 0x606872);

// ì˜¤ë¥¸ìª½ ì™¸ê³½ ê±´ë¬¼êµ° (ëŒ€í˜•)
addOuterBuilding(340, 300, 50, 40, 55, 0x7a8090);
addOuterBuilding(350, 215, 55, 42, 70, 0x778899);
addOuterBuilding(335, 130, 48, 40, 52, 0x606872);
addOuterBuilding(348, 45, 45, 38, 42, 0x8b8f98);
addOuterBuilding(340, -30, 52, 40, 65, 0x6e7580);
addOuterBuilding(345, -95, 48, 36, 48, 0x667788);

// ìœ„ìª½ ì™¸ê³½ ê±´ë¬¼êµ° - ì •ë¬¸ ì‹œì•¼ í™•ë³´ë¥¼ ìœ„í•´ ì œê±°

// ì•„ë˜ìª½ ì™¸ê³½ ê±´ë¬¼êµ° (ëŒ€í˜•)
addOuterBuilding(-155, -100, 52, 40, 50, 0x778899);
addOuterBuilding(-65, -108, 48, 36, 58, 0x667788);
addOuterBuilding(35, -98, 45, 40, 44, 0x7a8090);
addOuterBuilding(120, -105, 55, 38, 52, 0x8b8f98);
addOuterBuilding(210, -100, 48, 36, 40, 0x606872);

// â”€â”€ ë¶€ì†ê±´ë¬¼ (ì´ë¦„ ë¼ë²¨ í¬í•¨) â”€â”€
function addAuxBuilding(x, z, w, d, h, color, name) {
  const geo = new THREE.BoxGeometry(w, h, d);
  const mat = new THREE.MeshStandardMaterial({
    color: color, roughness: 0.7, metalness: 0.1
  });
  const mesh = new THREE.Mesh(geo, mat);
  mesh.position.set(x, h/2, z);
  mesh.castShadow = true;
  scene.add(mesh);

  // ì˜¥ìƒ
  const rGeo = new THREE.BoxGeometry(w+0.5, 0.5, d+0.5);
  const rMat = new THREE.MeshStandardMaterial({ color: 0x444c55, roughness: 0.6 });
  const roof = new THREE.Mesh(rGeo, rMat);
  roof.position.set(x, h+0.25, z);
  scene.add(roof);

  // ê°„ë‹¨í•œ ì°½ë¬¸
  const winR = Math.max(1, Math.floor(h/5));
  const winC = Math.max(1, Math.floor(w/5));
  for (let r2 = 0; r2 < winR; r2++) {
    for (let c2 = 0; c2 < winC; c2++) {
      const wg2 = new THREE.PlaneGeometry(2, 1.6);
      const wm2 = new THREE.MeshStandardMaterial({
        color: 0x99ccee, emissive: 0x335577, emissiveIntensity: 0.05,
        transparent: true, opacity: 0.35, side: THREE.DoubleSide
      });
      const w2 = new THREE.Mesh(wg2, wm2);
      w2.userData.isWindow = true;
      w2.position.set(x - w/2 + 3 + c2*4.5, 3 + r2*5, z + d/2 + 0.1);
      scene.add(w2);
    }
  }

  // ì´ë¦„ ë¼ë²¨
  if (name) {
    const lc2 = document.createElement('canvas');
    const ctx2 = lc2.getContext('2d');
    const fs2 = 22;
    ctx2.font = '600 '+fs2+'px Noto Sans KR, sans-serif';
    const tw2 = ctx2.measureText(name).width;
    lc2.width = tw2+24; lc2.height = fs2+12;
    ctx2.fillStyle = 'rgba(10,10,20,0.7)';
    ctx2.fillRect(0,0,lc2.width,lc2.height);
    ctx2.font = '600 '+fs2+'px Noto Sans KR, sans-serif';
    ctx2.fillStyle = '#ccddee';
    ctx2.textAlign = 'center'; ctx2.textBaseline = 'middle';
    ctx2.fillText(name, lc2.width/2, lc2.height/2);
    const tex2 = new THREE.CanvasTexture(lc2); tex2.minFilter = THREE.LinearFilter;
    const sm2 = new THREE.SpriteMaterial({ map: tex2, transparent: true, depthTest: false });
    const sp2 = new THREE.Sprite(sm2);
    sp2.scale.set(14, 14*(lc2.height/lc2.width), 1);
    sp2.position.set(x, h+8, z);
    scene.add(sp2);
  }
}

// ë¶€ì†ê±´ë¬¼ ë°°ì¹˜ (ëŒ€í˜•)
addAuxBuilding(-350, 340, 50, 38, 38, 0x889988, 'ì—ë„ˆì§€ì„¼í„°');
addAuxBuilding(-355, -110, 55, 42, 52, 0x8899aa, 'ì²­ìš´ê¸°ìˆ™ì‚¬');
addAuxBuilding(400, 360, 45, 35, 32, 0x998877, 'í•˜ë‚˜ì€í–‰');
addAuxBuilding(395, -30, 48, 40, 45, 0x887799, 'ì‚¬ì›ì•„íŒŒíŠ¸');
addAuxBuilding(-230, 465, 42, 32, 30, 0x889988, 'ì•ˆë‚´ì„¼í„°');
addAuxBuilding(290, 465, 45, 34, 35, 0x998888, 'ë³µì§€ê´€');
addAuxBuilding(-348, 170, 45, 35, 32, 0x889988, 'ë¬¼ë¥˜ì„¼í„°');
addAuxBuilding(-345, 50, 48, 38, 40, 0x99887a, 'ì—°êµ¬ë™');
addAuxBuilding(405, 155, 42, 34, 30, 0x888899, 'í’ˆì§ˆê´€ë¦¬ë™');
addAuxBuilding(398, 60, 50, 40, 42, 0x8a9988, 'í–‰ë³µ2ë§ˆì„');
addAuxBuilding(-240, -120, 45, 35, 38, 0x887788, 'ì²´ìœ¡ê´€');
addAuxBuilding(155, -120, 42, 34, 30, 0x888877, 'í™˜ê²½ì•ˆì „ë™');

// â”€â”€ ì•„íŒŒíŠ¸ ë™ (ì‚¬ì›ì•„íŒŒíŠ¸ í´ëŸ¬ìŠ¤í„°, ì˜¤ë¥¸ìª½ ì•„ë˜ ì™¸ê³½) â”€â”€
function addApartment(x, z, floors, name) {
  const w = 12, d = 28, floorH = 3.2;
  const h = floors * floorH;
  const color = 0x8899aa;
  const geo = new THREE.BoxGeometry(w, h, d);
  const mat = new THREE.MeshStandardMaterial({ color: color, roughness: 0.75, metalness: 0.05 });
  const mesh = new THREE.Mesh(geo, mat);
  mesh.position.set(x, h/2, z);
  mesh.castShadow = true; mesh.receiveShadow = true;
  scene.add(mesh);
  // ì˜¥ìƒ
  const rg = new THREE.BoxGeometry(w+0.5, 0.5, d+0.5);
  const rm = new THREE.MeshStandardMaterial({ color: 0x556070, roughness: 0.6 });
  const rf = new THREE.Mesh(rg, rm);
  rf.position.set(x, h+0.25, z);
  scene.add(rf);
  // ì°½ë¬¸ (ì–‘ë©´)
  for (let f = 0; f < floors; f++) {
    for (let c = 0; c < 5; c++) {
      const wg = new THREE.PlaneGeometry(2.2, 2);
      const wm = new THREE.MeshStandardMaterial({
        color: 0x99bbdd, emissive: 0x335566, emissiveIntensity: 0.04,
        transparent: true, opacity: 0.35, side: THREE.DoubleSide
      });
      const win = new THREE.Mesh(wg, wm);
      win.userData.isWindow = true;
      win.position.set(x - d/2 + 3 + c*5.5, 2 + f*floorH, z + w/2 + 0.1);
      scene.add(win);
      const win2 = new THREE.Mesh(wg, wm.clone());
      win2.userData.isWindow = true;
      win2.position.set(x - d/2 + 3 + c*5.5, 2 + f*floorH, z - w/2 - 0.1);
      scene.add(win2);
    }
  }
  // ë¼ë²¨
  if (name) {
    const lc3 = document.createElement('canvas');
    const cx3 = lc3.getContext('2d');
    cx3.font = '600 20px Noto Sans KR';
    const tw3 = cx3.measureText(name).width;
    lc3.width = tw3+20; lc3.height = 30;
    cx3.fillStyle = 'rgba(10,10,20,0.65)';
    cx3.fillRect(0,0,lc3.width,lc3.height);
    cx3.font = '600 20px Noto Sans KR';
    cx3.fillStyle = '#bbccdd'; cx3.textAlign = 'center'; cx3.textBaseline = 'middle';
    cx3.fillText(name, lc3.width/2, lc3.height/2);
    const t3 = new THREE.CanvasTexture(lc3); t3.minFilter = THREE.LinearFilter;
    const sm3 = new THREE.SpriteMaterial({ map: t3, transparent: true, depthTest: false });
    const sp3 = new THREE.Sprite(sm3);
    sp3.scale.set(12, 12*(lc3.height/lc3.width), 1);
    sp3.position.set(x, h+6, z);
    scene.add(sp3);
  }
}

addApartment(400, -50, 22, 'ì‚¬ì›ì•„íŒŒíŠ¸ 101ë™');
addApartment(425, -50, 25, 'ì‚¬ì›ì•„íŒŒíŠ¸ 102ë™');
addApartment(400, -100, 18, 'ì‚¬ì›ì•„íŒŒíŠ¸ 103ë™');
addApartment(425, -100, 22, 'í–‰ë³µë§ˆì„ 201ë™');
addApartment(450, -50, 20, 'í–‰ë³µë§ˆì„ 202ë™');
addApartment(450, -100, 24, 'í–‰ë³µë§ˆì„ 203ë™');

// â”€â”€ LPG/ê°€ìŠ¤ íƒ±í¬ (ìº í¼ìŠ¤ ì™¸ê³½, ì‹¤ë¦°ë”í˜•) â”€â”€
function addTank(x, z, radius, height, name) {
  const g = new THREE.Group();
  // ë³¸ì²´ (ì‹¤ë¦°ë”)
  const bodyGeo = new THREE.CylinderGeometry(radius, radius, height, 16);
  const bodyMat = new THREE.MeshStandardMaterial({ color: 0xcccccc, roughness: 0.3, metalness: 0.6 });
  const body = new THREE.Mesh(bodyGeo, bodyMat);
  body.position.y = height/2;
  body.castShadow = true;
  g.add(body);
  // ìƒë‹¨ ë°˜êµ¬
  const topGeo = new THREE.SphereGeometry(radius, 16, 8, 0, Math.PI*2, 0, Math.PI/2);
  const topMat = new THREE.MeshStandardMaterial({ color: 0xdddddd, roughness: 0.3, metalness: 0.5 });
  const top = new THREE.Mesh(topGeo, topMat);
  top.position.y = height;
  g.add(top);
  // ì§€ì§€ëŒ€ ë‹¤ë¦¬ 4ê°œ
  for (let i = 0; i < 4; i++) {
    const ang = (i/4) * Math.PI * 2;
    const legGeo = new THREE.CylinderGeometry(0.3, 0.4, height * 0.3, 4);
    const legMat = new THREE.MeshStandardMaterial({ color: 0x667777, roughness: 0.6 });
    const leg = new THREE.Mesh(legGeo, legMat);
    leg.position.set(Math.cos(ang)*radius*0.7, height*0.15, Math.sin(ang)*radius*0.7);
    g.add(leg);
  }
  // ë°°ê´€
  const pipeGeo = new THREE.CylinderGeometry(0.25, 0.25, radius*3, 6);
  const pipeMat = new THREE.MeshStandardMaterial({ color: 0x999999, roughness: 0.4, metalness: 0.4 });
  const pipe = new THREE.Mesh(pipeGeo, pipeMat);
  pipe.rotation.z = Math.PI / 2;
  pipe.position.set(radius + 2, height * 0.7, 0);
  g.add(pipe);
  g.position.set(x, 0, z);
  scene.add(g);
  // ë¼ë²¨
  if (name) {
    const lc4 = document.createElement('canvas');
    const cx4 = lc4.getContext('2d');
    cx4.font = '600 18px Noto Sans KR';
    const tw4 = cx4.measureText(name).width;
    lc4.width = tw4+18; lc4.height = 26;
    cx4.fillStyle = 'rgba(10,10,20,0.6)';
    cx4.fillRect(0,0,lc4.width,lc4.height);
    cx4.font = '600 18px Noto Sans KR';
    cx4.fillStyle = '#bbccdd'; cx4.textAlign = 'center'; cx4.textBaseline = 'middle';
    cx4.fillText(name, lc4.width/2, lc4.height/2);
    const t4 = new THREE.CanvasTexture(lc4); t4.minFilter = THREE.LinearFilter;
    const sm4 = new THREE.SpriteMaterial({ map: t4, transparent: true, depthTest: false });
    const sp4 = new THREE.Sprite(sm4);
    sp4.scale.set(10, 10*(lc4.height/lc4.width), 1);
    sp4.position.set(x, height+radius+5, z);
    scene.add(sp4);
  }
}

// LPG/ê°€ìŠ¤ íƒ±í¬ ë°°ì¹˜ (ìº í¼ìŠ¤ íšŒì‚¬ ê·¼ì²˜, ìƒì‚°ë™ ì˜†)
addTank(-330, 250, 10, 22, 'LPG íƒ±í¬ 1');
addTank(-330, 200, 8, 18, 'LPG íƒ±í¬ 2');
addTank(-330, 110, 12, 26, 'ì§ˆì†Œ íƒ±í¬');
addTank(-330, 40, 10, 22, 'ê°€ìŠ¤ íƒ±í¬');
addTank(-295, -20, 8, 18, 'ì•½í’ˆ íƒ±í¬');
addTank(-295, 40, 9, 20, 'ì‚°ì†Œ íƒ±í¬');

// â”€â”€ ì •ë¬¸ ê²Œì´íŠ¸ â”€â”€
(function() {
  const gateX = 20, gateZ = 375;
  const gateW = 30, gateH = 14, pillarW = 3, pillarD = 3;

  // ì™¼ìª½ ê¸°ë‘¥
  const pGeo = new THREE.BoxGeometry(pillarW, gateH, pillarD);
  const pMat = new THREE.MeshStandardMaterial({ color: 0x556677, roughness: 0.4, metalness: 0.4 });
  const pL = new THREE.Mesh(pGeo, pMat);
  pL.position.set(gateX - gateW/2, gateH/2, gateZ);
  pL.castShadow = true;
  scene.add(pL);
  // ì˜¤ë¥¸ìª½ ê¸°ë‘¥
  const pR = new THREE.Mesh(pGeo, pMat);
  pR.position.set(gateX + gateW/2, gateH/2, gateZ);
  pR.castShadow = true;
  scene.add(pR);

  // ìƒë‹¨ ë°” (ê°€ë¡œ ë¹”)
  const barGeo = new THREE.BoxGeometry(gateW + pillarW, 2.5, pillarD + 1);
  const barMat = new THREE.MeshStandardMaterial({ color: 0x667788, roughness: 0.35, metalness: 0.5 });
  const bar = new THREE.Mesh(barGeo, barMat);
  bar.position.set(gateX, gateH + 1.2, gateZ);
  bar.castShadow = true;
  scene.add(bar);

  // SK hynix ë¡œê³  íŒ¨ë„ (ìƒë‹¨ ë°” ì •ë©´)
  const logoCanvas = document.createElement('canvas');
  const lctx = logoCanvas.getContext('2d');
  logoCanvas.width = 512; logoCanvas.height = 96;
  lctx.fillStyle = 'rgba(40,50,65,0.9)';
  lctx.fillRect(0,0,512,96);
  // SK hynix ê¸€ì”¨
  lctx.font = 'bold 48px Noto Sans KR, sans-serif';
  lctx.fillStyle = '#ee3333';
  lctx.textAlign = 'center'; lctx.textBaseline = 'middle';
  lctx.fillText('SK hynix', 256, 40);
  // ì´ì²œìº í¼ìŠ¤
  lctx.font = '24px Noto Sans KR, sans-serif';
  lctx.fillStyle = '#ccddee';
  lctx.fillText('ì´ì²œìº í¼ìŠ¤', 256, 76);

  const logoTex = new THREE.CanvasTexture(logoCanvas);
  logoTex.minFilter = THREE.LinearFilter;
  const logoGeo = new THREE.PlaneGeometry(gateW * 0.8, 5);
  const logoMat = new THREE.MeshStandardMaterial({
    map: logoTex, transparent: true, emissive: 0xffffff, emissiveIntensity: 0.15
  });
  const logoMesh = new THREE.Mesh(logoGeo, logoMat);
  logoMesh.position.set(gateX, gateH + 1.2, gateZ + pillarD/2 + 0.6);
  scene.add(logoMesh);

  // ì •ë¬¸ ì°¨ë‹¨ê¸° ë°” (ê°€ëŠ” ë´‰)
  const boomGeo = new THREE.CylinderGeometry(0.15, 0.15, gateW * 0.85, 6);
  const boomMat = new THREE.MeshStandardMaterial({ color: 0xee4444, emissive: 0xcc2222, emissiveIntensity: 0.3, roughness: 0.4 });
  const boom = new THREE.Mesh(boomGeo, boomMat);
  boom.rotation.z = Math.PI / 2;
  boom.position.set(gateX, 4, gateZ + pillarD/2 + 2);
  scene.add(boom);

  // ì •ë¬¸ ì§„ì…ë¡œ (ê²Œì´íŠ¸ ì• ë„ë¡œ)
  const entryGeo = new THREE.PlaneGeometry(20, 30);
  const entryMat = new THREE.MeshStandardMaterial({ color: 0x2a2e38, roughness: 0.75 });
  const entry = new THREE.Mesh(entryGeo, entryMat);
  entry.rotation.x = -Math.PI / 2;
  entry.position.set(gateX, 0.3, gateZ + 18);
  entry.receiveShadow = true;
  scene.add(entry);

  // ì •ë¬¸ ì•ˆë‚´ì†Œ (ì‘ì€ ë°•ìŠ¤)
  const guardGeo = new THREE.BoxGeometry(5, 4, 4);
  const guardMat = new THREE.MeshStandardMaterial({ color: 0x556677, roughness: 0.5, metalness: 0.3 });
  const guard = new THREE.Mesh(guardGeo, guardMat);
  guard.position.set(gateX + gateW/2 + 5, 2, gateZ);
  guard.castShadow = true;
  scene.add(guard);
})();

// â”€â”€ ì‚¬ëŒë“¤ (~300ëª…, ìº í¼ìŠ¤ ê³³ê³³ì— ëœë¤ ë°°ì¹˜) â”€â”€
(function() {
  const bodyColors = [
    0x2244aa, 0x3366cc, 0x225588, 0x1155aa, // íŒŒë€ ì‘ì—…ë³µ
    0x224488, 0x335599, 0x1a3d7a, 0x2a5090,
    0xeeeeee, 0xdddddd, 0xcccccc,           // í° ê°€ìš´(ì—°êµ¬ì›)
    0x333333, 0x444444, 0x555555,           // ê²€ì •/íšŒìƒ‰ (ì‚¬ë¬´ì§)
    0xcc4444, 0xdd6633, 0x44aa44,           // ì•ˆì „ì¡°ë¼ ëŠë‚Œ
  ];
  const skinColors = [0xffccaa, 0xf5c09a, 0xeebb88, 0xdda878, 0xf0c8a0];
  const hairColors = [0x222222, 0x333333, 0x1a1a1a, 0x443322, 0x2a2a2a];

  // ê³µìœ  ì§€ì˜¤ë©”íŠ¸ë¦¬ (ì„±ëŠ¥)
  const headGeo = new THREE.SphereGeometry(1, 5, 4);
  const bodyGeo = new THREE.BoxGeometry(1, 1, 1);
  const legGeo = new THREE.BoxGeometry(1, 1, 1);
  const hairGeo = new THREE.SphereGeometry(1, 4, 3);

  // ë°°ì¹˜ ì˜ì—­ (ìº í¼ìŠ¤ ë‚´ë¶€ ë„ë¡œ/ê±´ë¬¼ ì‚¬ì´ + ì™¸ê³½)
  const zones = [
    // ìº í¼ìŠ¤ ë‚´ë¶€ (ë©”ì¸ ì˜ì—­) - ë§ì´
    { xMin: -190, xMax: 240, zMin: -30, zMax: 350, count: 180 },
    // ì •ë¬¸ ê·¼ì²˜
    { xMin: -30, xMax: 60, zMin: 350, zMax: 400, count: 25 },
    // ì™¸ê³½ ì™¼ìª½
    { xMin: -300, xMax: -220, zMin: -60, zMax: 330, count: 25 },
    // ì™¸ê³½ ì˜¤ë¥¸ìª½
    { xMin: 280, xMax: 380, zMin: -60, zMax: 330, count: 25 },
    // ì™¸ê³½ ì•„ë˜
    { xMin: -180, xMax: 220, zMin: -120, zMax: -40, count: 20 },
    // ê³ ì†ë„ë¡œ ì£¼ë³€ ì¸ë„
    { xMin: 460, xMax: 490, zMin: -100, zMax: 400, count: 15 },
    // ì•„íŒŒíŠ¸ ë™ ê·¼ì²˜
    { xMin: 380, xMax: 460, zMin: -120, zMax: -20, count: 15 },
  ];

  zones.forEach(zone => {
    for (let i = 0; i < zone.count; i++) {
      const px = zone.xMin + Math.random() * (zone.xMax - zone.xMin);
      const pz = zone.zMin + Math.random() * (zone.zMax - zone.zMin);
      const scale = 0.7 + Math.random() * 0.3; // í‚¤ ë³€í™” (í¬ê²Œ)
      const g = new THREE.Group();

      const skinC = skinColors[Math.floor(Math.random() * skinColors.length)];
      const bodyC = bodyColors[Math.floor(Math.random() * bodyColors.length)];
      const hairC = hairColors[Math.floor(Math.random() * hairColors.length)];

      // ë¨¸ë¦¬
      const skinMat = new THREE.MeshStandardMaterial({ color: skinC, roughness: 0.8 });
      const head = new THREE.Mesh(headGeo, skinMat);
      head.scale.set(scale*0.8, scale*0.9, scale*0.8);
      head.position.y = scale * 5.2;
      g.add(head);

      // ë¨¸ë¦¬ì¹´ë½
      const hMat = new THREE.MeshStandardMaterial({ color: hairC, roughness: 0.9 });
      const hair = new THREE.Mesh(hairGeo, hMat);
      hair.scale.set(scale*0.85, scale*0.5, scale*0.85);
      hair.position.y = scale * 5.6;
      g.add(hair);

      // ëª¸í†µ
      const bMat = new THREE.MeshStandardMaterial({ color: bodyC, roughness: 0.75 });
      const body = new THREE.Mesh(bodyGeo, bMat);
      body.scale.set(scale*1.6, scale*2.8, scale*1.0);
      body.position.y = scale * 3.2;
      g.add(body);

      // ë‹¤ë¦¬ 2ê°œ
      const legMat = new THREE.MeshStandardMaterial({ color: 0x333344, roughness: 0.8 });
      const legL = new THREE.Mesh(legGeo, legMat);
      legL.scale.set(scale*0.55, scale*2.2, scale*0.55);
      legL.position.set(-scale*0.35, scale*0.9, 0);
      g.add(legL);
      const legR = new THREE.Mesh(legGeo, legMat.clone());
      legR.scale.set(scale*0.55, scale*2.2, scale*0.55);
      legR.position.set(scale*0.35, scale*0.9, 0);
      g.add(legR);

      // ëœë¤ íšŒì „ (ê±·ëŠ” ë°©í–¥)
      g.rotation.y = Math.random() * Math.PI * 2;
      g.position.set(px, 0, pz);
      scene.add(g);

      // ê±·ëŠ” ì• ë‹ˆë©”ì´ì…˜ìš© ë°ì´í„°
      g.userData.isPerson = true;
      g.userData.walkSpeed = 0.02 + Math.random() * 0.04;
      g.userData.walkDir = Math.random() * Math.PI * 2;
      g.userData.walkTimer = Math.random() * 100;
      g.userData.zone = zone;
    }
  });
})();

// â”€â”€ ì•ˆë‚´ì„¼í„° ì• ì¤„ ì„œìˆëŠ” ì‚¬ëŒ 20ëª… â”€â”€
(function() {
  const queueX = -230, queueZ = 483; // ì•ˆë‚´ì„¼í„° ì•
  const skinColors = [0xffccaa, 0xf5c09a, 0xeebb88, 0xdda878, 0xf0c8a0];
  const hairColors = [0x222222, 0x333333, 0x1a1a1a, 0x443322];
  const bodyColors = [0x2244aa, 0x3366cc, 0xeeeeee, 0x333333, 0xcc4444, 0x225588];
  const headGeo = new THREE.SphereGeometry(1, 5, 4);
  const bodyGeo = new THREE.BoxGeometry(1, 1, 1);
  const legGeo = new THREE.BoxGeometry(1, 1, 1);
  const hairGeo = new THREE.SphereGeometry(1, 4, 3);

  for (let i = 0; i < 20; i++) {
    const scale = 0.7 + Math.random() * 0.3;
    const g = new THREE.Group();
    const skinC = skinColors[Math.floor(Math.random() * skinColors.length)];
    const bodyC = bodyColors[Math.floor(Math.random() * bodyColors.length)];
    const hairC = hairColors[Math.floor(Math.random() * hairColors.length)];

    const skinMat = new THREE.MeshStandardMaterial({ color: skinC, roughness: 0.8 });
    const head = new THREE.Mesh(headGeo, skinMat);
    head.scale.set(scale*0.8, scale*0.9, scale*0.8);
    head.position.y = scale * 5.2;
    g.add(head);
    const hMat = new THREE.MeshStandardMaterial({ color: hairC, roughness: 0.9 });
    const hair = new THREE.Mesh(hairGeo, hMat);
    hair.scale.set(scale*0.85, scale*0.5, scale*0.85);
    hair.position.y = scale * 5.6;
    g.add(hair);
    const bMat = new THREE.MeshStandardMaterial({ color: bodyC, roughness: 0.75 });
    const body = new THREE.Mesh(bodyGeo, bMat);
    body.scale.set(scale*1.6, scale*2.8, scale*1.0);
    body.position.y = scale * 3.2;
    g.add(body);
    const legMat = new THREE.MeshStandardMaterial({ color: 0x333344, roughness: 0.8 });
    const legL = new THREE.Mesh(legGeo, legMat);
    legL.scale.set(scale*0.55, scale*2.2, scale*0.55);
    legL.position.set(-scale*0.35, scale*0.9, 0);
    g.add(legL);
    const legR = new THREE.Mesh(legGeo, legMat.clone());
    legR.scale.set(scale*0.55, scale*2.2, scale*0.55);
    legR.position.set(scale*0.35, scale*0.9, 0);
    g.add(legR);

    // ì¤„ ë°°ì¹˜: í•œ ì¤„ë¡œ zë°©í–¥ ê°„ê²© 2.5ì”©
    const row = Math.floor(i / 10);
    const col = i % 10;
    g.position.set(queueX - 4 + row * 3, 0, queueZ + col * 2.5);
    g.rotation.y = Math.PI; // ì•ˆë‚´ì„¼í„° ìª½ ë°”ë¼ë³´ê¸°
    scene.add(g);
  }
})();

// â”€â”€ ì…”í‹€ë²„ìŠ¤ 2ëŒ€ (ìº í¼ìŠ¤ ë„ë¡œ ìœ„ ì£¼í–‰) â”€â”€
const busGroup = [];
(function() {
  function createBus(color, labelText) {
    const g = new THREE.Group();
    // ì°¨ì²´
    const bodyGeo = new THREE.BoxGeometry(5, 4.5, 14);
    const bodyMat = new THREE.MeshStandardMaterial({ color: color, roughness: 0.4, metalness: 0.2 });
    const body = new THREE.Mesh(bodyGeo, bodyMat);
    body.position.y = 3.5;
    body.castShadow = true;
    g.add(body);
    // ì§€ë¶•
    const roofGeo = new THREE.BoxGeometry(5.2, 0.5, 14.2);
    const roofMat = new THREE.MeshStandardMaterial({ color: 0xeeeeee, roughness: 0.5 });
    const roof = new THREE.Mesh(roofGeo, roofMat);
    roof.position.y = 5.8;
    g.add(roof);
    // ìœ ë¦¬ì°½ (ì–‘ìª½)
    for (let side = -1; side <= 1; side += 2) {
      for (let i = 0; i < 5; i++) {
        const winGeo = new THREE.PlaneGeometry(1.8, 2.2);
        const winMat = new THREE.MeshStandardMaterial({
          color: 0x88ccee, emissive: 0x224466, emissiveIntensity: 0.1,
          transparent: true, opacity: 0.5, side: THREE.DoubleSide
        });
        const win = new THREE.Mesh(winGeo, winMat);
        win.position.set(side * 2.55, 4.2, -5 + i * 2.5);
        win.rotation.y = Math.PI / 2;
        g.add(win);
      }
    }
    // ì•ìœ ë¦¬
    const frontGeo = new THREE.PlaneGeometry(4.2, 2.8);
    const frontMat = new THREE.MeshStandardMaterial({
      color: 0x99ddff, emissive: 0x336688, emissiveIntensity: 0.1,
      transparent: true, opacity: 0.45, side: THREE.DoubleSide
    });
    const front = new THREE.Mesh(frontGeo, frontMat);
    front.position.set(0, 4.2, 7.05);
    g.add(front);
    // ë°”í€´ 4ê°œ
    const wheelGeo = new THREE.CylinderGeometry(1, 1, 0.8, 8);
    const wheelMat = new THREE.MeshStandardMaterial({ color: 0x222222, roughness: 0.9 });
    const positions = [[-2, 1, 4.5], [2, 1, 4.5], [-2, 1, -4.5], [2, 1, -4.5]];
    positions.forEach(([wx, wy, wz]) => {
      const wheel = new THREE.Mesh(wheelGeo, wheelMat);
      wheel.rotation.z = Math.PI / 2;
      wheel.position.set(wx, wy, wz);
      g.add(wheel);
    });
    // ë¼ë²¨ (ì¸¡ë©´)
    if (labelText) {
      const lc = document.createElement('canvas');
      const cx = lc.getContext('2d');
      cx.font = 'bold 24px Noto Sans KR';
      const tw = cx.measureText(labelText).width;
      lc.width = tw + 20; lc.height = 34;
      cx.fillStyle = 'rgba(255,255,255,0.85)';
      cx.fillRect(0, 0, lc.width, lc.height);
      cx.font = 'bold 24px Noto Sans KR';
      cx.fillStyle = '#cc0000';
      cx.textAlign = 'center'; cx.textBaseline = 'middle';
      cx.fillText(labelText, lc.width / 2, lc.height / 2);
      const tex = new THREE.CanvasTexture(lc); tex.minFilter = THREE.LinearFilter;
      const spMat = new THREE.SpriteMaterial({ map: tex, transparent: true, depthTest: false });
      const sp = new THREE.Sprite(spMat);
      sp.scale.set(8, 8 * (lc.height / lc.width), 1);
      sp.position.set(0, 7.5, 0);
      g.add(sp);
    }
    scene.add(g);
    return g;
  }

  // ë²„ìŠ¤ 1: ìº í¼ìŠ¤ ë‚´ë¶€ ê°€ë¡œë„ë¡œ (ë™ì„œ ë°©í–¥)
  const bus1 = createBus(0x2266aa, 'SK hynix ì…”í‹€');
  bus1.userData.isBus = true;
  bus1.userData.route = [
    { x: -190, z: RZ(470) }, // ì™¼ìª½ ì¶œë°œ
    { x: 240, z: RZ(470) },  // ì˜¤ë¥¸ìª½ ë
  ];
  bus1.userData.routeIdx = 0;
  bus1.userData.progress = 0;
  bus1.userData.speed = 0.4;
  bus1.userData.forward = 1;
  bus1.position.set(-190, 0, RZ(470));
  bus1.rotation.y = -Math.PI / 2;
  busGroup.push(bus1);

  // ë²„ìŠ¤ 2: ìº í¼ìŠ¤ ì„¸ë¡œë„ë¡œ (ë‚¨ë¶ ë°©í–¥)
  const bus2 = createBus(0x44aa44, 'SK hynix í†µê·¼ë²„ìŠ¤');
  bus2.userData.isBus = true;
  bus2.userData.route = [
    { x: R(400), z: 340 }, // ìœ„ìª½
    { x: R(400), z: -30 }, // ì•„ë˜ìª½
  ];
  bus2.userData.routeIdx = 0;
  bus2.userData.progress = Math.random();
  bus2.userData.speed = 0.35;
  bus2.userData.forward = 1;
  bus2.position.set(R(400), 0, 200);
  bus2.rotation.y = 0;
  busGroup.push(bus2);
})();

// â”€â”€ ì™¸ê³½ ë„ë¡œ (ìº í¼ìŠ¤ ë°”ê¹¥ ì¼ë°˜ë„ë¡œ, ë„“ê²Œ) â”€â”€
// ìœ„ìª½ ì™¸ê³½ë„ë¡œ
addRoad(-380, 480, 470, 480, 14);
// ì™¼ìª½ ì™¸ê³½ë„ë¡œ
addRoad(-380, 480, -380, -150, 12);
// ì˜¤ë¥¸ìª½ ì™¸ê³½ë„ë¡œ
addRoad(470, 480, 470, -150, 12);
// ì•„ë˜ìª½ ì™¸ê³½ë„ë¡œ
addRoad(-380, -150, 470, -150, 14);

// â”€â”€ ê³ ì†ë„ë¡œ (ì˜¤ë¥¸ìª½ ë¼ì¸ ë, ë‚¨ë¶ ë°©í–¥) â”€â”€
(function() {
  const hwX = 520; // ê³ ì†ë„ë¡œ ì¤‘ì‹¬ x
  const hwZ1 = 520, hwZ2 = -180; // ìœ„~ì•„ë˜
  const hwLen = hwZ1 - hwZ2;
  const laneW = 9; // í¸ë„ í­
  const medianW = 2.5; // ì¤‘ì•™ë¶„ë¦¬ëŒ€

  // ìƒí–‰ ë„ë¡œ (ì™¼ìª½ ì°¨ì„ )
  const roadGeo1 = new THREE.PlaneGeometry(laneW, hwLen);
  const roadMat1 = new THREE.MeshStandardMaterial({ color: 0x2c3040, roughness: 0.7 });
  const road1 = new THREE.Mesh(roadGeo1, roadMat1);
  road1.rotation.x = -Math.PI / 2;
  road1.position.set(hwX - laneW/2 - medianW/2, 0.4, (hwZ1+hwZ2)/2);
  road1.receiveShadow = true;
  scene.add(road1);

  // í•˜í–‰ ë„ë¡œ (ì˜¤ë¥¸ìª½ ì°¨ì„ )
  const road2 = new THREE.Mesh(roadGeo1.clone(), roadMat1.clone());
  road2.rotation.x = -Math.PI / 2;
  road2.position.set(hwX + laneW/2 + medianW/2, 0.4, (hwZ1+hwZ2)/2);
  road2.receiveShadow = true;
  scene.add(road2);

  // ì¤‘ì•™ë¶„ë¦¬ëŒ€ (ì½˜í¬ë¦¬íŠ¸)
  const medGeo = new THREE.BoxGeometry(medianW, 1.8, hwLen);
  const medMat = new THREE.MeshStandardMaterial({ color: 0x555d68, roughness: 0.8 });
  const median = new THREE.Mesh(medGeo, medMat);
  median.position.set(hwX, 0.9, (hwZ1+hwZ2)/2);
  median.castShadow = true;
  scene.add(median);

  // ì°¨ì„  (í°ìƒ‰ ì ì„  - ê° ë°©í–¥ 2ì°¨ì„ )
  for (let side = -1; side <= 1; side += 2) {
    const cx = hwX + side * (laneW/2 + medianW/2);
    // ì¤‘ì•™ ì°¨ì„ 
    for (let i = 0; i < Math.floor(hwLen / 10); i++) {
      const dashGeo = new THREE.PlaneGeometry(0.3, 4);
      const dashMat = new THREE.MeshStandardMaterial({ color: 0xcccccc, emissive: 0x888888, emissiveIntensity: 0.15 });
      const dash = new THREE.Mesh(dashGeo, dashMat);
      dash.rotation.x = -Math.PI / 2;
      dash.position.set(cx, 0.42, hwZ1 - 5 - i*10);
      scene.add(dash);
    }
  }

  // ê°“ê¸¸ (ì–‘ìª½ ë°”ê¹¥)
  const shoulderW = 3;
  for (let side = -1; side <= 1; side += 2) {
    const sx = hwX + side * (laneW + medianW/2 + shoulderW/2);
    const sGeo = new THREE.PlaneGeometry(shoulderW, hwLen);
    const sMat = new THREE.MeshStandardMaterial({ color: 0x3a3f4a, roughness: 0.75 });
    const shoulder = new THREE.Mesh(sGeo, sMat);
    shoulder.rotation.x = -Math.PI / 2;
    shoulder.position.set(sx, 0.38, (hwZ1+hwZ2)/2);
    scene.add(shoulder);
  }

  // ê°€ë“œë ˆì¼ (ì–‘ìª½)
  const railColor = 0x999999;
  for (let side = -1; side <= 1; side += 2) {
    const rx = hwX + side * (laneW + medianW/2 + shoulderW + 0.5);
    for (let i = 0; i < Math.floor(hwLen / 8); i++) {
      // ê¸°ë‘¥
      const postGeo = new THREE.BoxGeometry(0.2, 1.5, 0.2);
      const postMat = new THREE.MeshStandardMaterial({ color: railColor, roughness: 0.4, metalness: 0.5 });
      const post = new THREE.Mesh(postGeo, postMat);
      post.position.set(rx, 0.75, hwZ1 - 4 - i*8);
      scene.add(post);
    }
    // ê°€ë“œë ˆì¼ ë°” (ì—°ì†)
    const barGeo = new THREE.BoxGeometry(0.15, 0.4, hwLen - 4);
    const barMat = new THREE.MeshStandardMaterial({ color: railColor, roughness: 0.35, metalness: 0.6 });
    const bar = new THREE.Mesh(barGeo, barMat);
    bar.position.set(rx, 1.0, (hwZ1+hwZ2)/2);
    scene.add(bar);
  }

  // ë°©ìŒë²½ (ìº í¼ìŠ¤ìª½, ì™¼ìª½ì—ë§Œ)
  const wallX = hwX - laneW - medianW/2 - shoulderW - 2;
  const wallGeo = new THREE.BoxGeometry(1.2, 8, hwLen);
  const wallMat = new THREE.MeshStandardMaterial({ color: 0x667766, roughness: 0.7, metalness: 0.1 });
  const wall = new THREE.Mesh(wallGeo, wallMat);
  wall.position.set(wallX, 4, (hwZ1+hwZ2)/2);
  wall.castShadow = true;
  scene.add(wall);
  // ë°©ìŒë²½ ìƒë‹¨ ì¥ì‹
  const wallTopGeo = new THREE.BoxGeometry(1.8, 0.5, hwLen);
  const wallTopMat = new THREE.MeshStandardMaterial({ color: 0x778877, roughness: 0.5 });
  const wallTop = new THREE.Mesh(wallTopGeo, wallTopMat);
  wallTop.position.set(wallX, 8.2, (hwZ1+hwZ2)/2);
  scene.add(wallTop);

  // ê³ ì†ë„ë¡œ ë¼ë²¨
  const hwLabel = document.createElement('canvas');
  const hwCtx = hwLabel.getContext('2d');
  hwCtx.font = 'bold 28px Noto Sans KR';
  const hwTw = hwCtx.measureText('ì¤‘ë¶€ê³ ì†ë„ë¡œ').width;
  hwLabel.width = hwTw + 30; hwLabel.height = 42;
  hwCtx.fillStyle = 'rgba(0,60,20,0.8)';
  hwCtx.fillRect(0,0,hwLabel.width,hwLabel.height);
  hwCtx.font = 'bold 28px Noto Sans KR';
  hwCtx.fillStyle = '#ffffff';
  hwCtx.textAlign = 'center'; hwCtx.textBaseline = 'middle';
  hwCtx.fillText('ì¤‘ë¶€ê³ ì†ë„ë¡œ', hwLabel.width/2, hwLabel.height/2);
  const hwTex = new THREE.CanvasTexture(hwLabel); hwTex.minFilter = THREE.LinearFilter;
  const hwSpMat = new THREE.SpriteMaterial({ map: hwTex, transparent: true, depthTest: false });
  const hwSp = new THREE.Sprite(hwSpMat);
  hwSp.scale.set(22, 22*(hwLabel.height/hwLabel.width), 1);
  hwSp.position.set(hwX, 18, 170);
  scene.add(hwSp);

  // ê³ ì†ë„ë¡œ í‘œì§€íŒ (ë…¹ìƒ‰ ì‚¬ê° ì•ˆë‚´íŒ)
  const signGeo = new THREE.BoxGeometry(16, 8, 0.5);
  const signMat = new THREE.MeshStandardMaterial({ color: 0x006633, emissive: 0x003311, emissiveIntensity: 0.2, roughness: 0.5 });
  const sign = new THREE.Mesh(signGeo, signMat);
  sign.position.set(hwX, 14, 250);
  scene.add(sign);
  // í‘œì§€íŒ ê¸°ë‘¥
  const sPoleGeo = new THREE.CylinderGeometry(0.4, 0.4, 14, 6);
  const sPoleMat = new THREE.MeshStandardMaterial({ color: 0x888888, roughness: 0.4, metalness: 0.5 });
  const sPole = new THREE.Mesh(sPoleGeo, sPoleMat);
  sPole.position.set(hwX, 7, 250);
  scene.add(sPole);

  // í‘œì§€íŒ í…ìŠ¤íŠ¸
  const signCanvas = document.createElement('canvas');
  const sCtx = signCanvas.getContext('2d');
  signCanvas.width = 256; signCanvas.height = 128;
  sCtx.fillStyle = '#006633';
  sCtx.fillRect(0,0,256,128);
  sCtx.strokeStyle = '#ffffff'; sCtx.lineWidth = 3;
  sCtx.strokeRect(8,8,240,112);
  sCtx.font = 'bold 32px Noto Sans KR';
  sCtx.fillStyle = '#ffffff';
  sCtx.textAlign = 'center'; sCtx.textBaseline = 'middle';
  sCtx.fillText('ì´ì²œ IC 2km', 128, 45);
  sCtx.font = '24px Noto Sans KR';
  sCtx.fillText('ì—¬ì£¼ â†‘  ê´‘ì£¼ â†“', 128, 90);
  const signTex = new THREE.CanvasTexture(signCanvas); signTex.minFilter = THREE.LinearFilter;
  const signPanelGeo = new THREE.PlaneGeometry(15.5, 7.5);
  const signPanelMat = new THREE.MeshStandardMaterial({ map: signTex, emissive: 0xffffff, emissiveIntensity: 0.08 });
  const signPanel = new THREE.Mesh(signPanelGeo, signPanelMat);
  signPanel.position.set(hwX, 14, 250.3);
  scene.add(signPanel);
})();

// â”€â”€ ê³ ì†ë„ë¡œ ì°¨ëŸ‰ 10ëŒ€ (ë‚¨ë¶ ì£¼í–‰) â”€â”€
const hwCars = [];
(function() {
  const hwX = 520;
  const laneW = 9, medianW = 2.5;
  const carColors = [0xcc2222, 0x2244cc, 0xeeeeee, 0x333333, 0x44aa44,
                     0xddaa22, 0x8844aa, 0x22aacc, 0xaa4422, 0x666666];

  for (let i = 0; i < 10; i++) {
    const g = new THREE.Group();
    const isUp = i < 5; // ìƒí–‰ 5ëŒ€, í•˜í–‰ 5ëŒ€
    const laneOffset = isUp ? -(laneW/2 + medianW/2) : (laneW/2 + medianW/2);
    const laneShift = (Math.random() - 0.5) * 3; // ì°¨ì„  ë‚´ ì•½ê°„ ëœë¤

    const cc = carColors[i];
    // ì°¨ì²´
    const bGeo = new THREE.BoxGeometry(3, 2.2, 6);
    const bMat = new THREE.MeshStandardMaterial({ color: cc, roughness: 0.35, metalness: 0.3 });
    const bdy = new THREE.Mesh(bGeo, bMat);
    bdy.position.y = 1.8;
    bdy.castShadow = true;
    g.add(bdy);
    // ìƒë‹¨ (ìºë¹ˆ)
    const tGeo = new THREE.BoxGeometry(2.6, 1.5, 3.2);
    const tMat = new THREE.MeshStandardMaterial({ color: cc, roughness: 0.4, metalness: 0.2 });
    const top = new THREE.Mesh(tGeo, tMat);
    top.position.y = 3.5;
    top.position.z = -0.3;
    g.add(top);
    // ìœ ë¦¬
    const fGeo = new THREE.PlaneGeometry(2.2, 1.3);
    const fMat = new THREE.MeshStandardMaterial({
      color: 0x88ccee, transparent: true, opacity: 0.5, side: THREE.DoubleSide
    });
    const fw = new THREE.Mesh(fGeo, fMat);
    fw.position.set(0, 3.5, 1.35);
    g.add(fw);
    const bw = new THREE.Mesh(fGeo, fMat.clone());
    bw.position.set(0, 3.5, -1.95);
    g.add(bw);
    // ë°”í€´
    const wGeo = new THREE.CylinderGeometry(0.55, 0.55, 0.5, 6);
    const wMat = new THREE.MeshStandardMaterial({ color: 0x111111, roughness: 0.9 });
    [[-1.3, 0.55, 2], [1.3, 0.55, 2], [-1.3, 0.55, -2], [1.3, 0.55, -2]].forEach(([wx,wy,wz]) => {
      const wh = new THREE.Mesh(wGeo, wMat);
      wh.rotation.z = Math.PI/2;
      wh.position.set(wx, wy, wz);
      g.add(wh);
    });
    // í—¤ë“œë¼ì´íŠ¸ (ì•)
    const hlGeo = new THREE.SphereGeometry(0.25, 4, 4);
    const hlMat = new THREE.MeshStandardMaterial({ color: 0xffffcc, emissive: 0xffff88, emissiveIntensity: 0.5 });
    const hlL = new THREE.Mesh(hlGeo, hlMat);
    hlL.position.set(-1, 1.5, 3.05);
    g.add(hlL);
    const hlR = new THREE.Mesh(hlGeo, hlMat);
    hlR.position.set(1, 1.5, 3.05);
    g.add(hlR);

    const startZ = -180 + Math.random() * 700;
    g.position.set(hwX + laneOffset + laneShift, 0, startZ);
    g.rotation.y = isUp ? 0 : Math.PI;
    g.userData.speed = 0.6 + Math.random() * 0.5;
    g.userData.dir = isUp ? 1 : -1;
    scene.add(g);
    hwCars.push(g);
  }
})();

// ============================================================
// Campus Boundary
// ============================================================
const boundaryPts2D = [
  [80, 140], [80, 450], [90, 500], [90, 620], [100, 660],
  [90, 720], [80, 800], [140, 840], [280, 850], [450, 840],
  [600, 830], [700, 840], [800, 830], [900, 820],
  [950, 800], [960, 720], [960, 500], [960, 350],
  [950, 180], [920, 140], [780, 130], [600, 140],
  [400, 140], [250, 140], [150, 140], [80, 140]
];
const boundaryPoints = boundaryPts2D.map(p => new THREE.Vector3(
  (p[0] - 480) * SCALE, 0.5, (820 - p[1]) * SCALE
));
const boundaryGeo = new THREE.BufferGeometry().setFromPoints(boundaryPoints);
const boundaryMat = new THREE.LineBasicMaterial({ color: 0x2a3040, linewidth: 2 });
const boundaryLine = new THREE.Line(boundaryGeo, boundaryMat);
scene.add(boundaryLine);

// ìº í¼ìŠ¤ ë°”ë‹¥ ì œê±° (ê²½ê³„ì„ ë§Œ ìœ ì§€)

// ============================================================
// Roads (ê±´ë¬¼ ì‚¬ì´ ë„ë¡œë§)
// ============================================================
function addRoad(x1, z1, x2, z2, width) {
  const dx = x2 - x1, dz = z2 - z1;
  const len = Math.sqrt(dx*dx + dz*dz);
  const geo = new THREE.PlaneGeometry(len, width);
  const mat = new THREE.MeshStandardMaterial({ color: 0x252a35, roughness: 0.75 });
  const mesh = new THREE.Mesh(geo, mat);
  mesh.rotation.x = -Math.PI / 2;
  mesh.position.set((x1+x2)/2, 0.35, (z1+z2)/2);
  mesh.rotation.z = -Math.atan2(dz, dx);
  mesh.receiveShadow = true;
  scene.add(mesh);

  // ë„ë¡œ ì¤‘ì•™ì„  (ì ì„  ëŠë‚Œ)
  const cGeo = new THREE.PlaneGeometry(len, 0.3);
  const cMat = new THREE.MeshStandardMaterial({
    color: 0x556677, emissive: 0x334455, emissiveIntensity: 0.2,
    roughness: 0.5
  });
  const cLine = new THREE.Mesh(cGeo, cMat);
  cLine.rotation.x = -Math.PI / 2;
  cLine.position.set((x1+x2)/2, 0.38, (z1+z2)/2);
  cLine.rotation.z = -Math.atan2(dz, dx);
  scene.add(cLine);
}

// ë°ì´í„° ì¢Œí‘œ â†’ ì›”ë“œ ì¢Œí‘œ ë³€í™˜ í—¬í¼
function R(dataX) { return (dataX - 480) * SCALE; }
function RZ(dataZ) { return (820 - dataZ) * SCALE; }

// â”€â”€ ë©”ì¸ ë™ì„œ ë„ë¡œ (ê°€ë¡œ) â”€â”€
addRoad(R(60), RZ(270), R(1000), RZ(270), 14);
addRoad(R(60), RZ(470), R(1000), RZ(470), 14);
addRoad(R(60), RZ(680), R(1000), RZ(680), 14);

// â”€â”€ ë©”ì¸ ë‚¨ë¶ ë„ë¡œ (ì„¸ë¡œ) â”€â”€
addRoad(R(130), RZ(100), R(130), RZ(880), 12);
addRoad(R(400), RZ(100), R(400), RZ(880), 12);
addRoad(R(680), RZ(100), R(680), RZ(880), 12);
addRoad(R(980), RZ(100), R(980), RZ(880), 12);

// â”€â”€ ì™¸ê³½ ìˆœí™˜ë„ë¡œ â”€â”€
addRoad(R(60), RZ(100), R(1000), RZ(100), 10);
addRoad(R(60), RZ(880), R(1000), RZ(880), 10);
addRoad(R(60), RZ(100), R(60), RZ(880), 10);
addRoad(R(1000), RZ(100), R(1000), RZ(880), 10);

// ============================================================
// Buildings
// ============================================================
const buildingMeshes = [];
const raycaster = new THREE.Raycaster();
const mouse = new THREE.Vector2();

function createBuilding(b) {
  const cx = (b.x + b.w/2 - 480) * SCALE;
  const cz = (820 - (b.z + b.d/2)) * SCALE;
  const w = b.w * SCALE;
  const d = b.d * SCALE;
  const h = b.h * SCALE;

  const group = new THREE.Group();
  group.userData = { ...b };
  const color = new THREE.Color(b.color);

  // â”€â”€ 1ì¸µ ê¸°ë‹¨ë¶€ (ì–´ë‘ìš´ ì½˜í¬ë¦¬íŠ¸) â”€â”€
  const baseH = Math.min(h * 0.15, 5);
  const baseGeo = new THREE.BoxGeometry(w + 2, baseH, d + 2);
  const baseMat = new THREE.MeshStandardMaterial({ color: 0x2a2d35, roughness: 0.9, metalness: 0.05 });
  const base = new THREE.Mesh(baseGeo, baseMat);
  base.position.set(0, baseH/2, 0);
  base.castShadow = true; base.receiveShadow = true;
  group.add(base);

  // â”€â”€ ë©”ì¸ ê±´ë¬¼ ë³¸ì²´ â”€â”€
  const mainH = h - baseH;
  const bodyGeo = new THREE.BoxGeometry(w, mainH, d);
  const bodyMat = new THREE.MeshStandardMaterial({
    color: color.clone().multiplyScalar(0.55),
    roughness: 0.5, metalness: 0.2
  });
  const body = new THREE.Mesh(bodyGeo, bodyMat);
  body.position.set(0, baseH + mainH/2, 0);
  body.castShadow = true; body.receiveShadow = true;
  group.add(body);

  // â”€â”€ ì™¸ë²½ íŒ¨ë„ ë¼ì¸ (ìˆ˜í‰ ì¤„) â”€â”€
  const panelCount = Math.floor(mainH / 4);
  for (let i = 0; i < panelCount; i++) {
    const py = baseH + 2 + i * 4;
    // ì•ë©´
    const lineGeo = new THREE.BoxGeometry(w + 0.2, 0.15, 0.15);
    const lineMat = new THREE.MeshStandardMaterial({
      color: color.clone().multiplyScalar(0.35), roughness: 0.7
    });
    const lineF = new THREE.Mesh(lineGeo, lineMat);
    lineF.position.set(0, py, d/2 + 0.1);
    group.add(lineF);
    const lineB = lineF.clone();
    lineB.position.z = -d/2 - 0.1;
    group.add(lineB);
    // ì˜†ë©´
    const sLineGeo = new THREE.BoxGeometry(0.15, 0.15, d + 0.2);
    const sLineF = new THREE.Mesh(sLineGeo, lineMat.clone());
    sLineF.position.set(w/2 + 0.1, py, 0);
    group.add(sLineF);
    const sLineB = sLineF.clone();
    sLineB.position.x = -w/2 - 0.1;
    group.add(sLineB);
  }

  // â”€â”€ ìˆ˜ì§ íŒ¨ë„ ë¼ì¸ â”€â”€
  const vCount = Math.floor(w / 12);
  for (let i = 1; i < vCount; i++) {
    const vx = -w/2 + i * (w / vCount);
    const vGeo = new THREE.BoxGeometry(0.15, mainH, 0.15);
    const vMat = new THREE.MeshStandardMaterial({
      color: color.clone().multiplyScalar(0.35), roughness: 0.7
    });
    const vF = new THREE.Mesh(vGeo, vMat);
    vF.position.set(vx, baseH + mainH/2, d/2 + 0.1);
    group.add(vF);
    const vB = vF.clone();
    vB.position.z = -d/2 - 0.1;
    group.add(vB);
  }

  // â”€â”€ ì°½ë¬¸ (4ë©´ ì „ì²´, ì¸µë³„ ìœ ë¦¬ íŒ¨ë„) â”€â”€
  const winSpacingX = 6;
  const winSpacingY = 6;
  const winW = 3.5;
  const winH = 2.8;
  const winColsF = Math.max(1, Math.floor((w - 4) / winSpacingX));
  const winColsS = Math.max(1, Math.floor((d - 4) / winSpacingY));
  const winRows = Math.max(1, Math.floor((mainH - 3) / winSpacingY));

  for (let row = 0; row < winRows; row++) {
    const wy = baseH + 3 + row * winSpacingY;
    const flicker = () => 0.15 + Math.random() * 0.6;
    const bright = () => 0.5 + Math.random() * 0.4;

    // ì•Â·ë’·ë©´
    for (let col = 0; col < winColsF; col++) {
      const wx = -w/2 + 3 + col * winSpacingX;
      const wGeo = new THREE.PlaneGeometry(winW, winH);
      const wMat = new THREE.MeshStandardMaterial({
        color: 0x8ac4ed, emissive: 0x3388bb,
        emissiveIntensity: flicker(),
        transparent: true, opacity: bright(),
        side: THREE.DoubleSide
      });
      // ì•ë©´
      const winF = new THREE.Mesh(wGeo, wMat);
      winF.userData.isWindow = true;
      winF.position.set(wx, wy, d/2 + 0.15);
      group.add(winF);
      // ë’·ë©´
      const winB = new THREE.Mesh(wGeo, wMat.clone());
      winB.userData.isWindow = true;
      winB.material.emissiveIntensity = flicker();
      winB.material.opacity = bright();
      winB.position.set(wx, wy, -d/2 - 0.15);
      group.add(winB);
    }

    // ì¢ŒÂ·ìš° ì˜†ë©´
    for (let col = 0; col < winColsS; col++) {
      const wz = -d/2 + 3 + col * winSpacingX;
      const wGeo = new THREE.PlaneGeometry(winW, winH);
      const wMat = new THREE.MeshStandardMaterial({
        color: 0x8ac4ed, emissive: 0x3388bb,
        emissiveIntensity: flicker(),
        transparent: true, opacity: bright(),
        side: THREE.DoubleSide
      });
      // ì˜¤ë¥¸ìª½
      const winR = new THREE.Mesh(wGeo, wMat);
      winR.userData.isWindow = true;
      winR.rotation.y = Math.PI / 2;
      winR.position.set(w/2 + 0.15, wy, wz);
      group.add(winR);
      // ì™¼ìª½
      const winL = new THREE.Mesh(wGeo, wMat.clone());
      winL.userData.isWindow = true;
      winL.material.emissiveIntensity = flicker();
      winL.material.opacity = bright();
      winL.rotation.y = Math.PI / 2;
      winL.position.set(-w/2 - 0.15, wy, wz);
      group.add(winL);
    }
  }

  // â”€â”€ ì˜¥ìƒ â”€â”€
  const roofGeo = new THREE.BoxGeometry(w + 1.5, 0.8, d + 1.5);
  const roofMat = new THREE.MeshStandardMaterial({
    color: color.clone().multiplyScalar(0.4), roughness: 0.6, metalness: 0.3
  });
  const roof = new THREE.Mesh(roofGeo, roofMat);
  roof.position.set(0, h + 0.4, 0);
  roof.castShadow = true;
  group.add(roof);

  // â”€â”€ ì˜¥ìƒ ìƒ‰ìƒ ë  (ê±´ë¬¼ êµ¬ë¶„) â”€â”€
  const stripGeo = new THREE.BoxGeometry(w + 2, 1.2, d + 2);
  const stripMat = new THREE.MeshStandardMaterial({
    color: color, emissive: color, emissiveIntensity: 0.5,
    roughness: 0.3, metalness: 0.1
  });
  const strip = new THREE.Mesh(stripGeo, stripMat);
  strip.position.set(0, h - 0.5, 0);
  group.add(strip);

  // â”€â”€ ì˜¥ìƒ ì¥ë¹„ (FAB íŠ¹ìœ ì˜ ê³µì¡°/ë°°ê¸° ì¥ì¹˜) â”€â”€
  const equipCount = Math.floor(w / 18);
  for (let i = 0; i < equipCount; i++) {
    // ê³µì¡°ê¸° ë°•ìŠ¤
    const eqW = 3 + Math.random() * 3;
    const eqH = 2 + Math.random() * 3;
    const eqD = 3 + Math.random() * 2;
    const eqGeo = new THREE.BoxGeometry(eqW, eqH, eqD);
    const eqMat = new THREE.MeshStandardMaterial({ color: 0x556677, roughness: 0.6, metalness: 0.4 });
    const eq = new THREE.Mesh(eqGeo, eqMat);
    eq.position.set(-w/2 + 8 + i * 18, h + 0.8 + eqH/2, -d/4 + Math.random() * d/2);
    eq.castShadow = true;
    group.add(eq);

    // ë°°ê¸° íŒŒì´í”„
    const pipeGeo = new THREE.CylinderGeometry(0.4, 0.4, eqH + 2, 6);
    const pipeMat = new THREE.MeshStandardMaterial({ color: 0x888888, roughness: 0.3, metalness: 0.6 });
    const pipe = new THREE.Mesh(pipeGeo, pipeMat);
    pipe.position.set(eq.position.x + eqW/2 + 1, h + 0.8 + (eqH+2)/2, eq.position.z);
    group.add(pipe);
  }

  // â”€â”€ ì˜¥ìƒ ë°°ê´€ (ìˆ˜í‰ íŒŒì´í”„) â”€â”€
  if (d > 30) {
    for (let p = 0; p < 2; p++) {
      const pipeHGeo = new THREE.CylinderGeometry(0.3, 0.3, d * 0.8, 6);
      const pipeHMat = new THREE.MeshStandardMaterial({ color: 0x999999, roughness: 0.3, metalness: 0.5 });
      const pipeH = new THREE.Mesh(pipeHGeo, pipeHMat);
      pipeH.rotation.x = Math.PI / 2;
      pipeH.position.set(-w/4 + p * w/2, h + 1.5, 0);
      group.add(pipeH);
    }
  }

  // â”€â”€ ê±´ë¬¼ ì…êµ¬ (1ì¸µ ì •ë©´) â”€â”€
  const doorGeo = new THREE.BoxGeometry(Math.min(w * 0.12, 6), baseH * 0.85, 0.5);
  const doorMat = new THREE.MeshStandardMaterial({
    color: 0x3a5577, emissive: 0x223344, emissiveIntensity: 0.3,
    roughness: 0.2, metalness: 0.3
  });
  const door = new THREE.Mesh(doorGeo, doorMat);
  door.position.set(0, baseH * 0.43, d/2 + 0.3);
  group.add(door);
  // ì…êµ¬ ìºë…¸í”¼
  const canopyGeo = new THREE.BoxGeometry(Math.min(w * 0.18, 10), 0.3, 3);
  const canopyMat = new THREE.MeshStandardMaterial({ color: 0x444d5a, roughness: 0.5, metalness: 0.3 });
  const canopy = new THREE.Mesh(canopyGeo, canopyMat);
  canopy.position.set(0, baseH * 0.9, d/2 + 1.8);
  canopy.castShadow = true;
  group.add(canopy);

  // â”€â”€ ë°”ë‹¥ ë°œê´‘ â”€â”€
  const glowGeo = new THREE.PlaneGeometry(w + 6, d + 6);
  const glowMat = new THREE.MeshStandardMaterial({
    color: color, emissive: color, emissiveIntensity: 0.12,
    transparent: true, opacity: 0.25,
  });
  const glowPlane = new THREE.Mesh(glowGeo, glowMat);
  glowPlane.rotation.x = -Math.PI / 2;
  glowPlane.position.y = 0.2;
  group.add(glowPlane);

  // â”€â”€ ê±´ë¬¼ ì´ë¦„ ë¼ë²¨ (ê³µì¤‘) â”€â”€
  const labelCanvas = document.createElement('canvas');
  const labelCtx = labelCanvas.getContext('2d');
  const labelText = b.name;
  const fontSize = 32;
  labelCtx.font = 'bold ' + fontSize + 'px Noto Sans KR, sans-serif';
  const tw = labelCtx.measureText(labelText).width;
  const typeFontSize = 16;
  labelCtx.font = typeFontSize + 'px Noto Sans KR, sans-serif';
  const tw2 = labelCtx.measureText(b.type).width;
  const canvasW = Math.max(tw, tw2) + 40;
  const canvasH = fontSize + typeFontSize + 28;
  labelCanvas.width = canvasW;
  labelCanvas.height = canvasH;
  // ë°°ê²½
  labelCtx.fillStyle = 'rgba(8,8,16,0.75)';
  const rr = 8;
  labelCtx.beginPath();
  labelCtx.moveTo(rr, 0);
  labelCtx.lineTo(canvasW-rr, 0); labelCtx.quadraticCurveTo(canvasW, 0, canvasW, rr);
  labelCtx.lineTo(canvasW, canvasH-rr); labelCtx.quadraticCurveTo(canvasW, canvasH, canvasW-rr, canvasH);
  labelCtx.lineTo(rr, canvasH); labelCtx.quadraticCurveTo(0, canvasH, 0, canvasH-rr);
  labelCtx.lineTo(0, rr); labelCtx.quadraticCurveTo(0, 0, rr, 0);
  labelCtx.closePath();
  labelCtx.fill();
  // í•˜ë‹¨ ìƒ‰ìƒ ë°”
  const hexColor = '#' + b.color.toString(16).padStart(6, '0');
  labelCtx.fillStyle = hexColor;
  labelCtx.fillRect(10, canvasH - 5, canvasW - 20, 3);
  // ê±´ë¬¼ ì´ë¦„
  labelCtx.font = 'bold ' + fontSize + 'px Noto Sans KR, sans-serif';
  labelCtx.fillStyle = '#ffffff';
  labelCtx.textAlign = 'center';
  labelCtx.textBaseline = 'top';
  labelCtx.fillText(labelText, canvasW/2, 8);
  // ê±´ë¬¼ íƒ€ì…
  labelCtx.font = typeFontSize + 'px Noto Sans KR, sans-serif';
  labelCtx.fillStyle = hexColor;
  labelCtx.fillText(b.type, canvasW/2, fontSize + 12);

  const labelTexture = new THREE.CanvasTexture(labelCanvas);
  labelTexture.minFilter = THREE.LinearFilter;
  const labelSpriteMat = new THREE.SpriteMaterial({
    map: labelTexture, transparent: true, depthTest: false
  });
  const labelSprite = new THREE.Sprite(labelSpriteMat);
  const spriteScale = Math.max(w * 0.55, 22);
  labelSprite.scale.set(spriteScale, spriteScale * (canvasH/canvasW), 1);
  labelSprite.position.set(0, h + 14, 0);
  group.add(labelSprite);

  // â”€â”€ ë¼ë²¨ ì—°ê²°ì„  (ê±´ë¬¼ â†’ ë¼ë²¨) â”€â”€
  const lineGeo2 = new THREE.BufferGeometry().setFromPoints([
    new THREE.Vector3(0, h + 1.5, 0),
    new THREE.Vector3(0, h + 10, 0)
  ]);
  const lineMat2 = new THREE.LineBasicMaterial({ color: b.color, transparent: true, opacity: 0.4 });
  const labelLine = new THREE.Line(lineGeo2, lineMat2);
  group.add(labelLine);

  group.position.set(cx, 0, cz);
  scene.add(group);
  buildingMeshes.push(group);
  return group;
}

// Create all buildings with staggered animation
buildings.forEach((b, i) => {
  const group = createBuilding(b);
  // Start below ground for animation
  group.userData.targetY = 0;
  group.position.y = -50;
  group.userData.animDelay = i * 60;
  group.userData.animStarted = false;
});

// ============================================================
// OHT ê³µì¤‘ ì—°ê²° í†µë¡œ
// ============================================================
function createOHTBridge(startX, startZ, endX, endZ, bridgeHeight, bridgeLabel) {
  const bridgeGroup = new THREE.Group();
  const dx = endX - startX, dz = endZ - startZ;
  const length = Math.sqrt(dx*dx + dz*dz);
  const angle = Math.atan2(dz, dx);
  const bW = 2.8, bH = 2.5;

  // ë°”ë‹¥íŒ
  const floorGeo = new THREE.BoxGeometry(length, 0.3, bW);
  const floorMat = new THREE.MeshStandardMaterial({ color: 0x556677, roughness: 0.6, metalness: 0.3 });
  const floor = new THREE.Mesh(floorGeo, floorMat);
  floor.position.y = -bH/2;
  bridgeGroup.add(floor);
  // ì²œì¥íŒ
  const ceilGeo = new THREE.BoxGeometry(length, 0.25, bW+0.4);
  const ceil = new THREE.Mesh(ceilGeo, floorMat.clone());
  ceil.position.y = bH/2;
  bridgeGroup.add(ceil);

  // í”„ë ˆì„ ê¸°ë‘¥ + ìœ ë¦¬
  const segments = Math.max(1, Math.floor(length / 6));
  for (let i = 0; i <= segments; i++) {
    const sx = -length/2 + i*(length/segments);
    const fGeo = new THREE.BoxGeometry(0.25, bH, 0.25);
    const fMat = new THREE.MeshStandardMaterial({ color: 0x88999a, roughness: 0.4, metalness: 0.5 });
    const fL = new THREE.Mesh(fGeo, fMat);
    fL.position.set(sx, 0, bW/2);
    bridgeGroup.add(fL);
    const fR = fL.clone(); fR.position.z = -bW/2;
    bridgeGroup.add(fR);
  }
  for (let i = 0; i < segments; i++) {
    const sx = -length/2 + (i+0.5)*(length/segments);
    const pw = (length/segments) - 0.5;
    const gGeo = new THREE.PlaneGeometry(pw, bH-0.6);
    const gMat = new THREE.MeshStandardMaterial({ color: 0x99ccee, emissive: 0x224466, emissiveIntensity: 0.15, transparent: true, opacity: 0.25, side: THREE.DoubleSide });
    const gL = new THREE.Mesh(gGeo, gMat);
    gL.position.set(sx, 0, bW/2+0.05);
    bridgeGroup.add(gL);
    const gR = new THREE.Mesh(gGeo, gMat.clone());
    gR.position.set(sx, 0, -bW/2-0.05);
    bridgeGroup.add(gR);
  }

  // OHT ë ˆì¼
  const rGeo = new THREE.BoxGeometry(length-1, 0.2, 0.3);
  const rMat = new THREE.MeshStandardMaterial({ color: 0xccaa22, emissive: 0xaa8800, emissiveIntensity: 0.3, roughness: 0.3, metalness: 0.5 });
  const r1 = new THREE.Mesh(rGeo, rMat); r1.position.set(0, bH/2-0.3, -0.5); bridgeGroup.add(r1);
  const r2 = new THREE.Mesh(rGeo, rMat.clone()); r2.position.set(0, bH/2-0.3, 0.5); bridgeGroup.add(r2);

  // ì§€ì§€ ê¸°ë‘¥
  const pCnt = Math.max(1, Math.floor(length/35));
  for (let i = 0; i <= pCnt; i++) {
    const px = -length/2+5 + i*((length-10)/Math.max(1,pCnt));
    const pGeo = new THREE.BoxGeometry(1.2, bridgeHeight, 1.2);
    const pMat = new THREE.MeshStandardMaterial({ color: 0x667788, roughness: 0.6, metalness: 0.3 });
    const p = new THREE.Mesh(pGeo, pMat); p.castShadow = true;
    p.position.set(px, -bH/2-bridgeHeight/2, 0);
    bridgeGroup.add(p);
  }

  // í•˜ë¶€ ë°œê´‘
  const glGeo = new THREE.BoxGeometry(length, 0.15, 0.6);
  const glMat = new THREE.MeshStandardMaterial({ color: 0x44aaee, emissive: 0x2288cc, emissiveIntensity: 0.5, transparent: true, opacity: 0.5 });
  const gl = new THREE.Mesh(glGeo, glMat); gl.position.y = -bH/2-0.2; bridgeGroup.add(gl);

  // ë¼ë²¨
  if (bridgeLabel) {
    const lc = document.createElement('canvas');
    const lx2 = lc.getContext('2d');
    const fs = 20;
    lx2.font = 'bold '+fs+'px Noto Sans KR, sans-serif';
    const tw = lx2.measureText(bridgeLabel).width;
    lc.width = tw+20; lc.height = fs+10;
    lx2.fillStyle = 'rgba(0,30,60,0.75)';
    lx2.fillRect(0,0,lc.width,lc.height);
    lx2.fillStyle = 'rgba(0,150,220,0.8)';
    lx2.fillRect(0,lc.height-2,lc.width,2);
    lx2.font = 'bold '+fs+'px Noto Sans KR, sans-serif';
    lx2.fillStyle = '#ddeeff';
    lx2.textAlign = 'center'; lx2.textBaseline = 'middle';
    lx2.fillText(bridgeLabel, lc.width/2, lc.height/2);
    const tex = new THREE.CanvasTexture(lc); tex.minFilter = THREE.LinearFilter;
    const sm = new THREE.SpriteMaterial({ map: tex, transparent: true, depthTest: false });
    const sp = new THREE.Sprite(sm);
    sp.scale.set(12, 12*(lc.height/lc.width), 1);
    sp.position.set(0, bH/2+4, 0);
    bridgeGroup.add(sp);
  }

  bridgeGroup.position.set((startX+endX)/2, bridgeHeight, (startZ+endZ)/2);
  bridgeGroup.rotation.y = -angle;
  scene.add(bridgeGroup);
  return bridgeGroup;
}

// ê±´ë¬¼ ì›”ë“œ ì¢Œí‘œ ê³„ì‚°
function getBuildingWorldCenter(b) {
  return {
    x: (b.x + b.w / 2 - 480) * SCALE,
    z: (820 - (b.z + b.d / 2)) * SCALE,
    h: b.h * SCALE
  };
}

const m14 = getBuildingWorldCenter(buildings[0]);   // M14A/B
const m16 = getBuildingWorldCenter(buildings[4]);    // M16A/B

// OHT ë¸Œë¦¿ì§€ ë†’ì´ (ê±´ë¬¼ ì¤‘ê°„ ë†’ì´ ~ ìƒë‹¨)
const ohtH1 = Math.min(m14.h, m16.h) * 0.7;

// â”€â”€ M14A/B â†” M16A/B (OHT ì—°ê²°, M10B ì™¼ìª½ ìš°íšŒ, M16 ì™¼ìª½ë©´ ì§„ì…) â”€â”€
// M14(xâ‰ˆ-112, zâ‰ˆ230) â†’ M16 ì™¼ìª½ë©´(xâ‰ˆ25, zâ‰ˆ120)
// M10B ì›”ë“œë²”ìœ„: x=10~80, z=210~260
// ê²½ë¡œ: M14â†’ì§§ê²Œ ì˜¤ë¥¸ìª½(M10B ì™¼ìª½ ë°”ê¹¥ x=-5)â†’ìœ„ë¡œ(M16 z)â†’ì˜¤ë¥¸ìª½(M16 ì™¼ìª½ë©´)
const safeX = -15;             // M14 ì˜¤ë¥¸ìª½ ë(-7.5) ì•ˆìª½, ë„ë¡œ ì•ˆ ì¹¨ë²”, M10B(x=10) ì™¼ìª½ ë°”ê¹¥
const m16LeftX = 25;           // M16 ì™¼ìª½ ë (ë°ì´í„°x=530, ì›”ë“œ=(530-480)*0.5=25)

// 1) M14 ì˜¤ë¥¸ìª½ ëì—ì„œ ì§§ê²Œ ë‚˜ê° (ì»¨ë² ì´ì–´)
createOHTBridge(m14.x + 55, m14.z, safeX, m14.z, ohtH1, 'ì»¨ë² ì´ì–´');
// 2) M10B ì™¼ìª½ ë°”ê¹¥ì—ì„œ ìœ„ë¡œ (M16 ë†’ì´ê¹Œì§€, OHT ë ˆì¼) - M10B ì•ˆ ì§€ë‚˜ê°!
createOHTBridge(safeX, m14.z, safeX, m16.z + 10, ohtH1, 'OHT ë ˆì¼');
// 3) M16 ì™¼ìª½ë©´ìœ¼ë¡œ ì§§ê²Œ ì—°ê²° (ë¦¬í”„í„°)
createOHTBridge(safeX, m16.z + 10, m16LeftX, m16.z + 10, ohtH1, 'ë¦¬í”„í„°');

// â”€â”€ M16A/B 3ì¸µ â†” P&T4 5ì¸µ (ì»¨ë² ì´ì–´ ì—°ê²°, ë¦¬í”„íŠ¸ í¬í•¨) â”€â”€
const pt4 = getBuildingWorldCenter(buildings[7]);  // P&T4
// M16 3ì¸µ ë†’ì´: 11ì¸µ ì¤‘ 3ì¸µ = h * 3/11
const m16_3F = m16.h * (3 / 11);
// P&T4 5ì¸µ ë†’ì´: 8ì¸µ ì¤‘ 5ì¸µ = h * 5/8
const pt4_5F = pt4.h * (5 / 8);
const ohtH2 = (m16_3F + pt4_5F) / 2;  // ì¤‘ê°„ ë†’ì´

// M16 ì˜¤ë¥¸ìª½ â†’ ìˆ˜í‰ìœ¼ë¡œ â†’ êº¾ì–´ì„œ ì•„ë˜ë¡œ P&T4 (ã„±ì)
const m16RightX = m16.x + 55;   // M16 ì˜¤ë¥¸ìª½ ë ê·¼ì²˜
const cornerX2 = pt4.x - 30;    // P&T4 ì™¼ìª½ ê·¼ì²˜ (êº¾ì„ì  x)

// 1) M16 ì˜¤ë¥¸ìª½ì—ì„œ ìˆ˜í‰ìœ¼ë¡œ (ì»¨ë² ì´ì–´)
createOHTBridge(m16RightX, m16.z, cornerX2, m16.z, ohtH2, 'ì»¨ë² ì´ì–´(3ì¸µ)');
// 2) êº¾ì–´ì„œ ì•„ë˜ë¡œ P&T4ê¹Œì§€ (ë¦¬í”„í„°/5ì¸µ)
createOHTBridge(cornerX2, m16.z, cornerX2, pt4.z + 10, ohtH2, 'ë¦¬í”„í„°(5ì¸µ)');

// â”€â”€ M16A/B 2ì¸µ â†” P&T5 3ì¸µ (ì»¨ë² ì´ì–´ ì—°ê²°, ã„·ë°˜ëŒ€ í˜•íƒœ) â”€â”€
const pt5 = getBuildingWorldCenter(buildings[8]);  // P&T5
// M16 2ì¸µ: 11ì¸µ ì¤‘ 2ì¸µ
const m16_2F = m16.h * (2 / 11);
// P&T5 3ì¸µ: ì•½5ì¸µ ì¤‘ 3ì¸µ
const pt5_3F = pt5.h * (3 / 5);
const ohtH3 = (m16_2F + pt5_3F) / 2;

// ã„·(ë°˜ëŒ€): M16 ì˜¤ë¥¸ìª½ â†’ ì˜¤ë¥¸ìª½ìœ¼ë¡œ â†’ ì•„ë˜ë¡œ â†’ ì™¼ìª½ìœ¼ë¡œ P&T5
const m16Right2 = m16.x + 55;       // M16 ì˜¤ë¥¸ìª½ ë
const farRightX = pt4.x + 10;       // P&T4 ì˜¤ë¥¸ìª½ ë°”ê¹¥ (ì¶©ëŒ íšŒí”¼)
const pt5TopZ = pt5.z - 10;         // P&T5 ìœ„ìª½ ê·¼ì²˜

// 1) M16 ì˜¤ë¥¸ìª½ì—ì„œ ìˆ˜í‰ìœ¼ë¡œ ì˜¤ë¥¸ìª½ (ì»¨ë² ì´ì–´ 2ì¸µ)
createOHTBridge(m16Right2, m16.z - 15, farRightX, m16.z - 15, ohtH3, 'ì»¨ë² ì´ì–´(2ì¸µ)');
// 2) ì˜¤ë¥¸ìª½ì—ì„œ ì•„ë˜ë¡œ (ë¦¬í”„í„°)
createOHTBridge(farRightX, m16.z - 15, farRightX, pt5TopZ, ohtH3, 'ë¦¬í”„í„°');
// 3) ì™¼ìª½ìœ¼ë¡œ P&T5ê¹Œì§€ (ì»¨ë² ì´ì–´ 3ì¸µ)
createOHTBridge(farRightX, pt5TopZ, pt5.x + 30, pt5TopZ, ohtH3, 'ì»¨ë² ì´ì–´(3ì¸µ)');

// ============================================================
// Orbit Controls (manual implementation since OrbitControls isn't in r128 core)
// ============================================================
let isDragging = false;
let isRightDrag = false;
let prevMouse = { x: 0, y: 0 };
let spherical = { theta: 1.57, phi: 0.85, radius: 420 };
let target = new THREE.Vector3(35, 0, 170);

function updateCamera() {
  const x = target.x + spherical.radius * Math.sin(spherical.phi) * Math.cos(spherical.theta);
  const y = target.y + spherical.radius * Math.cos(spherical.phi);
  const z = target.z + spherical.radius * Math.sin(spherical.phi) * Math.sin(spherical.theta);
  camera.position.set(x, y, z);
  camera.lookAt(target);
}

renderer.domElement.addEventListener('mousedown', e => {
  if (e.button === 2) isRightDrag = true;
  else isDragging = true;
  prevMouse = { x: e.clientX, y: e.clientY };
});

renderer.domElement.addEventListener('mousemove', e => {
  const dx = e.clientX - prevMouse.x;
  const dy = e.clientY - prevMouse.y;

  if (isDragging) {
    spherical.theta -= dx * 0.005;
    spherical.phi = Math.max(0.2, Math.min(1.5, spherical.phi - dy * 0.005));
    updateCamera();
  }
  if (isRightDrag) {
    const right = new THREE.Vector3();
    camera.getWorldDirection(right);
    right.cross(camera.up).normalize();
    const up = new THREE.Vector3(0, 1, 0);
    target.add(right.multiplyScalar(-dx * 0.5));
    target.add(up.multiplyScalar(dy * 0.3));
    updateCamera();
  }

  // Tooltip on hover
  mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
  mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
  raycaster.setFromCamera(mouse, camera);
  const tooltip = document.getElementById('tooltip');

  let hit = false;
  for (const group of buildingMeshes) {
    const intersects = raycaster.intersectObjects(group.children, true);
    if (intersects.length > 0) {
      tooltip.style.display = 'block';
      tooltip.style.left = e.clientX + 'px';
      tooltip.style.top = e.clientY + 'px';
      tooltip.textContent = group.userData.name;
      document.body.style.cursor = 'pointer';
      hit = true;
      break;
    }
  }
  if (!hit) {
    tooltip.style.display = 'none';
    document.body.style.cursor = 'default';
  }

  prevMouse = { x: e.clientX, y: e.clientY };
});

window.addEventListener('mouseup', () => {
  isDragging = false;
  isRightDrag = false;
});

renderer.domElement.addEventListener('contextmenu', e => e.preventDefault());

renderer.domElement.addEventListener('wheel', e => {
  spherical.radius = Math.max(100, Math.min(900, spherical.radius + e.deltaY * 0.5));
  updateCamera();
});

// ì‚¬ëŒ ëŒ€ì‚¬ ëª©ë¡
const personDialogs = [
  'ì—¬ê¸°ê°€ SKí•˜ì´ë‹‰ìŠ¤ ì´ì²œìº í¼ìŠ¤ì•¼~',
  'ì˜¤ëŠ˜ë„ ì•¼ê·¼ì´ë‹¤.. í˜ë‚´ì!',
  'íšŒì‚¬ ì–´ë•Œ? ë‚˜ì˜ì§€ ì•Šì•„ ã…ã…',
  'ë°¥ ë¨¹ìœ¼ëŸ¬ ê°€ì~',
  'M16ë™ ì§„ì§œ í¬ë‹¤..',
  'ì—¬ê¸° ì–´ë””ì•¼? ì²˜ìŒ ì™”ëŠ”ë°..',
  'í´ë¦°ë£¸ ë“¤ì–´ê°€ê¸° ì „ì— ì»¤í”¼ í•œì”!',
  'ì›¨ì´í¼ ìˆ˜ìœ¨ ì˜¬ë ¤ì•¼ í•˜ëŠ”ë°..',
  'OHT ë¬¼ë¥˜ ì‹œìŠ¤í…œ ëŒ€ë‹¨í•˜ì§€ ì•Šëƒ?',
  'ì´ë²ˆ ì£¼ ê¸ˆìš”ì¼ì´ ì œì¼ ê¸°ë‹¤ë ¤ì§„ë‹¤',
  'ë°˜ë„ì²´ê°€ ë¯¸ë˜ë‹¤!',
  'ì ì‹¬ ë­ ë¨¹ì„ê¹Œ? ëœì¥ì°Œê°œ?',
  'ì˜¤ëŠ˜ ë‚ ì”¨ ì¢‹ë‹¤~',
  'ì €ê¸° ì •ë¬¸ ìª½ì— ì¹´í˜ ìƒˆë¡œ ìƒê²¼ëŒ€',
  'ë‚´ì¼ êµëŒ€ê·¼ë¬´ë¼ ì¼ì° ìì•¼í•´',
  'ê³µì • êµìœ¡ ë“£ê³  ì™”ëŠ”ë° ì–´ë µë‹¤..',
  'ì´ì²œì—ì„œ ì„œìš¸ê¹Œì§€ ë²„ìŠ¤ 1ì‹œê°„ì´ë©´ ê°€',
  'ê¸°ìˆ™ì‚¬ ë°¥ ë§›ìˆì–´ì¡Œë”ë¼',
  'ì—°ë´‰ í˜‘ìƒ ì˜ ëìœ¼ë©´ ì¢‹ê² ë‹¤ ã…',
  'DRAM ê°€ê²© ì˜¬ë¼ê°€ë©´ ì¢‹ê² ë‹¤~',
  'ì—¬ê¸° ì•¼ê²½ ì§„ì§œ ì´ì˜ë‹¤!',
  'ì£¼ë§ì— ë­ í•˜ì§€? ì´ì²œ ì˜¨ì²œ ê°ˆê¹Œ?',
  'ì„ ë°°ë‹˜ ì € ì§ˆë¬¸ ìˆëŠ”ë°ìš”..',
  'ì‹ ì…ì‚¬ì›ì¸ë° ê¸¸ì„ ìƒì—ˆì–´ìš”..',
  'ì—ë„ˆì§€ì„¼í„°ì—ì„œ ì»¤í”¼ ë§ˆì‹œê³  ì™”ì–´',
  'íƒë°° ì™”ë‹¤! ì•ˆë‚´ì„¼í„° ê°€ì•¼ì§€',
  'ìš´ë™í•˜ëŸ¬ ì²´ìœ¡ê´€ ê°€ì~',
  'ì˜¤ëŠ˜ ê³µì • ì ê²€ì´ë˜ ë°”ì˜ê² ë‹¤',
  'M14ë™ì—ì„œ M16ë™ê¹Œì§€ OHTë¡œ 5ë¶„!',
  'ì´ì²œìº í¼ìŠ¤ ìµœê³  ì•„ë‹ˆëƒ?!',
  'ì•„ ì¡¸ë ¤.. ì•¼ê·¼ ëë‚˜ë©´ ì¹˜í‚¨ ë¨¹ì',
  'ë³µì§€ê´€ì—ì„œ ë™í˜¸íšŒ ëª¨ì„ ìˆëŒ€',
  'í•˜ì´ë‹‰ìŠ¤ ë“¤ì–´ì˜¤ê¸¸ ì˜í–ˆë‹¤ ì§„ì§œ',
  'ì—¬ê¸° P&T4ë™ì´ 8ì¸µì´ë˜ ëŒ€ë°•',
  'ì•ˆì „ëª¨ ì“°ê³  ë‹¤ë…€ì•¼ í•´~',
  'ì£¼ì°¨ì¥ ì–´ë””ì•¼? ë§¨ë‚  í—·ê°ˆë ¤',
  'ì˜¤ëŠ˜ íšŒì˜ ëª‡ ì‹œì§€?',
  'í‡´ê·¼í•˜ê³  ì¹˜ë§¥í•˜ì!',
  'ì´ ê±´ë¬¼ ë­í•˜ëŠ” ë°ì•¼?',
  'ê³ ì†ë„ë¡œ ë§‰íˆë ¤ë‚˜.. ì¼ì° ê°€ì',
];
let speechTimer = null;

// Click to select
renderer.domElement.addEventListener('click', e => {
  mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
  mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
  raycaster.setFromCamera(mouse, camera);

  // ì‚¬ëŒ í´ë¦­ ì²´í¬
  let personHit = false;
  const allPersons = scene.children.filter(c => c.userData && c.userData.isPerson);
  for (const person of allPersons) {
    const intersects = raycaster.intersectObjects(person.children, true);
    if (intersects.length > 0) {
      personHit = true;
      // ëœë¤ ëŒ€ì‚¬
      const msg = personDialogs[Math.floor(Math.random() * personDialogs.length)];
      const bubble = document.getElementById('speechBubble');
      const text = document.getElementById('speechText');
      text.textContent = msg;
      // 3Dâ†’2D í™”ë©´ì¢Œí‘œ ë³€í™˜
      const pos = new THREE.Vector3();
      person.getWorldPosition(pos);
      pos.y += 6;
      pos.project(camera);
      const sx = (pos.x * 0.5 + 0.5) * window.innerWidth;
      const sy = (-pos.y * 0.5 + 0.5) * window.innerHeight;
      bubble.style.left = sx + 'px';
      bubble.style.top = sy + 'px';
      bubble.style.display = 'block';
      bubble.style.animation = 'none';
      bubble.offsetHeight; // reflow
      bubble.style.animation = 'bubblePop 0.3s ease-out';
      // 3ì´ˆ í›„ ì‚¬ë¼ì§
      if (speechTimer) clearTimeout(speechTimer);
      speechTimer = setTimeout(() => { bubble.style.display = 'none'; }, 3000);
      break;
    }
  }

  // ì¤„ ì„œìˆëŠ” ì‚¬ëŒë„ ì²´í¬ (isPerson ì—†ëŠ” ì¼ë°˜ ê·¸ë£¹)
  if (!personHit) {
    const allGroups = scene.children.filter(c => c.isGroup && c.children.length === 5 && !c.userData.isPerson && !c.userData.isBus);
    for (const grp of allGroups) {
      const intersects = raycaster.intersectObjects(grp.children, true);
      if (intersects.length > 0) {
        personHit = true;
        const msg = personDialogs[Math.floor(Math.random() * personDialogs.length)];
        const bubble = document.getElementById('speechBubble');
        const text = document.getElementById('speechText');
        text.textContent = msg;
        const pos = new THREE.Vector3();
        grp.getWorldPosition(pos);
        pos.y += 6;
        pos.project(camera);
        const sx = (pos.x * 0.5 + 0.5) * window.innerWidth;
        const sy = (-pos.y * 0.5 + 0.5) * window.innerHeight;
        bubble.style.left = sx + 'px';
        bubble.style.top = sy + 'px';
        bubble.style.display = 'block';
        bubble.style.animation = 'none';
        bubble.offsetHeight;
        bubble.style.animation = 'bubblePop 0.3s ease-out';
        if (speechTimer) clearTimeout(speechTimer);
        speechTimer = setTimeout(() => { bubble.style.display = 'none'; }, 3000);
        break;
      }
    }
  }

  if (personHit) return; // ì‚¬ëŒ í´ë¦­ì´ë©´ ê±´ë¬¼ ì„ íƒ ì•ˆ í•¨

  for (const group of buildingMeshes) {
    const intersects = raycaster.intersectObjects(group.children, true);
    if (intersects.length > 0) {
      const d = group.userData;
      document.getElementById('bName').textContent = d.name;
      document.getElementById('bType').textContent = d.type;
      document.getElementById('bDetail').innerHTML = d.detail.replace(/\n/g, '<br>');

      // Highlight animation
      group.children.forEach(child => {
        if (child.material && child.material.emissive) {
          const origIntensity = child.material.emissiveIntensity;
          child.material.emissiveIntensity = 1.5;
          setTimeout(() => { child.material.emissiveIntensity = origIntensity; }, 400);
        }
      });
      break;
    }
  }
});

// Touch support
let touchStart = null;
let touchDist = 0;
renderer.domElement.addEventListener('touchstart', e => {
  if (e.touches.length === 1) {
    touchStart = { x: e.touches[0].clientX, y: e.touches[0].clientY };
  } else if (e.touches.length === 2) {
    const dx = e.touches[0].clientX - e.touches[1].clientX;
    const dy = e.touches[0].clientY - e.touches[1].clientY;
    touchDist = Math.sqrt(dx*dx + dy*dy);
  }
});
renderer.domElement.addEventListener('touchmove', e => {
  e.preventDefault();
  if (e.touches.length === 1 && touchStart) {
    const dx = e.touches[0].clientX - touchStart.x;
    const dy = e.touches[0].clientY - touchStart.y;
    spherical.theta -= dx * 0.005;
    spherical.phi = Math.max(0.2, Math.min(1.5, spherical.phi - dy * 0.005));
    updateCamera();
    touchStart = { x: e.touches[0].clientX, y: e.touches[0].clientY };
  } else if (e.touches.length === 2) {
    const dx = e.touches[0].clientX - e.touches[1].clientX;
    const dy = e.touches[0].clientY - e.touches[1].clientY;
    const dist = Math.sqrt(dx*dx + dy*dy);
    spherical.radius = Math.max(100, Math.min(900, spherical.radius - (dist - touchDist) * 1.5));
    touchDist = dist;
    updateCamera();
  }
}, { passive: false });

// ============================================================
// Minimap
// ============================================================
const minimapCanvas = document.getElementById('minimapCanvas');
const mCtx = minimapCanvas.getContext('2d');

function setupMinimap() {
  const rect = document.getElementById('minimap').getBoundingClientRect();
  minimapCanvas.width = rect.width * 2;
  minimapCanvas.height = rect.height * 2;
  mCtx.scale(2, 2);
}
setupMinimap();

function drawMinimap() {
  const cw = minimapCanvas.width / 2;
  const ch = minimapCanvas.height / 2;
  mCtx.clearRect(0, 0, cw, ch);

  // Background
  mCtx.fillStyle = 'rgba(10,10,20,0.95)';
  mCtx.fillRect(0, 0, cw, ch);

  // Map coordinate transform: building data x,z -> minimap px
  const mapMinX = 30, mapMaxX = 940, mapMinZ = 180, mapMaxZ = 820;
  const padX = 14, padY = 20;
  const drawW = cw - padX * 2;
  const drawH = ch - padY * 2;

  function toMinimap(bx, bz) {
    const mx = padX + ((bx - mapMinX) / (mapMaxX - mapMinX)) * drawW;
    const my = padY + ((bz - mapMinZ) / (mapMaxZ - mapMinZ)) * drawH;
    return [mx, my];
  }

  // Draw campus boundary
  mCtx.beginPath();
  boundaryPts2D.forEach((p, i) => {
    const [mx, my] = toMinimap(p[0], p[1]);
    if (i === 0) mCtx.moveTo(mx, my);
    else mCtx.lineTo(mx, my);
  });
  mCtx.closePath();
  mCtx.fillStyle = 'rgba(24,30,40,0.8)';
  mCtx.fill();
  mCtx.strokeStyle = 'rgba(60,70,90,0.6)';
  mCtx.lineWidth = 0.8;
  mCtx.stroke();

  // Draw buildings
  buildings.forEach(b => {
    const [mx, my] = toMinimap(b.x, b.z);
    const bw = (b.w / (mapMaxX - mapMinX)) * drawW;
    const bh = (b.d / (mapMaxZ - mapMinZ)) * drawH;
    const c = '#' + b.color.toString(16).padStart(6, '0');

    mCtx.fillStyle = c;
    mCtx.globalAlpha = 0.7;
    mCtx.fillRect(mx, my, Math.max(bw, 3), Math.max(bh, 2));
    mCtx.globalAlpha = 1;

    // Label for buildings
    mCtx.fillStyle = '#fff';
    mCtx.font = (b.h > 50 ? '6px' : '5px') + ' Noto Sans KR, sans-serif';
    mCtx.textAlign = 'center';
    mCtx.fillText(b.name, mx + bw / 2, my + bh / 2 + 2);
  });

  // OHT ì—°ê²°í†µë¡œ ë¯¸ë‹ˆë§µ (M14â†’ì˜¤ë¥¸ìª½â†’ìœ„â†’M16ì™¼ìª½, M10B ì™¼ìª½ ìš°íšŒ)
  mCtx.strokeStyle = 'rgba(0,170,255,0.8)';
  mCtx.lineWidth = 1.5;
  mCtx.setLineDash([3, 2]);
  const m14d = buildings[0], m16d = buildings[4];
  // ì›”ë“œâ†’ë°ì´í„° ë³€í™˜: dataX = worldX/0.5+480, dataZ = 820-worldZ/0.5
  const startDx = (m14.x+55)/0.5 + 480;
  const startDz = 820 - m14.z/0.5;
  const safeDx = (-15)/0.5 + 480;       // x=-15 â†’ ë°ì´í„°450
  const m16zDz = 820 - (m16.z+10)/0.5;
  const m16lDx = 25/0.5 + 480;          // x=25 â†’ ë°ì´í„°530
  const [p1, p1y] = toMinimap(startDx, startDz);
  const [p2, p2y] = toMinimap(safeDx, startDz);
  const [p3, p3y] = toMinimap(safeDx, m16zDz);
  const [p4, p4y] = toMinimap(m16lDx, m16zDz);
  // M14 â†’ ì˜¤ë¥¸ìª½ (M10B ì™¼ìª½ ë°”ê¹¥)
  mCtx.beginPath(); mCtx.moveTo(p1, p1y); mCtx.lineTo(p2, p2y); mCtx.stroke();
  // ìœ„ë¡œ (M16 ë†’ì´ê¹Œì§€)
  mCtx.beginPath(); mCtx.moveTo(p2, p2y); mCtx.lineTo(p3, p3y); mCtx.stroke();
  // M16 ì™¼ìª½ë©´ìœ¼ë¡œ
  mCtx.beginPath(); mCtx.moveTo(p3, p3y); mCtx.lineTo(p4, p4y); mCtx.stroke();
  mCtx.setLineDash([]);
  // êº¾ì„ì  í‘œì‹œ
  mCtx.fillStyle = 'rgba(0,170,255,0.9)';
  mCtx.beginPath(); mCtx.arc(p2, p2y, 2, 0, Math.PI*2); mCtx.fill();
  mCtx.beginPath(); mCtx.arc(p3, p3y, 2, 0, Math.PI*2); mCtx.fill();

  // M16 â†” P&T4 ì»¨ë² ì´ì–´ ë¯¸ë‹ˆë§µ (ã„±ì)
  const m16Rdx = (m16.x+55)/0.5 + 480;
  const m16Rdz = 820 - m16.z/0.5;
  const corner2dx = (pt4.x-30)/0.5 + 480;
  const pt4dz = 820 - (pt4.z+10)/0.5;
  const [pm16r, pm16ry] = toMinimap(m16Rdx, m16Rdz);
  const [pc2, pc2y] = toMinimap(corner2dx, m16Rdz);
  const [ppt4, ppt4y] = toMinimap(corner2dx, pt4dz);
  mCtx.strokeStyle = 'rgba(0,170,255,0.8)';
  mCtx.lineWidth = 1.5;
  mCtx.setLineDash([3, 2]);
  mCtx.beginPath(); mCtx.moveTo(pm16r, pm16ry); mCtx.lineTo(pc2, pc2y); mCtx.stroke();
  mCtx.beginPath(); mCtx.moveTo(pc2, pc2y); mCtx.lineTo(ppt4, ppt4y); mCtx.stroke();
  mCtx.setLineDash([]);
  mCtx.fillStyle = 'rgba(0,170,255,0.9)';
  mCtx.beginPath(); mCtx.arc(pc2, pc2y, 2, 0, Math.PI*2); mCtx.fill();

  // M16 â†” P&T5 ì»¨ë² ì´ì–´ ë¯¸ë‹ˆë§µ (ã„·ë°˜ëŒ€)
  const m16R2dx = (m16.x+55)/0.5 + 480;
  const m16R2dz = 820 - (m16.z-15)/0.5;
  const farRdx = (pt4.x+10)/0.5 + 480;
  const pt5Tdz = 820 - (pt5.z-10)/0.5;
  const pt5Edx = (pt5.x+30)/0.5 + 480;
  const [pp1, pp1y] = toMinimap(m16R2dx, m16R2dz);
  const [pp2, pp2y] = toMinimap(farRdx, m16R2dz);
  const [pp3, pp3y] = toMinimap(farRdx, pt5Tdz);
  const [pp4, pp4y] = toMinimap(pt5Edx, pt5Tdz);
  mCtx.strokeStyle = 'rgba(0,170,255,0.8)';
  mCtx.lineWidth = 1.5;
  mCtx.setLineDash([3, 2]);
  mCtx.beginPath(); mCtx.moveTo(pp1, pp1y); mCtx.lineTo(pp2, pp2y); mCtx.stroke();
  mCtx.beginPath(); mCtx.moveTo(pp2, pp2y); mCtx.lineTo(pp3, pp3y); mCtx.stroke();
  mCtx.beginPath(); mCtx.moveTo(pp3, pp3y); mCtx.lineTo(pp4, pp4y); mCtx.stroke();
  mCtx.setLineDash([]);
  mCtx.fillStyle = 'rgba(0,170,255,0.9)';
  mCtx.beginPath(); mCtx.arc(pp2, pp2y, 2, 0, Math.PI*2); mCtx.fill();
  mCtx.beginPath(); mCtx.arc(pp3, pp3y, 2, 0, Math.PI*2); mCtx.fill();

  // Draw camera position indicator
  // Convert camera world position back to building-data coords
  const camWorldX = camera.position.x;
  const camWorldZ = camera.position.z;
  // Inverse of: cx = (b.x + b.w/2 - 480) * SCALE  -> b.x = cx/SCALE + 480
  const camDataX = camWorldX / SCALE + 480;
  const camDataZ = 820 - camWorldZ / SCALE;
  const [camMX, camMY] = toMinimap(camDataX, camDataZ);

  // Camera direction (look target)
  const tgtDataX = target.x / SCALE + 480;
  const tgtDataZ = 820 - target.z / SCALE;
  const [tgtMX, tgtMY] = toMinimap(tgtDataX, tgtDataZ);

  // Direction line
  mCtx.beginPath();
  mCtx.moveTo(camMX, camMY);
  mCtx.lineTo(tgtMX, tgtMY);
  mCtx.strokeStyle = 'rgba(100,180,255,0.5)';
  mCtx.lineWidth = 1;
  mCtx.stroke();

  // Camera FOV cone
  const angle = Math.atan2(tgtMY - camMY, tgtMX - camMX);
  const fovHalf = 0.4;
  const coneLen = 18;
  mCtx.beginPath();
  mCtx.moveTo(camMX, camMY);
  mCtx.lineTo(camMX + Math.cos(angle - fovHalf) * coneLen, camMY + Math.sin(angle - fovHalf) * coneLen);
  mCtx.lineTo(camMX + Math.cos(angle + fovHalf) * coneLen, camMY + Math.sin(angle + fovHalf) * coneLen);
  mCtx.closePath();
  mCtx.fillStyle = 'rgba(80,160,255,0.15)';
  mCtx.fill();

  // Camera dot
  mCtx.beginPath();
  mCtx.arc(camMX, camMY, 3, 0, Math.PI * 2);
  mCtx.fillStyle = '#4af';
  mCtx.fill();
  mCtx.strokeStyle = '#fff';
  mCtx.lineWidth = 0.8;
  mCtx.stroke();

  // Target dot
  mCtx.beginPath();
  mCtx.arc(tgtMX, tgtMY, 2, 0, Math.PI * 2);
  mCtx.fillStyle = 'rgba(255,100,100,0.8)';
  mCtx.fill();
}

// Click minimap to reposition camera target
document.getElementById('minimap').addEventListener('click', function(e) {
  const rect = this.getBoundingClientRect();
  const clickX = e.clientX - rect.left;
  const clickY = e.clientY - rect.top;

  const cw = rect.width;
  const ch = rect.height;
  const padX = 14, padY = 20;
  const drawW = cw - padX * 2;
  const drawH = ch - padY * 2;

  const mapMinX = 30, mapMaxX = 940, mapMinZ = 180, mapMaxZ = 820;
  const dataX = mapMinX + ((clickX - padX) / drawW) * (mapMaxX - mapMinX);
  const dataZ = mapMinZ + ((clickY - padY) / drawH) * (mapMaxZ - mapMinZ);

  // Convert to world coords
  const worldX = (dataX - 480) * SCALE;
  const worldZ = (820 - dataZ) * SCALE;

  target.set(worldX, 0, worldZ);
  updateCamera();
});

// ============================================================
// Animation Loop
// ============================================================
updateCamera();
const clock = new THREE.Clock();
let startTime = Date.now();

function animate() {
  requestAnimationFrame(animate);
  const elapsed = Date.now() - startTime;

  // Building rise animation
  buildingMeshes.forEach(group => {
    if (elapsed > group.userData.animDelay) {
      if (!group.userData.animStarted) {
        group.userData.animStarted = true;
        group.userData.animTime = 0;
      }
      group.userData.animTime += 0.03;
      const t = Math.min(1, group.userData.animTime);
      // Ease out cubic
      const ease = 1 - Math.pow(1 - t, 3);
      group.position.y = -50 + 50 * ease;
    }
  });

  // Subtle camera auto-rotate when idle
  // (disabled to keep user control)

  // ì²œì²´ ì—…ë°ì´íŠ¸ (í•´/ë‹¬ ìœ„ì¹˜, í•˜ëŠ˜ìƒ‰, ì¡°ëª…)
  updateSky();

  // Window flicker (í•­ìƒ - ë°¤ì—ë„ ê¹œë¹¡ì„)
  if (Math.random() < 0.02) {
    const randomBuilding = buildingMeshes[Math.floor(Math.random() * buildingMeshes.length)];
    randomBuilding.children.forEach(child => {
      if (child.userData && child.userData.isWindow) {
        child.material.emissiveIntensity = 0.3 + Math.random() * 0.6;
      }
    });
  }

  // ì‚¬ëŒ ê±·ê¸° ì• ë‹ˆë©”ì´ì…˜
  scene.children.forEach(obj => {
    if (obj.userData && obj.userData.isPerson) {
      obj.userData.walkTimer += 1;
      // ì¼ì • ê°„ê²©ìœ¼ë¡œ ë°©í–¥ ì „í™˜
      if (obj.userData.walkTimer % 200 < 1) {
        obj.userData.walkDir += (Math.random() - 0.5) * 1.5;
      }
      const spd = obj.userData.walkSpeed;
      const dir = obj.userData.walkDir;
      obj.position.x += Math.cos(dir) * spd;
      obj.position.z += Math.sin(dir) * spd;
      obj.rotation.y = -dir + Math.PI/2;
      // ì˜ì—­ ë°–ì´ë©´ ë˜ëŒë¦¬ê¸°
      const z = obj.userData.zone;
      if (obj.position.x < z.xMin) { obj.position.x = z.xMin; obj.userData.walkDir = Math.random()*Math.PI; }
      if (obj.position.x > z.xMax) { obj.position.x = z.xMax; obj.userData.walkDir = Math.PI+Math.random()*Math.PI; }
      if (obj.position.z < z.zMin) { obj.position.z = z.zMin; obj.userData.walkDir = Math.PI*0.5*Math.random(); }
      if (obj.position.z > z.zMax) { obj.position.z = z.zMax; obj.userData.walkDir = -Math.PI*0.5+Math.random()*Math.PI; }
      // ê±·ëŠ” ëª¨ì…˜ (ë‹¤ë¦¬ í”ë“¤ê¸°)
      const swing = Math.sin(obj.userData.walkTimer * 0.15) * 0.15;
      if (obj.children[3]) obj.children[3].rotation.x = swing;  // ì™¼ë‹¤ë¦¬
      if (obj.children[4]) obj.children[4].rotation.x = -swing; // ì˜¤ë¥¸ë‹¤ë¦¬
    }
  });

  // ë²„ìŠ¤ ì£¼í–‰ ì• ë‹ˆë©”ì´ì…˜
  busGroup.forEach(bus => {
    const r = bus.userData.route;
    const p0 = r[0], p1 = r[1];
    bus.userData.progress += bus.userData.speed * 0.002 * bus.userData.forward;
    if (bus.userData.progress >= 1) { bus.userData.progress = 1; bus.userData.forward = -1; }
    if (bus.userData.progress <= 0) { bus.userData.progress = 0; bus.userData.forward = 1; }
    const t = bus.userData.progress;
    bus.position.x = p0.x + (p1.x - p0.x) * t;
    bus.position.z = p0.z + (p1.z - p0.z) * t;
    // ë°©í–¥ ë§ì¶”ê¸°
    const dx = (p1.x - p0.x) * bus.userData.forward;
    const dz = (p1.z - p0.z) * bus.userData.forward;
    bus.rotation.y = -Math.atan2(dz, dx) + Math.PI/2;
  });

  // ê³ ì†ë„ë¡œ ì°¨ëŸ‰ ì£¼í–‰
  hwCars.forEach(car => {
    car.position.z += car.userData.speed * car.userData.dir;
    // ë²”ìœ„ ë°–ì´ë©´ ë°˜ëŒ€ìª½ì—ì„œ ë‹¤ì‹œ ì¶œë°œ
    if (car.position.z > 530) { car.position.z = -190; }
    if (car.position.z < -190) { car.position.z = 530; }
  });

  renderer.render(scene, camera);

  // Update minimap
  drawMinimap();
}

// Hide loading
setTimeout(() => {
  document.getElementById('loading').classList.add('hidden');
  startTime = Date.now();
  animate();
}, 500);

// Resize
window.addEventListener('resize', () => {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
  setupMinimap();
});
</script>
</body>
</html>
