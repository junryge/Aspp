"""
================================================================================
AMHS ì˜ˆì¸¡ ëª¨ë¸ íŒ¨ì¹˜ë…¸íŠ¸ ê´€ë¦¬ í”„ë¡œê·¸ë¨ (GUI)
================================================================================
ê¸°ëŠ¥:
  - íŒ¨ì¹˜ë…¸íŠ¸ ì‘ì„±/ìˆ˜ì •/ì‚­ì œ
  - JSON íŒŒì¼ë¡œ ì €ì¥/ë¡œë“œ
  - íƒ­ìœ¼ë¡œ ë²„ì „ë³„ ë¶„ë¦¬
  - MD ë‚´ë³´ë‚´ê¸°
================================================================================
"""

import tkinter as tk
from tkinter import ttk, messagebox, filedialog, scrolledtext
import json
import os
from datetime import datetime
from typing import List, Dict, Optional


class PatchNote:
    """íŒ¨ì¹˜ë…¸íŠ¸ ë°ì´í„° í´ë˜ìŠ¤"""
    
    def __init__(self, version: str, date: str = None, note_type: str = "Major"):
        self.version = version
        self.date = date or datetime.now().strftime("%Y-%m-%d")
        self.type = note_type
        self.new: List[str] = []
        self.improved: List[str] = []
        self.fixed: List[str] = []
        self.breaking: List[str] = []
        self.metrics: List[str] = []
        self.files: List[str] = []
        self.next: List[str] = []
    
    def to_dict(self) -> dict:
        return {
            "version": self.version,
            "date": self.date,
            "type": self.type,
            "new": self.new,
            "improved": self.improved,
            "fixed": self.fixed,
            "breaking": self.breaking,
            "metrics": self.metrics,
            "files": self.files,
            "next": self.next,
        }
    
    @classmethod
    def from_dict(cls, data: dict) -> 'PatchNote':
        note = cls(data["version"], data["date"], data.get("type", "Major"))
        note.new = data.get("new", [])
        note.improved = data.get("improved", [])
        note.fixed = data.get("fixed", [])
        note.breaking = data.get("breaking", [])
        note.files = data.get("files", [])
        note.next = data.get("next", [])
        
        # metrics í˜¸í™˜ì„± ì²˜ë¦¬ (ë”•ì…”ë„ˆë¦¬ â†’ ë¦¬ìŠ¤íŠ¸ ë³€í™˜)
        metrics_data = data.get("metrics", [])
        if isinstance(metrics_data, dict):
            # ì´ì „ í˜•ì‹ (ë”•ì…”ë„ˆë¦¬) â†’ ë¦¬ìŠ¤íŠ¸ë¡œ ë³€í™˜
            note.metrics = []
            for name, info in metrics_data.items():
                if isinstance(info, dict):
                    note.metrics.append(f"{name}: {info.get('before', '-')} â†’ {info.get('after', '-')} ({info.get('change', '')})")
                else:
                    note.metrics.append(f"{name}: {info}")
        else:
            # ìƒˆ í˜•ì‹ (ë¦¬ìŠ¤íŠ¸)
            note.metrics = metrics_data
        
        return note


class PatchNoteApp:
    """íŒ¨ì¹˜ë…¸íŠ¸ GUI ì• í”Œë¦¬ì¼€ì´ì…˜"""
    
    def __init__(self, root):
        self.root = root
        self.root.title("AMHS ì˜ˆì¸¡ ëª¨ë¸ íŒ¨ì¹˜ë…¸íŠ¸ ê´€ë¦¬")
        self.root.geometry("900x700")
        self.root.configure(bg="#2b2b2b")
        
        self.notes: Dict[str, PatchNote] = {}
        self.current_version: Optional[str] = None
        self.save_file = "patch_notes.json"
        
        # ìŠ¤íƒ€ì¼ ì„¤ì •
        self.setup_styles()
        
        # UI êµ¬ì„±
        self.create_widgets()
        
        # ìƒ˜í”Œ ë°ì´í„° ë¡œë“œ
        self.load_or_create_sample()
    
    def setup_styles(self):
        """ìŠ¤íƒ€ì¼ ì„¤ì •"""
        style = ttk.Style()
        style.theme_use('clam')
        
        # ë‹¤í¬ í…Œë§ˆ ìƒ‰ìƒ
        self.colors = {
            'bg': '#2b2b2b',
            'fg': '#ffffff',
            'accent': '#4a9eff',
            'accent2': '#ff6b6b',
            'card': '#3c3c3c',
            'input': '#404040',
            'border': '#555555',
        }
        
        style.configure('TFrame', background=self.colors['bg'])
        style.configure('Card.TFrame', background=self.colors['card'])
        style.configure('TLabel', background=self.colors['bg'], foreground=self.colors['fg'], font=('ë§‘ì€ ê³ ë”•', 10))
        style.configure('Title.TLabel', font=('ë§‘ì€ ê³ ë”•', 14, 'bold'))
        style.configure('Header.TLabel', font=('ë§‘ì€ ê³ ë”•', 12, 'bold'))
        style.configure('TButton', font=('ë§‘ì€ ê³ ë”•', 10))
        style.configure('Accent.TButton', font=('ë§‘ì€ ê³ ë”•', 10, 'bold'))
        style.configure('TNotebook', background=self.colors['bg'])
        style.configure('TNotebook.Tab', font=('ë§‘ì€ ê³ ë”•', 10), padding=[10, 5])
    
    def create_widgets(self):
        """ìœ„ì ¯ ìƒì„±"""
        
        # ===== ìƒë‹¨ í—¤ë” =====
        header_frame = ttk.Frame(self.root)
        header_frame.pack(fill=tk.X, padx=10, pady=10)
        
        ttk.Label(header_frame, text="ğŸ“‹ AMHS ì˜ˆì¸¡ ëª¨ë¸ íŒ¨ì¹˜ë…¸íŠ¸", style='Title.TLabel').pack(side=tk.LEFT)
        
        # ë²„íŠ¼ë“¤
        btn_frame = ttk.Frame(header_frame)
        btn_frame.pack(side=tk.RIGHT)
        
        ttk.Button(btn_frame, text="ğŸ’¾ ì €ì¥", command=self.save_notes).pack(side=tk.LEFT, padx=2)
        ttk.Button(btn_frame, text="ğŸ“‚ ë¡œë“œ", command=self.load_notes).pack(side=tk.LEFT, padx=2)
        ttk.Button(btn_frame, text="ğŸ“„ MD ë‚´ë³´ë‚´ê¸°", command=self.export_md).pack(side=tk.LEFT, padx=2)
        ttk.Button(btn_frame, text="â• ìƒˆ ë²„ì „", command=self.new_version_dialog).pack(side=tk.LEFT, padx=2)
        
        # ===== ë©”ì¸ ì˜ì—­ =====
        main_frame = ttk.Frame(self.root)
        main_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=5)
        
        # ì¢Œì¸¡: ë²„ì „ ëª©ë¡
        left_frame = ttk.Frame(main_frame, width=150)
        left_frame.pack(side=tk.LEFT, fill=tk.Y, padx=(0, 10))
        left_frame.pack_propagate(False)
        
        ttk.Label(left_frame, text="ğŸ“¦ ë²„ì „ ëª©ë¡", style='Header.TLabel').pack(pady=5)
        
        self.version_listbox = tk.Listbox(
            left_frame, 
            font=('ë§‘ì€ ê³ ë”•', 11),
            bg=self.colors['card'],
            fg=self.colors['fg'],
            selectbackground=self.colors['accent'],
            selectforeground='white',
            borderwidth=0,
            highlightthickness=1,
            highlightcolor=self.colors['border']
        )
        self.version_listbox.pack(fill=tk.BOTH, expand=True, pady=5)
        self.version_listbox.bind('<<ListboxSelect>>', self.on_version_select)
        
        ttk.Button(left_frame, text="ğŸ—‘ï¸ ì‚­ì œ", command=self.delete_version).pack(fill=tk.X, pady=5)
        
        # ìš°ì¸¡: íŒ¨ì¹˜ë…¸íŠ¸ ìƒì„¸
        right_frame = ttk.Frame(main_frame)
        right_frame.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        
        # íƒ­ ë…¸íŠ¸ë¶
        self.notebook = ttk.Notebook(right_frame)
        self.notebook.pack(fill=tk.BOTH, expand=True)
        
        # íƒ­ 1: ê¸°ë³¸ ì •ë³´
        self.tab_info = ttk.Frame(self.notebook)
        self.notebook.add(self.tab_info, text="ğŸ“ ê¸°ë³¸ ì •ë³´")
        self.create_info_tab()
        
        # íƒ­ 2: ì‹ ê·œ/ê°œì„ 
        self.tab_changes = ttk.Frame(self.notebook)
        self.notebook.add(self.tab_changes, text="âœ¨ ë³€ê²½ì‚¬í•­")
        self.create_changes_tab()
        
        # íƒ­ 3: ì„±ëŠ¥/íŒŒì¼
        self.tab_metrics = ttk.Frame(self.notebook)
        self.notebook.add(self.tab_metrics, text="ğŸ“Š ì„±ëŠ¥/íŒŒì¼")
        self.create_metrics_tab()
        
        # íƒ­ 4: ë¯¸ë¦¬ë³´ê¸°
        self.tab_preview = ttk.Frame(self.notebook)
        self.notebook.add(self.tab_preview, text="ğŸ‘ï¸ ë¯¸ë¦¬ë³´ê¸°")
        self.create_preview_tab()
    
    def create_info_tab(self):
        """ê¸°ë³¸ ì •ë³´ íƒ­"""
        frame = ttk.Frame(self.tab_info, padding=20)
        frame.pack(fill=tk.BOTH, expand=True)
        
        # ë²„ì „
        ttk.Label(frame, text="ë²„ì „:").grid(row=0, column=0, sticky='w', pady=5)
        self.entry_version = ttk.Entry(frame, font=('ë§‘ì€ ê³ ë”•', 11), width=20)
        self.entry_version.grid(row=0, column=1, sticky='w', pady=5, padx=5)
        
        # ë‚ ì§œ
        ttk.Label(frame, text="ë‚ ì§œ:").grid(row=1, column=0, sticky='w', pady=5)
        self.entry_date = ttk.Entry(frame, font=('ë§‘ì€ ê³ ë”•', 11), width=20)
        self.entry_date.grid(row=1, column=1, sticky='w', pady=5, padx=5)
        
        # ìœ í˜•
        ttk.Label(frame, text="ìœ í˜•:").grid(row=2, column=0, sticky='w', pady=5)
        self.combo_type = ttk.Combobox(frame, values=["Major", "Minor", "Patch"], font=('ë§‘ì€ ê³ ë”•', 11), width=17)
        self.combo_type.grid(row=2, column=1, sticky='w', pady=5, padx=5)
        self.combo_type.set("Major")
        
        # Breaking Changes
        ttk.Label(frame, text="Breaking Changes:").grid(row=3, column=0, sticky='nw', pady=5)
        self.text_breaking = scrolledtext.ScrolledText(frame, height=4, width=50, font=('ë§‘ì€ ê³ ë”•', 10),
                                                        bg=self.colors['input'], fg=self.colors['fg'])
        self.text_breaking.grid(row=3, column=1, sticky='w', pady=5, padx=5)
        
        # ë‹¤ìŒ ë²„ì „ ì˜ˆê³ 
        ttk.Label(frame, text="ë‹¤ìŒ ë²„ì „ ì˜ˆê³ :").grid(row=4, column=0, sticky='nw', pady=5)
        self.text_next = scrolledtext.ScrolledText(frame, height=4, width=50, font=('ë§‘ì€ ê³ ë”•', 10),
                                                    bg=self.colors['input'], fg=self.colors['fg'])
        self.text_next.grid(row=4, column=1, sticky='w', pady=5, padx=5)
    
    def create_changes_tab(self):
        """ë³€ê²½ì‚¬í•­ íƒ­"""
        frame = ttk.Frame(self.tab_changes, padding=20)
        frame.pack(fill=tk.BOTH, expand=True)
        
        # ì‹ ê·œ ê¸°ëŠ¥
        ttk.Label(frame, text="âœ¨ ì‹ ê·œ ê¸°ëŠ¥ (ì¤„ë°”ê¿ˆìœ¼ë¡œ êµ¬ë¶„):", style='Header.TLabel').pack(anchor='w')
        self.text_new = scrolledtext.ScrolledText(frame, height=6, font=('ë§‘ì€ ê³ ë”•', 10),
                                                   bg=self.colors['input'], fg=self.colors['fg'])
        self.text_new.pack(fill=tk.X, pady=(5, 15))
        
        # ê°œì„ ì‚¬í•­
        ttk.Label(frame, text="â¬†ï¸ ê°œì„ ì‚¬í•­ (ì¤„ë°”ê¿ˆìœ¼ë¡œ êµ¬ë¶„):", style='Header.TLabel').pack(anchor='w')
        self.text_improved = scrolledtext.ScrolledText(frame, height=6, font=('ë§‘ì€ ê³ ë”•', 10),
                                                        bg=self.colors['input'], fg=self.colors['fg'])
        self.text_improved.pack(fill=tk.X, pady=(5, 15))
        
        # ë²„ê·¸ ìˆ˜ì •
        ttk.Label(frame, text="ğŸ”§ ë²„ê·¸ ìˆ˜ì • (ì¤„ë°”ê¿ˆìœ¼ë¡œ êµ¬ë¶„):", style='Header.TLabel').pack(anchor='w')
        self.text_fixed = scrolledtext.ScrolledText(frame, height=6, font=('ë§‘ì€ ê³ ë”•', 10),
                                                     bg=self.colors['input'], fg=self.colors['fg'])
        self.text_fixed.pack(fill=tk.X, pady=(5, 15))
    
    def create_metrics_tab(self):
        """ì„±ëŠ¥/íŒŒì¼ íƒ­"""
        frame = ttk.Frame(self.tab_metrics, padding=20)
        frame.pack(fill=tk.BOTH, expand=True)
        
        # ì„±ëŠ¥ ì§€í‘œ
        ttk.Label(frame, text="ğŸ“Š ì„±ëŠ¥ ë³€í™” (ì¤„ë°”ê¿ˆìœ¼ë¡œ êµ¬ë¶„):", style='Header.TLabel').pack(anchor='w')
        self.text_metrics = scrolledtext.ScrolledText(frame, height=6, font=('ë§‘ì€ ê³ ë”•', 10),
                                                       bg=self.colors['input'], fg=self.colors['fg'])
        self.text_metrics.pack(fill=tk.X, pady=(5, 15))
        
        # ë³€ê²½ íŒŒì¼
        ttk.Label(frame, text="ğŸ“ ë³€ê²½ íŒŒì¼ (ì¤„ë°”ê¿ˆìœ¼ë¡œ êµ¬ë¶„):", style='Header.TLabel').pack(anchor='w')
        self.text_files = scrolledtext.ScrolledText(frame, height=8, font=('ë§‘ì€ ê³ ë”•', 10),
                                                     bg=self.colors['input'], fg=self.colors['fg'])
        self.text_files.pack(fill=tk.X, pady=(5, 15))
    
    def create_preview_tab(self):
        """ë¯¸ë¦¬ë³´ê¸° íƒ­"""
        frame = ttk.Frame(self.tab_preview, padding=10)
        frame.pack(fill=tk.BOTH, expand=True)
        
        ttk.Button(frame, text="ğŸ”„ ìƒˆë¡œê³ ì¹¨", command=self.refresh_preview).pack(anchor='w', pady=5)
        
        self.text_preview = scrolledtext.ScrolledText(
            frame, 
            font=('Consolas', 10),
            bg=self.colors['card'], 
            fg=self.colors['fg'],
            wrap=tk.NONE
        )
        self.text_preview.pack(fill=tk.BOTH, expand=True, pady=5)
    
    # ===== ê¸°ëŠ¥ ë©”ì„œë“œ =====
    
    def load_or_create_sample(self):
        """íŒŒì¼ ë¡œë“œ ë˜ëŠ” ìƒ˜í”Œ ìƒì„±"""
        if os.path.exists(self.save_file):
            self._load_from_file(self.save_file)
        else:
            self._create_sample_data()
        self.refresh_version_list()
    
    def _create_sample_data(self):
        """ìƒ˜í”Œ ë°ì´í„° ìƒì„±"""
        # V8
        v8 = PatchNote("V8.0.0", "2025-12-01", "Major")
        v8.new = [
            "ë²”ì£¼í˜• 3-Class ë¶„ë¥˜ ëª¨ë¸ ì¶”ê°€ (í•˜ë½/ì†Œí­/ê¸‰ì¦)",
            "M16HUB QUE ì»¬ëŸ¼ 5ê°œ ì¶”ê°€",
            "M16A QUE ì»¬ëŸ¼ 7ê°œ ì¶”ê°€",
            "CURRENT_M16A_3F_JOB ëŒ€ì²´ íƒ€ê²Ÿ ì»¬ëŸ¼ ì¶”ê°€",
        ]
        v8.improved = [
            "ì…ë ¥ ì»¬ëŸ¼: 19ê°œ â†’ 32ê°œ",
            "Feature ìˆ˜: 180ê°œ â†’ 222ê°œ",
            "ìˆ˜ì¹˜í˜• ëª¨ë¸: 50+ ë³€í™” ìƒ˜í”Œ 3ë°° ê°€ì¤‘ì¹˜ ì ìš©",
            "ë²”ì£¼í˜• ëª¨ë¸: Class2(ê¸‰ì¦) 5ë°° ê°€ì¤‘ì¹˜ ì ìš©",
        ]
        v8.metrics = [
            "MAE: 12.5 â†’ 9.8 (â†“21%)",
            "RÂ²: 0.62 â†’ 0.68 (â†‘9.7%)",
            "ë²”ì£¼í˜• ì •í™•ë„: 72% (ì‹ ê·œ)",
        ]
        v8.breaking = ["V7 ëª¨ë¸ íŒŒì¼(.pkl)ê³¼ í˜¸í™˜ë˜ì§€ ì•ŠìŒ", "V8 ì „ìš© í‰ê°€ ì½”ë“œ ì‚¬ìš© í•„ìš”"]
        v8.files = [
            "V8_ìˆ˜ì¹˜í˜•_í•™ìŠµì½”ë“œ.py", "V8_ìˆ˜ì¹˜í˜•_í‰ê°€ì½”ë“œ.py",
            "V8_ë²”ì£¼í˜•_í•™ìŠµì½”ë“œ.py", "V8_ë²”ì£¼í˜•_í‰ê°€ì½”ë“œ.py",
            "xgboost_ìˆ˜ì¹˜í˜•_V8.pkl", "xgboost_ë²”ì£¼í˜•_V8.pkl"
        ]
        v8.next = ["MLflow Tracking ì—°ë™", "í•˜ì´í¼íŒŒë¼ë¯¸í„° ìë™ íƒìƒ‰ (Optuna)"]
        self.notes["V8.0.0"] = v8
        
        # V7
        v7 = PatchNote("V7.0.0", "2025-11-15", "Major")
        v7.new = ["M16HUB.QUE.ALL.CURRENTQCNT ì»¬ëŸ¼ ì¶”ê°€", "QUE ê¸°ë°˜ ë³‘ëª© ê°ì§€ Feature ì¶”ê°€"]
        v7.improved = ["ì…ë ¥ ì»¬ëŸ¼: 17ê°œ â†’ 19ê°œ", "ë³‘ëª© ê°ì§€ ë¡œì§ ê°•í™”"]
        v7.metrics = ["MAE: 14.2 â†’ 12.5 (â†“12%)"]
        v7.fixed = ["HUBROOMTOTAL ê²°ì¸¡ì¹˜ ì²˜ë¦¬ ì˜¤ë¥˜ ìˆ˜ì •"]
        v7.breaking = ["V6 ëª¨ë¸ íŒŒì¼ê³¼ í˜¸í™˜ë˜ì§€ ì•ŠìŒ"]
        v7.next = ["ë²”ì£¼í˜• ë¶„ë¥˜ ëª¨ë¸ ì¶”ê°€"]
        self.notes["V7.0.0"] = v7
        
        # V6
        v6 = PatchNote("V6.0.0", "2025-10-20", "Major")
        v6.new = ["ë©€í‹°ì•„ì›ƒí’‹ êµ¬ì¡° ë„ì… (MIN/MAX/AVG)", "10ë¶„ êµ¬ê°„ í†µê³„ ì˜ˆì¸¡"]
        v6.improved = ["Feature ìˆ˜: 120ê°œ â†’ 165ê°œ", "ì‹œí€€ìŠ¤ ê¸¸ì´: 20ë¶„ â†’ 30ë¶„"]
        v6.metrics = ["MAE: 18.5 â†’ 14.2 (â†“23%)"]
        v6.fixed = ["í° ë³€í™” ì˜ˆì¸¡ ëˆ„ë½ ë¬¸ì œ í•´ê²°"]
        v6.breaking = ["ë‹¨ì¼ ì¶œë ¥ â†’ ë©€í‹° ì¶œë ¥ êµ¬ì¡° ë³€ê²½"]
        self.notes["V6.0.0"] = v6
    
    def refresh_version_list(self):
        """ë²„ì „ ëª©ë¡ ê°±ì‹ """
        self.version_listbox.delete(0, tk.END)
        for version in sorted(self.notes.keys(), reverse=True):
            self.version_listbox.insert(tk.END, version)
        
        if self.notes:
            self.version_listbox.selection_set(0)
            self.on_version_select(None)
    
    def on_version_select(self, event):
        """ë²„ì „ ì„ íƒ ì‹œ"""
        selection = self.version_listbox.curselection()
        if not selection:
            return
        
        version = self.version_listbox.get(selection[0])
        self.current_version = version
        self.load_note_to_ui(self.notes[version])
    
    def load_note_to_ui(self, note: PatchNote):
        """íŒ¨ì¹˜ë…¸íŠ¸ë¥¼ UIì— ë¡œë“œ"""
        # ê¸°ë³¸ ì •ë³´
        self.entry_version.delete(0, tk.END)
        self.entry_version.insert(0, note.version)
        
        self.entry_date.delete(0, tk.END)
        self.entry_date.insert(0, note.date)
        
        self.combo_type.set(note.type)
        
        self.text_breaking.delete('1.0', tk.END)
        self.text_breaking.insert('1.0', '\n'.join(note.breaking))
        
        self.text_next.delete('1.0', tk.END)
        self.text_next.insert('1.0', '\n'.join(note.next))
        
        # ë³€ê²½ì‚¬í•­
        self.text_new.delete('1.0', tk.END)
        self.text_new.insert('1.0', '\n'.join(note.new))
        
        self.text_improved.delete('1.0', tk.END)
        self.text_improved.insert('1.0', '\n'.join(note.improved))
        
        self.text_fixed.delete('1.0', tk.END)
        self.text_fixed.insert('1.0', '\n'.join(note.fixed))
        
        # ì„±ëŠ¥/íŒŒì¼
        self.text_metrics.delete('1.0', tk.END)
        self.text_metrics.insert('1.0', '\n'.join(note.metrics))
        
        self.text_files.delete('1.0', tk.END)
        self.text_files.insert('1.0', '\n'.join(note.files))
        
        # ë¯¸ë¦¬ë³´ê¸°
        self.refresh_preview()
    
    def save_ui_to_note(self) -> Optional[PatchNote]:
        """UIì—ì„œ íŒ¨ì¹˜ë…¸íŠ¸ë¡œ ì €ì¥"""
        version = self.entry_version.get().strip()
        if not version:
            messagebox.showerror("ì˜¤ë¥˜", "ë²„ì „ì„ ì…ë ¥í•˜ì„¸ìš”")
            return None
        
        note = PatchNote(
            version,
            self.entry_date.get().strip() or datetime.now().strftime("%Y-%m-%d"),
            self.combo_type.get()
        )
        
        note.new = [x.strip() for x in self.text_new.get('1.0', tk.END).strip().split('\n') if x.strip()]
        note.improved = [x.strip() for x in self.text_improved.get('1.0', tk.END).strip().split('\n') if x.strip()]
        note.fixed = [x.strip() for x in self.text_fixed.get('1.0', tk.END).strip().split('\n') if x.strip()]
        note.breaking = [x.strip() for x in self.text_breaking.get('1.0', tk.END).strip().split('\n') if x.strip()]
        note.next = [x.strip() for x in self.text_next.get('1.0', tk.END).strip().split('\n') if x.strip()]
        note.files = [x.strip() for x in self.text_files.get('1.0', tk.END).strip().split('\n') if x.strip()]
        note.metrics = [x.strip() for x in self.text_metrics.get('1.0', tk.END).strip().split('\n') if x.strip()]
        
        return note
    
    def refresh_preview(self):
        """ë¯¸ë¦¬ë³´ê¸° ê°±ì‹ """
        note = self.save_ui_to_note()
        if not note:
            return
        
        preview = self._generate_preview(note)
        self.text_preview.delete('1.0', tk.END)
        self.text_preview.insert('1.0', preview)
    
    def _generate_preview(self, note: PatchNote) -> str:
        """ë¯¸ë¦¬ë³´ê¸° í…ìŠ¤íŠ¸ ìƒì„±"""
        lines = []
        w = 58
        
        lines.append("â”Œ" + "â”€" * w + "â”")
        lines.append(f"â”‚  AMHS ì˜ˆì¸¡ ëª¨ë¸ {note.version}".ljust(w) + " â”‚")
        lines.append(f"â”‚  {note.date} | {note.type} Update".ljust(w) + " â”‚")
        lines.append("â”œ" + "â”€" * w + "â”¤")
        
        if note.new:
            lines.append(f"â”‚  [NEW] ì‹ ê·œ ê¸°ëŠ¥".ljust(w) + " â”‚")
            for item in note.new:
                line = f"â”‚    â€¢ {item}"
                lines.append(line[:w].ljust(w) + " â”‚")
        
        if note.improved:
            lines.append(f"â”‚  [IMPROVED] ê°œì„ ì‚¬í•­".ljust(w) + " â”‚")
            for item in note.improved:
                line = f"â”‚    â€¢ {item}"
                lines.append(line[:w].ljust(w) + " â”‚")
        
        if note.metrics:
            lines.append(f"â”‚  [METRICS] ì„±ëŠ¥ ë³€í™”".ljust(w) + " â”‚")
            for item in note.metrics:
                line = f"â”‚    â€¢ {item}"
                lines.append(line[:w].ljust(w) + " â”‚")
        
        lines.append(f"â”‚  [FIXED] ë²„ê·¸ ìˆ˜ì •".ljust(w) + " â”‚")
        if note.fixed:
            for item in note.fixed:
                line = f"â”‚    â€¢ {item}"
                lines.append(line[:w].ljust(w) + " â”‚")
        else:
            lines.append(f"â”‚    â€¢ ì—†ìŒ".ljust(w) + " â”‚")
        
        if note.breaking:
            lines.append(f"â”‚  [BREAKING] í˜¸í™˜ì„±".ljust(w) + " â”‚")
            for item in note.breaking:
                line = f"â”‚    â€¢ {item}"
                lines.append(line[:w].ljust(w) + " â”‚")
        
        if note.files:
            lines.append(f"â”‚  [FILES] ë³€ê²½ íŒŒì¼".ljust(w) + " â”‚")
            for item in note.files:
                line = f"â”‚    â€¢ {item}"
                lines.append(line[:w].ljust(w) + " â”‚")
        
        if note.next:
            lines.append(f"â”‚  [NEXT] ë‹¤ìŒ ë²„ì „ ì˜ˆê³ ".ljust(w) + " â”‚")
            for item in note.next:
                line = f"â”‚    â€¢ {item}"
                lines.append(line[:w].ljust(w) + " â”‚")
        
        lines.append("â””" + "â”€" * w + "â”˜")
        
        return '\n'.join(lines)
    
    def save_notes(self):
        """ì €ì¥"""
        # í˜„ì¬ í¸ì§‘ ì¤‘ì¸ ë…¸íŠ¸ ì €ì¥
        if self.current_version:
            note = self.save_ui_to_note()
            if note:
                # ë²„ì „ì´ ë³€ê²½ëœ ê²½ìš°
                if note.version != self.current_version:
                    del self.notes[self.current_version]
                self.notes[note.version] = note
                self.current_version = note.version
        
        # íŒŒì¼ë¡œ ì €ì¥
        data = {
            "project": "AMHS ì˜ˆì¸¡ ëª¨ë¸",
            "updated": datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
            "notes": {v: n.to_dict() for v, n in self.notes.items()}
        }
        
        with open(self.save_file, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=2)
        
        self.refresh_version_list()
        messagebox.showinfo("ì €ì¥", f"ì €ì¥ ì™„ë£Œ: {self.save_file}")
    
    def load_notes(self):
        """ë¡œë“œ"""
        filename = filedialog.askopenfilename(
            filetypes=[("JSON files", "*.json"), ("All files", "*.*")]
        )
        if filename:
            self._load_from_file(filename)
            self.refresh_version_list()
            messagebox.showinfo("ë¡œë“œ", f"ë¡œë“œ ì™„ë£Œ: {filename}")
    
    def _load_from_file(self, filename):
        """íŒŒì¼ì—ì„œ ë¡œë“œ"""
        with open(filename, 'r', encoding='utf-8') as f:
            data = json.load(f)
        
        self.notes = {}
        for version, note_data in data.get("notes", {}).items():
            self.notes[version] = PatchNote.from_dict(note_data)
    
    def export_md(self):
        """ë§ˆí¬ë‹¤ìš´ ë‚´ë³´ë‚´ê¸°"""
        filename = filedialog.asksaveasfilename(
            defaultextension=".md",
            filetypes=[("Markdown files", "*.md"), ("All files", "*.*")],
            initialfile="PATCH_NOTES.md"
        )
        if not filename:
            return
        
        lines = []
        lines.append("# AMHS ì˜ˆì¸¡ ëª¨ë¸ íŒ¨ì¹˜ë…¸íŠ¸\n")
        lines.append(f"*ìµœì¢… ì—…ë°ì´íŠ¸: {datetime.now().strftime('%Y-%m-%d')}*\n")
        
        for version in sorted(self.notes.keys(), reverse=True):
            note = self.notes[version]
            lines.append(f"\n---\n")
            lines.append(f"## {note.version} ({note.date})\n")
            lines.append(f"**{note.type} Update**\n")
            
            if note.new:
                lines.append("\n### âœ¨ ì‹ ê·œ ê¸°ëŠ¥\n")
                for item in note.new:
                    lines.append(f"- {item}\n")
            
            if note.improved:
                lines.append("\n### â¬†ï¸ ê°œì„ ì‚¬í•­\n")
                for item in note.improved:
                    lines.append(f"- {item}\n")
            
            if note.metrics:
                lines.append("\n### ğŸ“Š ì„±ëŠ¥ ë³€í™”\n")
                for item in note.metrics:
                    lines.append(f"- {item}\n")
            
            if note.fixed:
                lines.append("\n### ğŸ”§ ë²„ê·¸ ìˆ˜ì •\n")
                for item in note.fixed:
                    lines.append(f"- {item}\n")
            
            if note.breaking:
                lines.append("\n### âš ï¸ Breaking Changes\n")
                for item in note.breaking:
                    lines.append(f"- {item}\n")
            
            if note.files:
                lines.append("\n### ğŸ“ ë³€ê²½ íŒŒì¼\n")
                for item in note.files:
                    lines.append(f"- `{item}`\n")
            
            if note.next:
                lines.append("\n### ğŸ”® ë‹¤ìŒ ë²„ì „ ì˜ˆê³ \n")
                for item in note.next:
                    lines.append(f"- {item}\n")
        
        with open(filename, 'w', encoding='utf-8') as f:
            f.writelines(lines)
        
        messagebox.showinfo("ë‚´ë³´ë‚´ê¸°", f"MD ì €ì¥ ì™„ë£Œ: {filename}")
    
    def new_version_dialog(self):
        """ìƒˆ ë²„ì „ ë‹¤ì´ì–¼ë¡œê·¸"""
        dialog = tk.Toplevel(self.root)
        dialog.title("ìƒˆ íŒ¨ì¹˜ë…¸íŠ¸")
        dialog.geometry("300x150")
        dialog.configure(bg=self.colors['bg'])
        dialog.transient(self.root)
        dialog.grab_set()
        
        ttk.Label(dialog, text="ìƒˆ ë²„ì „:").pack(pady=10)
        entry = ttk.Entry(dialog, font=('ë§‘ì€ ê³ ë”•', 12), width=20)
        entry.pack(pady=5)
        entry.insert(0, "V9.0.0")
        entry.focus()
        
        def create():
            version = entry.get().strip()
            if version:
                if version in self.notes:
                    messagebox.showerror("ì˜¤ë¥˜", "ì´ë¯¸ ì¡´ì¬í•˜ëŠ” ë²„ì „ì…ë‹ˆë‹¤")
                    return
                self.notes[version] = PatchNote(version)
                self.refresh_version_list()
                # ìƒˆ ë²„ì „ ì„ íƒ
                idx = list(sorted(self.notes.keys(), reverse=True)).index(version)
                self.version_listbox.selection_clear(0, tk.END)
                self.version_listbox.selection_set(idx)
                self.on_version_select(None)
                dialog.destroy()
        
        ttk.Button(dialog, text="ìƒì„±", command=create).pack(pady=15)
    
    def delete_version(self):
        """ë²„ì „ ì‚­ì œ"""
        if not self.current_version:
            return
        
        if messagebox.askyesno("ì‚­ì œ í™•ì¸", f"{self.current_version}ì„(ë¥¼) ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?"):
            del self.notes[self.current_version]
            self.current_version = None
            self.refresh_version_list()


def main():
    root = tk.Tk()
    app = PatchNoteApp(root)
    root.mainloop()


if __name__ == "__main__":
    main()