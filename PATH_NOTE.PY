"""
================================================================================
AMHS ì˜ˆì¸¡ ëª¨ë¸ íŒ¨ì¹˜ë…¸íŠ¸ ê´€ë¦¬ í”„ë¡œê·¸ë¨ (GUI)
================================================================================
ê¸°ëŠ¥:
  - íŒ¨ì¹˜ë…¸íŠ¸ ì‘ì„±/ìˆ˜ì •/ì‚­ì œ
  - JSON íŒŒì¼ë¡œ ì €ì¥/ë¡œë“œ
  - íƒ­ìœ¼ë¡œ ë²„ì „ë³„ ë¶„ë¦¬
  - MD ë‚´ë³´ë‚´ê¸°
================================================================================
"""

import tkinter as tk
from tkinter import ttk, messagebox, filedialog, scrolledtext
import json
import csv
import os
from datetime import datetime
from typing import List, Dict, Optional


class PatchNote:
    """íŒ¨ì¹˜ë…¸íŠ¸ ë°ì´í„° í´ë˜ìŠ¤"""
    
    def __init__(self, version: str, date: str = None, note_type: str = "Major"):
        self.version = version
        self.date = date or datetime.now().strftime("%Y-%m-%d")
        self.type = note_type
        self.new: List[str] = []
        self.improved: List[str] = []
        self.fixed: List[str] = []
        self.breaking: List[str] = []
        self.metrics: List[str] = []
        self.files: List[str] = []
        self.next: List[str] = []
        self.important: List[str] = []
    
    def to_dict(self) -> dict:
        return {
            "version": self.version,
            "date": self.date,
            "type": self.type,
            "new": self.new,
            "improved": self.improved,
            "fixed": self.fixed,
            "breaking": self.breaking,
            "metrics": self.metrics,
            "files": self.files,
            "next": self.next,
            "important": self.important,
        }
    
    @classmethod
    def from_dict(cls, data: dict) -> 'PatchNote':
        note = cls(data["version"], data["date"], data.get("type", "Major"))
        note.new = data.get("new", [])
        note.fixed = data.get("fixed", [])
        note.breaking = data.get("breaking", [])
        note.files = data.get("files", [])
        note.next = data.get("next", [])
        note.important = data.get("important", [])
        
        # improved í˜¸í™˜ì„± ì²˜ë¦¬
        improved_data = data.get("improved", [])
        if improved_data and isinstance(improved_data[0], dict):
            note.improved = [f"{item.get('item', '')}: {item.get('before', '')} â†’ {item.get('after', '')}" for item in improved_data]
        else:
            note.improved = improved_data
        
        # metrics í˜¸í™˜ì„± ì²˜ë¦¬
        metrics_data = data.get("metrics", [])
        if isinstance(metrics_data, dict):
            note.metrics = []
            for name, info in metrics_data.items():
                if isinstance(info, dict):
                    note.metrics.append(f"{name}: {info.get('before', '-')} â†’ {info.get('after', '-')} ({info.get('change', '')})")
                else:
                    note.metrics.append(f"{name}: {info}")
        else:
            note.metrics = metrics_data
        
        return note


class VersionManagement:
    """ë²„ì „ ê´€ë¦¬ ë°ì´í„° í´ë˜ìŠ¤ (CSVìš©)"""
    
    def __init__(self):
        self.date: str = ""
        self.operation: str = ""
        self.development: str = ""
        self.fab: str = ""
        self.model_name: str = ""
        self.version: str = ""
        self.total_predict: str = ""
        self.early_detect: str = ""
        self.model_desc: str = ""
    
    def to_row(self) -> List[str]:
        return [
            self.date, self.operation, self.development, self.fab,
            self.model_name, self.version, self.total_predict,
            self.early_detect, self.model_desc
        ]
    
    @classmethod
    def from_row(cls, row: List[str]) -> 'VersionManagement':
        vm = cls()
        if len(row) >= 9:
            vm.date = row[0]
            vm.operation = row[1]
            vm.development = row[2]
            vm.fab = row[3]
            vm.model_name = row[4]
            vm.version = row[5]
            vm.total_predict = row[6]
            vm.early_detect = row[7]
            vm.model_desc = row[8]
        return vm
    
    @staticmethod
    def csv_header() -> List[str]:
        return ["ë‚ ì§œ", "ìš´ì˜", "ê°œë°œ", "FAB", "ì˜ˆì¸¡ëª¨ë¸_NAME", "ë²„ì „", "ì „ì²´ì˜ˆì¸¡", "ì‚¬ì „ê°ì§€ì˜ˆì¸¡", "ëª¨ë¸ë‚´ìš©"]


class PatchNoteApp:
    """íŒ¨ì¹˜ë…¸íŠ¸ GUI ì• í”Œë¦¬ì¼€ì´ì…˜"""
    
    def __init__(self, root):
        self.root = root
        self.root.title("AMHS ì˜ˆì¸¡ ëª¨ë¸ íŒ¨ì¹˜ë…¸íŠ¸ ê´€ë¦¬")
        self.root.geometry("900x700")
        self.root.configure(bg="#2b2b2b")
        
        self.notes: Dict[str, PatchNote] = {}
        self.current_version: Optional[str] = None
        self.save_file = "patch_notes.json"
        
        # ìŠ¤íƒ€ì¼ ì„¤ì •
        self.setup_styles()
        
        # UI êµ¬ì„±
        self.create_widgets()
        
        # ìƒ˜í”Œ ë°ì´í„° ë¡œë“œ
        self.load_or_create_sample()
    
    def setup_styles(self):
        """ìŠ¤íƒ€ì¼ ì„¤ì •"""
        style = ttk.Style()
        style.theme_use('clam')
        
        # ë‹¤í¬ í…Œë§ˆ ìƒ‰ìƒ
        self.colors = {
            'bg': '#2b2b2b',
            'fg': '#ffffff',
            'accent': '#4a9eff',
            'accent2': '#ff6b6b',
            'card': '#3c3c3c',
            'input': '#404040',
            'border': '#555555',
        }
        
        style.configure('TFrame', background=self.colors['bg'])
        style.configure('Card.TFrame', background=self.colors['card'])
        style.configure('TLabel', background=self.colors['bg'], foreground=self.colors['fg'], font=('ë§‘ì€ ê³ ë”•', 10))
        style.configure('Title.TLabel', font=('ë§‘ì€ ê³ ë”•', 14, 'bold'))
        style.configure('Header.TLabel', font=('ë§‘ì€ ê³ ë”•', 12, 'bold'))
        style.configure('TButton', font=('ë§‘ì€ ê³ ë”•', 10))
        style.configure('Accent.TButton', font=('ë§‘ì€ ê³ ë”•', 10, 'bold'))
        style.configure('TNotebook', background=self.colors['bg'])
        style.configure('TNotebook.Tab', font=('ë§‘ì€ ê³ ë”•', 10), padding=[10, 5])
    
    def create_widgets(self):
        """ìœ„ì ¯ ìƒì„±"""
        
        # ===== ìƒë‹¨ í—¤ë” =====
        header_frame = ttk.Frame(self.root)
        header_frame.pack(fill=tk.X, padx=10, pady=10)
        
        ttk.Label(header_frame, text="ğŸ“‹ AMHS ì˜ˆì¸¡ ëª¨ë¸ íŒ¨ì¹˜ë…¸íŠ¸", style='Title.TLabel').pack(side=tk.LEFT)
        
        # ë²„íŠ¼ë“¤
        btn_frame = ttk.Frame(header_frame)
        btn_frame.pack(side=tk.RIGHT)
        
        ttk.Button(btn_frame, text="ğŸ’¾ ì €ì¥", command=self.save_notes).pack(side=tk.LEFT, padx=2)
        ttk.Button(btn_frame, text="ğŸ“‚ ë¡œë“œ", command=self.load_notes).pack(side=tk.LEFT, padx=2)
        ttk.Button(btn_frame, text="ğŸ“„ MD ë‚´ë³´ë‚´ê¸°", command=self.export_md).pack(side=tk.LEFT, padx=2)
        ttk.Button(btn_frame, text="â• ìƒˆ ë²„ì „", command=self.new_version_dialog).pack(side=tk.LEFT, padx=2)
        
        # ===== ë©”ì¸ ì˜ì—­ =====
        main_frame = ttk.Frame(self.root)
        main_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=5)
        
        # ì¢Œì¸¡: ë²„ì „ ëª©ë¡
        left_frame = ttk.Frame(main_frame, width=150)
        left_frame.pack(side=tk.LEFT, fill=tk.Y, padx=(0, 10))
        left_frame.pack_propagate(False)
        
        ttk.Label(left_frame, text="ğŸ“¦ ë²„ì „ ëª©ë¡", style='Header.TLabel').pack(pady=5)
        
        self.version_listbox = tk.Listbox(
            left_frame, 
            font=('ë§‘ì€ ê³ ë”•', 11),
            bg=self.colors['card'],
            fg=self.colors['fg'],
            selectbackground=self.colors['accent'],
            selectforeground='white',
            borderwidth=0,
            highlightthickness=1,
            highlightcolor=self.colors['border']
        )
        self.version_listbox.pack(fill=tk.BOTH, expand=True, pady=5)
        self.version_listbox.bind('<<ListboxSelect>>', self.on_version_select)
        
        ttk.Button(left_frame, text="ğŸ—‘ï¸ ì‚­ì œ", command=self.delete_version).pack(fill=tk.X, pady=5)
        
        # ìš°ì¸¡: íŒ¨ì¹˜ë…¸íŠ¸ ìƒì„¸
        right_frame = ttk.Frame(main_frame)
        right_frame.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        
        # íƒ­ ë…¸íŠ¸ë¶
        self.notebook = ttk.Notebook(right_frame)
        self.notebook.pack(fill=tk.BOTH, expand=True)
        
        # íƒ­ 1: ê¸°ë³¸ ì •ë³´
        self.tab_info = ttk.Frame(self.notebook)
        self.notebook.add(self.tab_info, text="ğŸ“ ê¸°ë³¸ ì •ë³´")
        self.create_info_tab()
        
        # íƒ­ 2: ì‹ ê·œ/ê°œì„ 
        self.tab_changes = ttk.Frame(self.notebook)
        self.notebook.add(self.tab_changes, text="âœ¨ ë³€ê²½ì‚¬í•­")
        self.create_changes_tab()
        
        # íƒ­ 3: ì„±ëŠ¥/íŒŒì¼
        self.tab_metrics = ttk.Frame(self.notebook)
        self.notebook.add(self.tab_metrics, text="ğŸ“Š ì„±ëŠ¥/íŒŒì¼")
        self.create_metrics_tab()
        
        # íƒ­ 4: ë²„ì „ ê´€ë¦¬
        self.tab_version = ttk.Frame(self.notebook)
        self.notebook.add(self.tab_version, text="ğŸ”– ë²„ì „ ê´€ë¦¬")
        self.create_version_tab()
        
        # íƒ­ 5: ë¯¸ë¦¬ë³´ê¸°
        self.tab_preview = ttk.Frame(self.notebook)
        self.notebook.add(self.tab_preview, text="ğŸ‘ï¸ ë¯¸ë¦¬ë³´ê¸°")
        self.create_preview_tab()
    
    def create_info_tab(self):
        """ê¸°ë³¸ ì •ë³´ íƒ­"""
        frame = ttk.Frame(self.tab_info, padding=20)
        frame.pack(fill=tk.BOTH, expand=True)
        
        # ë²„ì „
        ttk.Label(frame, text="ë²„ì „:").grid(row=0, column=0, sticky='w', pady=5)
        self.entry_version = ttk.Entry(frame, font=('ë§‘ì€ ê³ ë”•', 11), width=20)
        self.entry_version.grid(row=0, column=1, sticky='w', pady=5, padx=5)
        
        # ë‚ ì§œ
        ttk.Label(frame, text="ë‚ ì§œ:").grid(row=1, column=0, sticky='w', pady=5)
        self.entry_date = ttk.Entry(frame, font=('ë§‘ì€ ê³ ë”•', 11), width=20)
        self.entry_date.grid(row=1, column=1, sticky='w', pady=5, padx=5)
        
        # ìœ í˜•
        ttk.Label(frame, text="ìœ í˜•:").grid(row=2, column=0, sticky='w', pady=5)
        self.combo_type = ttk.Combobox(frame, values=["Major", "Minor", "Patch"], font=('ë§‘ì€ ê³ ë”•', 11), width=17)
        self.combo_type.grid(row=2, column=1, sticky='w', pady=5, padx=5)
        self.combo_type.set("Major")
        
        # ì¤‘ìš” ì •ë³´
        ttk.Label(frame, text="âš ï¸ ì¤‘ìš” ì •ë³´:").grid(row=3, column=0, sticky='nw', pady=5)
        self.text_important = scrolledtext.ScrolledText(frame, height=4, width=50, font=('ë§‘ì€ ê³ ë”•', 10),
                                                        bg=self.colors['input'], fg=self.colors['fg'])
        self.text_important.grid(row=3, column=1, sticky='w', pady=5, padx=5)
        
        # Breaking Changes
        ttk.Label(frame, text="Breaking Changes:").grid(row=4, column=0, sticky='nw', pady=5)
        self.text_breaking = scrolledtext.ScrolledText(frame, height=4, width=50, font=('ë§‘ì€ ê³ ë”•', 10),
                                                        bg=self.colors['input'], fg=self.colors['fg'])
        self.text_breaking.grid(row=4, column=1, sticky='w', pady=5, padx=5)
        
        # ë‹¤ìŒ ë²„ì „ ì˜ˆê³ 
        ttk.Label(frame, text="ë‹¤ìŒ ë²„ì „ ì˜ˆê³ :").grid(row=5, column=0, sticky='nw', pady=5)
        self.text_next = scrolledtext.ScrolledText(frame, height=4, width=50, font=('ë§‘ì€ ê³ ë”•', 10),
                                                    bg=self.colors['input'], fg=self.colors['fg'])
        self.text_next.grid(row=5, column=1, sticky='w', pady=5, padx=5)
    
    def create_changes_tab(self):
        """ë³€ê²½ì‚¬í•­ íƒ­"""
        frame = ttk.Frame(self.tab_changes, padding=20)
        frame.pack(fill=tk.BOTH, expand=True)
        
        # ì‹ ê·œ ê¸°ëŠ¥
        ttk.Label(frame, text="âœ¨ ì‹ ê·œ ê¸°ëŠ¥ (ì¤„ë°”ê¿ˆìœ¼ë¡œ êµ¬ë¶„):", style='Header.TLabel').pack(anchor='w')
        self.text_new = scrolledtext.ScrolledText(frame, height=6, font=('ë§‘ì€ ê³ ë”•', 10),
                                                   bg=self.colors['input'], fg=self.colors['fg'])
        self.text_new.pack(fill=tk.X, pady=(5, 15))
        
        # ê°œì„ ì‚¬í•­
        ttk.Label(frame, text="â¬†ï¸ ê°œì„ ì‚¬í•­ (ì¤„ë°”ê¿ˆìœ¼ë¡œ êµ¬ë¶„):", style='Header.TLabel').pack(anchor='w')
        self.text_improved = scrolledtext.ScrolledText(frame, height=6, font=('ë§‘ì€ ê³ ë”•', 10),
                                                        bg=self.colors['input'], fg=self.colors['fg'])
        self.text_improved.pack(fill=tk.X, pady=(5, 15))
        
        # ë²„ê·¸ ìˆ˜ì •
        ttk.Label(frame, text="ğŸ”§ ë²„ê·¸ ìˆ˜ì • (ì¤„ë°”ê¿ˆìœ¼ë¡œ êµ¬ë¶„):", style='Header.TLabel').pack(anchor='w')
        self.text_fixed = scrolledtext.ScrolledText(frame, height=6, font=('ë§‘ì€ ê³ ë”•', 10),
                                                     bg=self.colors['input'], fg=self.colors['fg'])
        self.text_fixed.pack(fill=tk.X, pady=(5, 15))
    
    def create_metrics_tab(self):
        """ì„±ëŠ¥/íŒŒì¼ íƒ­"""
        frame = ttk.Frame(self.tab_metrics, padding=20)
        frame.pack(fill=tk.BOTH, expand=True)
        
        # ì„±ëŠ¥ ì§€í‘œ
        ttk.Label(frame, text="ğŸ“Š ì„±ëŠ¥ ë³€í™” (ì¤„ë°”ê¿ˆìœ¼ë¡œ êµ¬ë¶„):", style='Header.TLabel').pack(anchor='w')
        self.text_metrics = scrolledtext.ScrolledText(frame, height=6, font=('ë§‘ì€ ê³ ë”•', 10),
                                                       bg=self.colors['input'], fg=self.colors['fg'])
        self.text_metrics.pack(fill=tk.X, pady=(5, 15))
        
        # ë³€ê²½ íŒŒì¼
        ttk.Label(frame, text="ğŸ“ ë³€ê²½ íŒŒì¼ (ì¤„ë°”ê¿ˆìœ¼ë¡œ êµ¬ë¶„):", style='Header.TLabel').pack(anchor='w')
        self.text_files = scrolledtext.ScrolledText(frame, height=8, font=('ë§‘ì€ ê³ ë”•', 10),
                                                     bg=self.colors['input'], fg=self.colors['fg'])
        self.text_files.pack(fill=tk.X, pady=(5, 15))
    
    def create_version_tab(self):
        """ë²„ì „ ê´€ë¦¬ íƒ­ (CSV ì €ì¥ìš©, ë³„ë„ ê´€ë¦¬)"""
        frame = ttk.Frame(self.tab_version, padding=20)
        frame.pack(fill=tk.BOTH, expand=True)
        
        # ì•ˆë‚´ ë¬¸êµ¬
        ttk.Label(frame, text="ğŸ“‹ ë²„ì „ ê´€ë¦¬ (CSVë¡œ ë³„ë„ ì €ì¥)", 
                  font=('ë§‘ì€ ê³ ë”•', 12, 'bold')).pack(anchor='w', pady=(0, 10))
        
        # ì…ë ¥ ì˜ì—­
        input_frame = ttk.LabelFrame(frame, text="ìƒˆ í•­ëª© ì…ë ¥", padding=10)
        input_frame.pack(fill=tk.X, pady=(0, 15))
        
        # ìƒë‹¨ ê·¸ë¦¬ë“œ (ë‚ ì§œ, ìš´ì˜, ê°œë°œ, FAB)
        row1 = ttk.Frame(input_frame)
        row1.pack(fill=tk.X, pady=5)
        
        ttk.Label(row1, text="ğŸ“… ë‚ ì§œ:").pack(side=tk.LEFT)
        self.entry_vm_date = ttk.Entry(row1, font=('ë§‘ì€ ê³ ë”•', 10), width=12)
        self.entry_vm_date.pack(side=tk.LEFT, padx=(5, 15))
        self.entry_vm_date.insert(0, datetime.now().strftime("%Y-%m-%d"))
        
        ttk.Label(row1, text="ğŸ­ ìš´ì˜:").pack(side=tk.LEFT)
        self.entry_vm_operation = ttk.Entry(row1, font=('ë§‘ì€ ê³ ë”•', 10), width=10)
        self.entry_vm_operation.pack(side=tk.LEFT, padx=(5, 15))
        
        ttk.Label(row1, text="ğŸ’» ê°œë°œ:").pack(side=tk.LEFT)
        self.entry_vm_development = ttk.Entry(row1, font=('ë§‘ì€ ê³ ë”•', 10), width=10)
        self.entry_vm_development.pack(side=tk.LEFT, padx=(5, 15))
        
        ttk.Label(row1, text="ğŸ¢ FAB:").pack(side=tk.LEFT)
        self.entry_vm_fab = ttk.Entry(row1, font=('ë§‘ì€ ê³ ë”•', 10), width=10)
        self.entry_vm_fab.pack(side=tk.LEFT, padx=(5, 0))
        
        # ì¤‘ê°„ ê·¸ë¦¬ë“œ (ì˜ˆì¸¡ëª¨ë¸_NAME, ë²„ì „)
        row2 = ttk.Frame(input_frame)
        row2.pack(fill=tk.X, pady=5)
        
        ttk.Label(row2, text="ğŸ¤– ì˜ˆì¸¡ëª¨ë¸_NAME:").pack(side=tk.LEFT)
        self.entry_vm_model_name = ttk.Entry(row2, font=('ë§‘ì€ ê³ ë”•', 10), width=25)
        self.entry_vm_model_name.pack(side=tk.LEFT, padx=(5, 15))
        
        ttk.Label(row2, text="ğŸ”– ë²„ì „:").pack(side=tk.LEFT)
        self.entry_vm_version = ttk.Entry(row2, font=('ë§‘ì€ ê³ ë”•', 10), width=12)
        self.entry_vm_version.pack(side=tk.LEFT, padx=(5, 0))
        
        # í•˜ë‹¨ ê·¸ë¦¬ë“œ (ì „ì²´ì˜ˆì¸¡, ì‚¬ì „ê°ì§€ì˜ˆì¸¡)
        row3 = ttk.Frame(input_frame)
        row3.pack(fill=tk.X, pady=5)
        
        ttk.Label(row3, text="ğŸ“Š ì „ì²´ì˜ˆì¸¡:").pack(side=tk.LEFT)
        self.entry_vm_total_predict = ttk.Entry(row3, font=('ë§‘ì€ ê³ ë”•', 10), width=20)
        self.entry_vm_total_predict.pack(side=tk.LEFT, padx=(5, 15))
        
        ttk.Label(row3, text="ğŸ” ì‚¬ì „ê°ì§€ì˜ˆì¸¡:").pack(side=tk.LEFT)
        self.entry_vm_early_detect = ttk.Entry(row3, font=('ë§‘ì€ ê³ ë”•', 10), width=20)
        self.entry_vm_early_detect.pack(side=tk.LEFT, padx=(5, 0))
        
        # ëª¨ë¸ ë‚´ìš©
        row4 = ttk.Frame(input_frame)
        row4.pack(fill=tk.X, pady=5)
        
        ttk.Label(row4, text="ğŸ“ ëª¨ë¸ë‚´ìš©:").pack(side=tk.LEFT)
        self.entry_vm_model_desc = ttk.Entry(row4, font=('ë§‘ì€ ê³ ë”•', 10), width=60)
        self.entry_vm_model_desc.pack(side=tk.LEFT, padx=(5, 0), fill=tk.X, expand=True)
        
        # ë²„íŠ¼ ì˜ì—­ (í•­ëª© ì¶”ê°€/ìˆ˜ì •/ì‚­ì œ)
        btn_frame = ttk.Frame(input_frame)
        btn_frame.pack(fill=tk.X, pady=(10, 0))
        
        ttk.Button(btn_frame, text="â• í•­ëª© ì¶”ê°€", command=self.add_vm_row).pack(side=tk.LEFT, padx=5)
        ttk.Button(btn_frame, text="âœï¸ ì„ íƒ ìˆ˜ì •", command=self.update_vm_row).pack(side=tk.LEFT, padx=5)
        ttk.Button(btn_frame, text="ğŸ—‘ï¸ ì„ íƒ ì‚­ì œ", command=self.delete_vm_row).pack(side=tk.LEFT, padx=5)
        ttk.Button(btn_frame, text="ğŸ§¹ ì…ë ¥ ì´ˆê¸°í™”", command=self.clear_vm_inputs).pack(side=tk.LEFT, padx=5)
        
        # í…Œì´ë¸” (Treeview)
        table_frame = ttk.Frame(frame)
        table_frame.pack(fill=tk.BOTH, expand=True, pady=(0, 15))
        
        columns = ("ë‚ ì§œ", "ìš´ì˜", "ê°œë°œ", "FAB", "ì˜ˆì¸¡ëª¨ë¸_NAME", "ë²„ì „", "ì „ì²´ì˜ˆì¸¡", "ì‚¬ì „ê°ì§€ì˜ˆì¸¡", "ëª¨ë¸ë‚´ìš©")
        self.vm_tree = ttk.Treeview(table_frame, columns=columns, show='headings', height=8)
        
        # ì»¬ëŸ¼ ì„¤ì •
        col_widths = [90, 60, 60, 50, 150, 80, 120, 120, 200]
        for col, width in zip(columns, col_widths):
            self.vm_tree.heading(col, text=col)
            self.vm_tree.column(col, width=width, minwidth=50)
        
        # ìŠ¤í¬ë¡¤ë°”
        scrollbar_y = ttk.Scrollbar(table_frame, orient=tk.VERTICAL, command=self.vm_tree.yview)
        scrollbar_x = ttk.Scrollbar(table_frame, orient=tk.HORIZONTAL, command=self.vm_tree.xview)
        self.vm_tree.configure(yscrollcommand=scrollbar_y.set, xscrollcommand=scrollbar_x.set)
        
        self.vm_tree.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        scrollbar_y.pack(side=tk.RIGHT, fill=tk.Y)
        scrollbar_x.pack(side=tk.BOTTOM, fill=tk.X)
        
        # í…Œì´ë¸” ì„ íƒ ì´ë²¤íŠ¸
        self.vm_tree.bind('<<TreeviewSelect>>', self.on_vm_select)
        
        # CSV ì €ì¥/ë¶ˆëŸ¬ì˜¤ê¸° ë²„íŠ¼
        csv_frame = ttk.Frame(frame)
        csv_frame.pack(fill=tk.X)
        
        ttk.Button(csv_frame, text="ğŸ’¾ CSV ì €ì¥", command=self.save_vm_csv).pack(side=tk.LEFT, padx=5)
        ttk.Button(csv_frame, text="ğŸ“‚ CSV ë¶ˆëŸ¬ì˜¤ê¸°", command=self.load_vm_csv).pack(side=tk.LEFT, padx=5)
        
        # ë²„ì „ ê´€ë¦¬ ë°ì´í„° ë¦¬ìŠ¤íŠ¸
        self.vm_data: List[VersionManagement] = []
        self.vm_save_file = "version_management.csv"
        
        # ê¸°ì¡´ ë°ì´í„° ë¡œë“œ ë˜ëŠ” ìƒ˜í”Œ ì¶”ê°€
        self._load_vm_data()
    
    def _load_vm_data(self):
        """ë²„ì „ ê´€ë¦¬ ë°ì´í„° ë¡œë“œ"""
        if os.path.exists(self.vm_save_file):
            try:
                with open(self.vm_save_file, 'r', encoding='utf-8-sig') as f:
                    reader = csv.reader(f)
                    next(reader)  # í—¤ë” ìŠ¤í‚µ
                    for row in reader:
                        vm = VersionManagement.from_row(row)
                        self.vm_data.append(vm)
                        self.vm_tree.insert('', tk.END, values=vm.to_row())
            except Exception as e:
                print(f"ë²„ì „ ê´€ë¦¬ ë¡œë“œ ì‹¤íŒ¨: {e}")
                self._add_sample_vm_data()
        else:
            # íŒŒì¼ ì—†ìœ¼ë©´ ìƒ˜í”Œ ë°ì´í„°
            self._add_sample_vm_data()
            self._auto_save_vm()
    
    def _auto_save_vm(self):
        """ë²„ì „ ê´€ë¦¬ ìë™ ì €ì¥"""
        try:
            with open(self.vm_save_file, 'w', newline='', encoding='utf-8-sig') as f:
                writer = csv.writer(f)
                writer.writerow(VersionManagement.csv_header())
                for vm in self.vm_data:
                    writer.writerow(vm.to_row())
        except Exception as e:
            print(f"ë²„ì „ ê´€ë¦¬ ì €ì¥ ì‹¤íŒ¨: {e}")
    
    def _add_sample_vm_data(self):
        """ìƒ˜í”Œ ë²„ì „ ê´€ë¦¬ ë°ì´í„°"""
        sample = VersionManagement()
        sample.date = "2025-12-01"
        sample.operation = "M16A"
        sample.development = "AIíŒ€"
        sample.fab = "M16"
        sample.model_name = "AMHS_JOB2_ì˜ˆì¸¡ëª¨ë¸"
        sample.version = "V8.0.0"
        sample.total_predict = "MAE 9.8, RÂ² 0.68"
        sample.early_detect = "ë²”ì£¼í˜• ì •í™•ë„ 72%"
        sample.model_desc = "ìˆ˜ì¹˜í˜•+ë²”ì£¼í˜• ì•™ìƒë¸”, 32ì»¬ëŸ¼â†’222Feature"
        
        self.vm_data.append(sample)
        self.vm_tree.insert('', tk.END, values=sample.to_row())
    
    def add_vm_row(self):
        """ë²„ì „ ê´€ë¦¬ í•­ëª© ì¶”ê°€"""
        vm = VersionManagement()
        vm.date = self.entry_vm_date.get().strip()
        vm.operation = self.entry_vm_operation.get().strip()
        vm.development = self.entry_vm_development.get().strip()
        vm.fab = self.entry_vm_fab.get().strip()
        vm.model_name = self.entry_vm_model_name.get().strip()
        vm.version = self.entry_vm_version.get().strip()
        vm.total_predict = self.entry_vm_total_predict.get().strip()
        vm.early_detect = self.entry_vm_early_detect.get().strip()
        vm.model_desc = self.entry_vm_model_desc.get().strip()
        
        if not vm.version:
            messagebox.showwarning("ê²½ê³ ", "ë²„ì „ì€ í•„ìˆ˜ ì…ë ¥ì…ë‹ˆë‹¤.")
            return
        
        self.vm_data.append(vm)
        self.vm_tree.insert('', tk.END, values=vm.to_row())
        self.clear_vm_inputs()
        self._auto_save_vm()  # ìë™ ì €ì¥
    
    def on_vm_select(self, event):
        """í…Œì´ë¸” ì„ íƒ ì‹œ ì…ë ¥ í•„ë“œì— ë°ì´í„° ë¡œë“œ"""
        selected = self.vm_tree.selection()
        if not selected:
            return
        
        item = selected[0]
        values = self.vm_tree.item(item, 'values')
        
        if len(values) >= 9:
            self.entry_vm_date.delete(0, tk.END)
            self.entry_vm_date.insert(0, values[0])
            
            self.entry_vm_operation.delete(0, tk.END)
            self.entry_vm_operation.insert(0, values[1])
            
            self.entry_vm_development.delete(0, tk.END)
            self.entry_vm_development.insert(0, values[2])
            
            self.entry_vm_fab.delete(0, tk.END)
            self.entry_vm_fab.insert(0, values[3])
            
            self.entry_vm_model_name.delete(0, tk.END)
            self.entry_vm_model_name.insert(0, values[4])
            
            self.entry_vm_version.delete(0, tk.END)
            self.entry_vm_version.insert(0, values[5])
            
            self.entry_vm_total_predict.delete(0, tk.END)
            self.entry_vm_total_predict.insert(0, values[6])
            
            self.entry_vm_early_detect.delete(0, tk.END)
            self.entry_vm_early_detect.insert(0, values[7])
            
            self.entry_vm_model_desc.delete(0, tk.END)
            self.entry_vm_model_desc.insert(0, values[8])
    
    def update_vm_row(self):
        """ì„ íƒëœ í•­ëª© ìˆ˜ì •"""
        selected = self.vm_tree.selection()
        if not selected:
            messagebox.showwarning("ê²½ê³ ", "ìˆ˜ì •í•  í•­ëª©ì„ ì„ íƒí•˜ì„¸ìš”.")
            return
        
        item = selected[0]
        idx = self.vm_tree.index(item)
        
        if idx >= len(self.vm_data):
            return
        
        # ì…ë ¥ í•„ë“œì—ì„œ ë°ì´í„° ê°€ì ¸ì˜¤ê¸°
        vm = self.vm_data[idx]
        vm.date = self.entry_vm_date.get().strip()
        vm.operation = self.entry_vm_operation.get().strip()
        vm.development = self.entry_vm_development.get().strip()
        vm.fab = self.entry_vm_fab.get().strip()
        vm.model_name = self.entry_vm_model_name.get().strip()
        vm.version = self.entry_vm_version.get().strip()
        vm.total_predict = self.entry_vm_total_predict.get().strip()
        vm.early_detect = self.entry_vm_early_detect.get().strip()
        vm.model_desc = self.entry_vm_model_desc.get().strip()
        
        if not vm.version:
            messagebox.showwarning("ê²½ê³ ", "ë²„ì „ì€ í•„ìˆ˜ ì…ë ¥ì…ë‹ˆë‹¤.")
            return
        
        # í…Œì´ë¸” ì—…ë°ì´íŠ¸
        self.vm_tree.item(item, values=vm.to_row())
        self._auto_save_vm()  # ìë™ ì €ì¥
        messagebox.showinfo("ìˆ˜ì • ì™„ë£Œ", "í•­ëª©ì´ ìˆ˜ì •ë˜ì—ˆìŠµë‹ˆë‹¤.")
    
    def delete_vm_row(self):
        """ì„ íƒëœ í•­ëª© ì‚­ì œ"""
        selected = self.vm_tree.selection()
        if not selected:
            messagebox.showwarning("ê²½ê³ ", "ì‚­ì œí•  í•­ëª©ì„ ì„ íƒí•˜ì„¸ìš”.")
            return
        
        for item in selected:
            idx = self.vm_tree.index(item)
            self.vm_tree.delete(item)
            if idx < len(self.vm_data):
                del self.vm_data[idx]
        
        self._auto_save_vm()  # ìë™ ì €ì¥
    
    def clear_vm_inputs(self):
        """ì…ë ¥ í•„ë“œ ì´ˆê¸°í™”"""
        self.entry_vm_date.delete(0, tk.END)
        self.entry_vm_date.insert(0, datetime.now().strftime("%Y-%m-%d"))
        self.entry_vm_operation.delete(0, tk.END)
        self.entry_vm_development.delete(0, tk.END)
        self.entry_vm_fab.delete(0, tk.END)
        self.entry_vm_model_name.delete(0, tk.END)
        self.entry_vm_version.delete(0, tk.END)
        self.entry_vm_total_predict.delete(0, tk.END)
        self.entry_vm_early_detect.delete(0, tk.END)
        self.entry_vm_model_desc.delete(0, tk.END)
    
    def save_vm_csv(self):
        """ë²„ì „ ê´€ë¦¬ CSV ì €ì¥"""
        filename = filedialog.asksaveasfilename(
            defaultextension=".csv",
            filetypes=[("CSV files", "*.csv"), ("All files", "*.*")],
            initialfile="version_management.csv"
        )
        if not filename:
            return
        
        with open(filename, 'w', newline='', encoding='utf-8-sig') as f:
            writer = csv.writer(f)
            writer.writerow(VersionManagement.csv_header())
            for vm in self.vm_data:
                writer.writerow(vm.to_row())
        
        messagebox.showinfo("ì €ì¥ ì™„ë£Œ", f"CSV ì €ì¥: {filename}")
    
    def load_vm_csv(self):
        """ë²„ì „ ê´€ë¦¬ CSV ë¶ˆëŸ¬ì˜¤ê¸°"""
        filename = filedialog.askopenfilename(
            filetypes=[("CSV files", "*.csv"), ("All files", "*.*")]
        )
        if not filename:
            return
        
        try:
            with open(filename, 'r', encoding='utf-8-sig') as f:
                reader = csv.reader(f)
                header = next(reader)  # í—¤ë” ìŠ¤í‚µ
                
                # ê¸°ì¡´ ë°ì´í„° í´ë¦¬ì–´
                self.vm_data.clear()
                for item in self.vm_tree.get_children():
                    self.vm_tree.delete(item)
                
                # ìƒˆ ë°ì´í„° ë¡œë“œ
                for row in reader:
                    vm = VersionManagement.from_row(row)
                    self.vm_data.append(vm)
                    self.vm_tree.insert('', tk.END, values=vm.to_row())
            
            self._auto_save_vm()  # ìë™ ì €ì¥
            messagebox.showinfo("ë¡œë“œ ì™„ë£Œ", f"CSV ë¡œë“œ: {filename}")
        except Exception as e:
            messagebox.showerror("ì˜¤ë¥˜", f"CSV ë¡œë“œ ì‹¤íŒ¨: {e}")
    
    def create_preview_tab(self):
        """ë¯¸ë¦¬ë³´ê¸° íƒ­"""
        frame = ttk.Frame(self.tab_preview, padding=10)
        frame.pack(fill=tk.BOTH, expand=True)
        
        ttk.Button(frame, text="ğŸ”„ ìƒˆë¡œê³ ì¹¨", command=self.refresh_preview).pack(anchor='w', pady=5)
        
        self.text_preview = scrolledtext.ScrolledText(
            frame, 
            font=('Consolas', 10),
            bg=self.colors['card'], 
            fg=self.colors['fg'],
            wrap=tk.NONE
        )
        self.text_preview.pack(fill=tk.BOTH, expand=True, pady=5)
    
    # ===== ê¸°ëŠ¥ ë©”ì„œë“œ =====
    
    def load_or_create_sample(self):
        """íŒŒì¼ ë¡œë“œ ë˜ëŠ” ìƒ˜í”Œ ìƒì„±"""
        if os.path.exists(self.save_file):
            self._load_from_file(self.save_file)
        else:
            self._create_sample_data()
        self.refresh_version_list()
    
    def _create_sample_data(self):
        """ìƒ˜í”Œ ë°ì´í„° ìƒì„±"""
        # V8
        v8 = PatchNote("V8.0.0", "2025-12-01", "Major")
        v8.important = [
            "V7 ëª¨ë¸ê³¼ í˜¸í™˜ë˜ì§€ ì•ŠìŒ - ë°˜ë“œì‹œ V8 ì½”ë“œ ì‚¬ìš©",
            "ê¸°ì¡´ patch_notes.json ì‚­ì œ í›„ ì¬ì‹¤í–‰ í•„ìš”",
        ]
        v8.new = [
            "ë²”ì£¼í˜• 3-Class ë¶„ë¥˜ ëª¨ë¸ ì¶”ê°€ (í•˜ë½/ì†Œí­/ê¸‰ì¦)",
            "M16HUB QUE ì»¬ëŸ¼ 5ê°œ ì¶”ê°€",
            "M16A QUE ì»¬ëŸ¼ 7ê°œ ì¶”ê°€",
            "CURRENT_M16A_3F_JOB ëŒ€ì²´ íƒ€ê²Ÿ ì»¬ëŸ¼ ì¶”ê°€",
        ]
        v8.improved = [
            "ì…ë ¥ ì»¬ëŸ¼: 19ê°œ â†’ 32ê°œ",
            "Feature ìˆ˜: 180ê°œ â†’ 222ê°œ",
            "ìˆ˜ì¹˜í˜• ëª¨ë¸: 50+ ë³€í™” ìƒ˜í”Œ 3ë°° ê°€ì¤‘ì¹˜ ì ìš©",
            "ë²”ì£¼í˜• ëª¨ë¸: Class2(ê¸‰ì¦) 5ë°° ê°€ì¤‘ì¹˜ ì ìš©",
        ]
        v8.metrics = [
            "MAE: 12.5 â†’ 9.8 (â†“21%)",
            "RÂ²: 0.62 â†’ 0.68 (â†‘9.7%)",
            "ë²”ì£¼í˜• ì •í™•ë„: 72% (ì‹ ê·œ)",
        ]
        v8.breaking = ["V7 ëª¨ë¸ íŒŒì¼(.pkl)ê³¼ í˜¸í™˜ë˜ì§€ ì•ŠìŒ", "V8 ì „ìš© í‰ê°€ ì½”ë“œ ì‚¬ìš© í•„ìš”"]
        v8.files = [
            "V8_ìˆ˜ì¹˜í˜•_í•™ìŠµì½”ë“œ.py", "V8_ìˆ˜ì¹˜í˜•_í‰ê°€ì½”ë“œ.py",
            "V8_ë²”ì£¼í˜•_í•™ìŠµì½”ë“œ.py", "V8_ë²”ì£¼í˜•_í‰ê°€ì½”ë“œ.py",
            "xgboost_ìˆ˜ì¹˜í˜•_V8.pkl", "xgboost_ë²”ì£¼í˜•_V8.pkl"
        ]
        v8.next = ["MLflow Tracking ì—°ë™", "í•˜ì´í¼íŒŒë¼ë¯¸í„° ìë™ íƒìƒ‰ (Optuna)"]
        self.notes["V8.0.0"] = v8
        
        # V7
        v7 = PatchNote("V7.0.0", "2025-11-15", "Major")
        v7.new = ["M16HUB.QUE.ALL.CURRENTQCNT ì»¬ëŸ¼ ì¶”ê°€", "QUE ê¸°ë°˜ ë³‘ëª© ê°ì§€ Feature ì¶”ê°€"]
        v7.improved = ["ì…ë ¥ ì»¬ëŸ¼: 17ê°œ â†’ 19ê°œ", "ë³‘ëª© ê°ì§€ ë¡œì§ ê°•í™”"]
        v7.metrics = ["MAE: 14.2 â†’ 12.5 (â†“12%)"]
        v7.fixed = ["HUBROOMTOTAL ê²°ì¸¡ì¹˜ ì²˜ë¦¬ ì˜¤ë¥˜ ìˆ˜ì •"]
        v7.breaking = ["V6 ëª¨ë¸ íŒŒì¼ê³¼ í˜¸í™˜ë˜ì§€ ì•ŠìŒ"]
        v7.next = ["ë²”ì£¼í˜• ë¶„ë¥˜ ëª¨ë¸ ì¶”ê°€"]
        self.notes["V7.0.0"] = v7
        
        # V6
        v6 = PatchNote("V6.0.0", "2025-10-20", "Major")
        v6.new = ["ë©€í‹°ì•„ì›ƒí’‹ êµ¬ì¡° ë„ì… (MIN/MAX/AVG)", "10ë¶„ êµ¬ê°„ í†µê³„ ì˜ˆì¸¡"]
        v6.improved = ["Feature ìˆ˜: 120ê°œ â†’ 165ê°œ", "ì‹œí€€ìŠ¤ ê¸¸ì´: 20ë¶„ â†’ 30ë¶„"]
        v6.metrics = ["MAE: 18.5 â†’ 14.2 (â†“23%)"]
        v6.fixed = ["í° ë³€í™” ì˜ˆì¸¡ ëˆ„ë½ ë¬¸ì œ í•´ê²°"]
        v6.breaking = ["ë‹¨ì¼ ì¶œë ¥ â†’ ë©€í‹° ì¶œë ¥ êµ¬ì¡° ë³€ê²½"]
        self.notes["V6.0.0"] = v6
    
    def refresh_version_list(self):
        """ë²„ì „ ëª©ë¡ ê°±ì‹ """
        self.version_listbox.delete(0, tk.END)
        for version in sorted(self.notes.keys(), reverse=True):
            self.version_listbox.insert(tk.END, version)
        
        if self.notes:
            self.version_listbox.selection_set(0)
            self.on_version_select(None)
    
    def on_version_select(self, event):
        """ë²„ì „ ì„ íƒ ì‹œ"""
        selection = self.version_listbox.curselection()
        if not selection:
            return
        
        version = self.version_listbox.get(selection[0])
        self.current_version = version
        self.load_note_to_ui(self.notes[version])
    
    def load_note_to_ui(self, note: PatchNote):
        """íŒ¨ì¹˜ë…¸íŠ¸ë¥¼ UIì— ë¡œë“œ"""
        # ê¸°ë³¸ ì •ë³´
        self.entry_version.delete(0, tk.END)
        self.entry_version.insert(0, note.version)
        
        self.entry_date.delete(0, tk.END)
        self.entry_date.insert(0, note.date)
        
        self.combo_type.set(note.type)
        
        self.text_important.delete('1.0', tk.END)
        self.text_important.insert('1.0', '\n'.join(note.important))
        
        self.text_breaking.delete('1.0', tk.END)
        self.text_breaking.insert('1.0', '\n'.join(note.breaking))
        
        self.text_next.delete('1.0', tk.END)
        self.text_next.insert('1.0', '\n'.join(note.next))
        
        # ë³€ê²½ì‚¬í•­
        self.text_new.delete('1.0', tk.END)
        self.text_new.insert('1.0', '\n'.join(note.new))
        
        self.text_improved.delete('1.0', tk.END)
        self.text_improved.insert('1.0', '\n'.join(note.improved))
        
        self.text_fixed.delete('1.0', tk.END)
        self.text_fixed.insert('1.0', '\n'.join(note.fixed))
        
        # ì„±ëŠ¥/íŒŒì¼
        self.text_metrics.delete('1.0', tk.END)
        self.text_metrics.insert('1.0', '\n'.join(note.metrics))
        
        self.text_files.delete('1.0', tk.END)
        self.text_files.insert('1.0', '\n'.join(note.files))
        
        # ë¯¸ë¦¬ë³´ê¸°
        self.refresh_preview()
    
    def save_ui_to_note(self) -> Optional[PatchNote]:
        """UIì—ì„œ íŒ¨ì¹˜ë…¸íŠ¸ë¡œ ì €ì¥"""
        version = self.entry_version.get().strip()
        if not version:
            messagebox.showerror("ì˜¤ë¥˜", "ë²„ì „ì„ ì…ë ¥í•˜ì„¸ìš”")
            return None
        
        note = PatchNote(
            version,
            self.entry_date.get().strip() or datetime.now().strftime("%Y-%m-%d"),
            self.combo_type.get()
        )
        
        note.new = [x.strip() for x in self.text_new.get('1.0', tk.END).strip().split('\n') if x.strip()]
        note.improved = [x.strip() for x in self.text_improved.get('1.0', tk.END).strip().split('\n') if x.strip()]
        note.fixed = [x.strip() for x in self.text_fixed.get('1.0', tk.END).strip().split('\n') if x.strip()]
        note.breaking = [x.strip() for x in self.text_breaking.get('1.0', tk.END).strip().split('\n') if x.strip()]
        note.next = [x.strip() for x in self.text_next.get('1.0', tk.END).strip().split('\n') if x.strip()]
        note.files = [x.strip() for x in self.text_files.get('1.0', tk.END).strip().split('\n') if x.strip()]
        note.metrics = [x.strip() for x in self.text_metrics.get('1.0', tk.END).strip().split('\n') if x.strip()]
        note.important = [x.strip() for x in self.text_important.get('1.0', tk.END).strip().split('\n') if x.strip()]
        
        return note
    
    def refresh_preview(self):
        """ë¯¸ë¦¬ë³´ê¸° ê°±ì‹ """
        note = self.save_ui_to_note()
        if not note:
            return
        
        preview = self._generate_preview(note)
        self.text_preview.delete('1.0', tk.END)
        self.text_preview.insert('1.0', preview)
    
    def _generate_preview(self, note: PatchNote) -> str:
        """ë¯¸ë¦¬ë³´ê¸° í…ìŠ¤íŠ¸ ìƒì„±"""
        lines = []
        w = 58
        
        lines.append("â”Œ" + "â”€" * w + "â”")
        lines.append(f"â”‚  AMHS ì˜ˆì¸¡ ëª¨ë¸ {note.version}".ljust(w) + " â”‚")
        lines.append(f"â”‚  {note.date} | {note.type} Update".ljust(w) + " â”‚")
        lines.append("â”œ" + "â”€" * w + "â”¤")
        
        if note.important:
            lines.append(f"â”‚  [âš ï¸ IMPORTANT] ì¤‘ìš” ì •ë³´".ljust(w) + " â”‚")
            for item in note.important:
                line = f"â”‚    â€¢ {item}"
                lines.append(line[:w].ljust(w) + " â”‚")
        
        if note.new:
            lines.append(f"â”‚  [NEW] ì‹ ê·œ ê¸°ëŠ¥".ljust(w) + " â”‚")
            for item in note.new:
                line = f"â”‚    â€¢ {item}"
                lines.append(line[:w].ljust(w) + " â”‚")
        
        if note.improved:
            lines.append(f"â”‚  [IMPROVED] ê°œì„ ì‚¬í•­".ljust(w) + " â”‚")
            for item in note.improved:
                line = f"â”‚    â€¢ {item}"
                lines.append(line[:w].ljust(w) + " â”‚")
        
        if note.metrics:
            lines.append(f"â”‚  [METRICS] ì„±ëŠ¥ ë³€í™”".ljust(w) + " â”‚")
            for item in note.metrics:
                line = f"â”‚    â€¢ {item}"
                lines.append(line[:w].ljust(w) + " â”‚")
        
        lines.append(f"â”‚  [FIXED] ë²„ê·¸ ìˆ˜ì •".ljust(w) + " â”‚")
        if note.fixed:
            for item in note.fixed:
                line = f"â”‚    â€¢ {item}"
                lines.append(line[:w].ljust(w) + " â”‚")
        else:
            lines.append(f"â”‚    â€¢ ì—†ìŒ".ljust(w) + " â”‚")
        
        if note.breaking:
            lines.append(f"â”‚  [BREAKING] í˜¸í™˜ì„±".ljust(w) + " â”‚")
            for item in note.breaking:
                line = f"â”‚    â€¢ {item}"
                lines.append(line[:w].ljust(w) + " â”‚")
        
        if note.files:
            lines.append(f"â”‚  [FILES] ë³€ê²½ íŒŒì¼".ljust(w) + " â”‚")
            for item in note.files:
                line = f"â”‚    â€¢ {item}"
                lines.append(line[:w].ljust(w) + " â”‚")
        
        if note.next:
            lines.append(f"â”‚  [NEXT] ë‹¤ìŒ ë²„ì „ ì˜ˆê³ ".ljust(w) + " â”‚")
            for item in note.next:
                line = f"â”‚    â€¢ {item}"
                lines.append(line[:w].ljust(w) + " â”‚")
        
        lines.append("â””" + "â”€" * w + "â”˜")
        
        return '\n'.join(lines)
    
    def save_notes(self):
        """ì €ì¥"""
        # í˜„ì¬ í¸ì§‘ ì¤‘ì¸ ë…¸íŠ¸ ì €ì¥
        if self.current_version:
            note = self.save_ui_to_note()
            if note:
                # ë²„ì „ì´ ë³€ê²½ëœ ê²½ìš°
                if note.version != self.current_version:
                    del self.notes[self.current_version]
                self.notes[note.version] = note
                self.current_version = note.version
        
        # íŒŒì¼ë¡œ ì €ì¥
        data = {
            "project": "AMHS ì˜ˆì¸¡ ëª¨ë¸",
            "updated": datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
            "notes": {v: n.to_dict() for v, n in self.notes.items()}
        }
        
        with open(self.save_file, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=2)
        
        self.refresh_version_list()
        messagebox.showinfo("ì €ì¥", f"ì €ì¥ ì™„ë£Œ: {self.save_file}")
    
    def load_notes(self):
        """ë¡œë“œ"""
        filename = filedialog.askopenfilename(
            filetypes=[("JSON files", "*.json"), ("All files", "*.*")]
        )
        if filename:
            self._load_from_file(filename)
            self.refresh_version_list()
            messagebox.showinfo("ë¡œë“œ", f"ë¡œë“œ ì™„ë£Œ: {filename}")
    
    def _load_from_file(self, filename):
        """íŒŒì¼ì—ì„œ ë¡œë“œ"""
        with open(filename, 'r', encoding='utf-8') as f:
            data = json.load(f)
        
        self.notes = {}
        for version, note_data in data.get("notes", {}).items():
            self.notes[version] = PatchNote.from_dict(note_data)
    
    def export_md(self):
        """ë§ˆí¬ë‹¤ìš´ ë‚´ë³´ë‚´ê¸°"""
        filename = filedialog.asksaveasfilename(
            defaultextension=".md",
            filetypes=[("Markdown files", "*.md"), ("All files", "*.*")],
            initialfile="PATCH_NOTES.md"
        )
        if not filename:
            return
        
        lines = []
        lines.append("# AMHS ì˜ˆì¸¡ ëª¨ë¸ íŒ¨ì¹˜ë…¸íŠ¸\n")
        lines.append(f"*ìµœì¢… ì—…ë°ì´íŠ¸: {datetime.now().strftime('%Y-%m-%d')}*\n")
        
        for version in sorted(self.notes.keys(), reverse=True):
            note = self.notes[version]
            lines.append(f"\n---\n")
            lines.append(f"## {note.version} ({note.date})\n")
            lines.append(f"**{note.type} Update**\n")
            
            if note.important:
                lines.append("\n### âš ï¸ ì¤‘ìš” ì •ë³´\n")
                for item in note.important:
                    lines.append(f"- {item}\n")
            
            if note.new:
                lines.append("\n### âœ¨ ì‹ ê·œ ê¸°ëŠ¥\n")
                for item in note.new:
                    lines.append(f"- {item}\n")
            
            if note.improved:
                lines.append("\n### â¬†ï¸ ê°œì„ ì‚¬í•­\n")
                for item in note.improved:
                    lines.append(f"- {item}\n")
            
            if note.metrics:
                lines.append("\n### ğŸ“Š ì„±ëŠ¥ ë³€í™”\n")
                for item in note.metrics:
                    lines.append(f"- {item}\n")
            
            if note.fixed:
                lines.append("\n### ğŸ”§ ë²„ê·¸ ìˆ˜ì •\n")
                for item in note.fixed:
                    lines.append(f"- {item}\n")
            
            if note.breaking:
                lines.append("\n### âš ï¸ Breaking Changes\n")
                for item in note.breaking:
                    lines.append(f"- {item}\n")
            
            if note.files:
                lines.append("\n### ğŸ“ ë³€ê²½ íŒŒì¼\n")
                for item in note.files:
                    lines.append(f"- `{item}`\n")
            
            if note.next:
                lines.append("\n### ğŸ”® ë‹¤ìŒ ë²„ì „ ì˜ˆê³ \n")
                for item in note.next:
                    lines.append(f"- {item}\n")
        
        with open(filename, 'w', encoding='utf-8') as f:
            f.writelines(lines)
        
        messagebox.showinfo("ë‚´ë³´ë‚´ê¸°", f"MD ì €ì¥ ì™„ë£Œ: {filename}")
    
    def new_version_dialog(self):
        """ìƒˆ ë²„ì „ ë‹¤ì´ì–¼ë¡œê·¸"""
        dialog = tk.Toplevel(self.root)
        dialog.title("ìƒˆ íŒ¨ì¹˜ë…¸íŠ¸")
        dialog.geometry("300x150")
        dialog.configure(bg=self.colors['bg'])
        dialog.transient(self.root)
        dialog.grab_set()
        
        ttk.Label(dialog, text="ìƒˆ ë²„ì „:").pack(pady=10)
        entry = ttk.Entry(dialog, font=('ë§‘ì€ ê³ ë”•', 12), width=20)
        entry.pack(pady=5)
        entry.insert(0, "V9.0.0")
        entry.focus()
        
        def create():
            version = entry.get().strip()
            if version:
                if version in self.notes:
                    messagebox.showerror("ì˜¤ë¥˜", "ì´ë¯¸ ì¡´ì¬í•˜ëŠ” ë²„ì „ì…ë‹ˆë‹¤")
                    return
                self.notes[version] = PatchNote(version)
                self.refresh_version_list()
                # ìƒˆ ë²„ì „ ì„ íƒ
                idx = list(sorted(self.notes.keys(), reverse=True)).index(version)
                self.version_listbox.selection_clear(0, tk.END)
                self.version_listbox.selection_set(idx)
                self.on_version_select(None)
                dialog.destroy()
        
        ttk.Button(dialog, text="ìƒì„±", command=create).pack(pady=15)
    
    def delete_version(self):
        """ë²„ì „ ì‚­ì œ"""
        if not self.current_version:
            return
        
        if messagebox.askyesno("ì‚­ì œ í™•ì¸", f"{self.current_version}ì„(ë¥¼) ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?"):
            del self.notes[self.current_version]
            self.current_version = None
            self.refresh_version_list()


def main():
    root = tk.Tk()
    app = PatchNoteApp(root)
    root.mainloop()


if __name__ == "__main__":
    main()